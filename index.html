<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>D&D Player Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="mobile-web-app-capable" content="yes" />

  <!-- Tailwind CSS (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- React + ReactDOM 17 from jsDelivr -->
  <script src="https://cdn.jsdelivr.net/npm/react@17/umd/react.development.js" crossorigin></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@17/umd/react-dom.development.js" crossorigin></script>

  <!-- Babel for inline JSX -->
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

  <!-- D&D-ish font -->
  <link href="https://fonts.googleapis.com/css2?family=Cinzel&display=swap" rel="stylesheet" />

  <style>
    body {
      font-family: 'Cinzel', serif;
      background: #f4e4bc url("https://www.transparenttextures.com/patterns/aged-paper.png") repeat;
      background-blend-mode: overlay;
      color: #4a2c0f;
    }

    .dark {
      background-color: #1a1a1a;
      color: #fafafa;
      background-blend-mode: normal;
    }

    ::-webkit-scrollbar {
      width: 12px;
    }
    ::-webkit-scrollbar-track {
      background: #f5e8c7;
    }
    ::-webkit-scrollbar-thumb {
      background-color: #8b5a2b;
      border-radius: 20px;
      border: 3px solid #f5e8c7;
    }
  </style>
</head>

<body class="text-gray-800">
  <div id="root" class="p-4"></div>

  <script type="text/babel">
    /************************************************
     * Components:
     * 1) LocalStorage Backup/Restore
     * 2) Hook for Expand/Collapse
     * 3) Dark Mode Toggle
     * 4) CharacterCard (with Background/Bio and Image)
     * 5) EnemyCard
     * 6) StatsSection
     * 7) DiceRoller
     * 8) MapSection (Fixed)
     * 9) PartyImages
     * 10) CopyButton
     * 11) ClassesSection
     * 12) RacesSection
     * 13) MonsterCreatureList
     * 14) BulkActions
     * 15) Main DnDTracker
     ************************************************/

    /** 1) LocalStorage Backup/Restore */
    function backupLocalStorage() {
      const data = {
        characters: localStorage.getItem("characters"),
        enemies: localStorage.getItem("enemies"),
        statRows: localStorage.getItem("statRows"),
        mapImage: localStorage.getItem("mapImage"),
        dotPositions: localStorage.getItem("dotPositions"),
        collapsedCharacters: localStorage.getItem("collapsedCharacters"),
        collapsedEnemies: localStorage.getItem("collapsedEnemies"),
        darkMode: localStorage.getItem("darkMode"),
      };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "dnd_tracker_backup.json";
      a.click();
      URL.revokeObjectURL(url);
    }

    function restoreLocalStorage(files) {
      if (!files || !files.length) return;
      const file = files[0];
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          for (const key in data) {
            if (data[key] !== null && data[key] !== undefined) {
              localStorage.setItem(key, data[key]);
            }
          }
          alert("LocalStorage restored. Please refresh the page.");
        } catch (err) {
          console.error(err);
          alert("Failed to restore. Invalid JSON?");
        }
      };
      reader.readAsText(file);
    }

    /** 2) Hook for Expand/Collapse */
    function useCollapseState(storageKey) {
      const [collapseState, setCollapseState] = React.useState(() => {
        const saved = localStorage.getItem(storageKey);
        return saved ? JSON.parse(saved) : {};
      });

      function toggleCollapse(id) {
        setCollapseState((prev) => {
          const newVal = { ...prev, [id]: !prev[id] };
          localStorage.setItem(storageKey, JSON.stringify(newVal));
          return newVal;
        });
      }

      return [collapseState, toggleCollapse];
    }

    /** 3) Dark Mode Toggle */
    function DarkModeToggle() {
      const [darkMode, setDarkMode] = React.useState(() => localStorage.getItem("darkMode") === "true");

      React.useEffect(() => {
        if (darkMode) document.body.classList.add("dark");
        else document.body.classList.remove("dark");
        localStorage.setItem("darkMode", darkMode);
      }, [darkMode]);

      return (
        <button className="px-3 py-1 bg-amber-700 text-white rounded hover:bg-amber-800" onClick={() => setDarkMode(!darkMode)}>
          {darkMode ? "Light Mode" : "Dark Mode"}
        </button>
      );
    }

    /** 4) CharacterCard (Enhanced with Background/Bio and Image) */
    function CharacterCard({
      char,
      collapsed,
      onToggleCollapse,
      onUpdateChar,
      onHeal,
      onDamage,
      onRemoveStatus,
      onRemoveEffect,
      onRemoveItem,
      onRemoveAbility,
      onRemoveSpell,
      onRemoveChar,
    }) {
      const [isEditing, setIsEditing] = React.useState(false);
      const [editName, setEditName] = React.useState(char.name);
      const [editClass, setEditClass] = React.useState(char.class);
      const [editMaxHealth, setEditMaxHealth] = React.useState(String(char.maxHealth));
      const [editLevel, setEditLevel] = React.useState(String(char.level || 1));
      const [editXP, setEditXP] = React.useState(String(char.xp || 0));
      const [editInitiative, setEditInitiative] = React.useState(String(char.initiative || 0));
      const [editNotes, setEditNotes] = React.useState(char.notes || "");
      const [newStatus, setNewStatus] = React.useState("");
      const [newEffect, setNewEffect] = React.useState("");
      const [newItem, setNewItem] = React.useState("");
      const [newAbility, setNewAbility] = React.useState("");
      const [newSpell, setNewSpell] = React.useState("");
      const [healInput, setHealInput] = React.useState("0");
      const [dmgInput, setDmgInput] = React.useState("0");

      React.useEffect(() => {
        setEditName(char.name);
        setEditClass(char.class);
        setEditMaxHealth(String(char.maxHealth));
        setEditLevel(String(char.level || 1));
        setEditXP(String(char.xp || 0));
        setEditInitiative(String(char.initiative || 0));
        setEditNotes(char.notes || "");
      }, [char]);

      function handleImageUpload(e) {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (evt) => onUpdateChar({ ...char, image: evt.target.result });
          reader.readAsDataURL(file);
        }
      }

      function handleSave() {
        const parsedMax = parseInt(editMaxHealth, 10) || 0;
        const clippedHealth = Math.min(char.health, parsedMax);
        onUpdateChar({
          ...char,
          name: editName,
          class: editClass,
          maxHealth: parsedMax,
          health: clippedHealth,
          level: parseInt(editLevel, 10) || 1,
          xp: parseInt(editXP, 10) || 0,
          initiative: parseInt(editInitiative, 10) || 0,
          notes: editNotes,
        });
        setIsEditing(false);
      }

      function handleAddStatus() {
        if (!newStatus.trim()) return;
        onUpdateChar({ ...char, status: [...char.status, newStatus.trim()] });
        setNewStatus("");
      }

      function handleAddEffect() {
        if (!newEffect.trim()) return;
        onUpdateChar({ ...char, effects: [...char.effects, newEffect.trim()] });
        setNewEffect("");
      }

      function handleAddItem() {
        if (!newItem.trim()) return;
        onUpdateChar({ ...char, inventory: [...char.inventory, newItem.trim()] });
        setNewItem("");
      }

      function handleAddAbility() {
        if (!newAbility.trim()) return;
        onUpdateChar({ ...char, specialAbilities: [...char.specialAbilities, newAbility.trim()] });
        setNewAbility("");
      }

      function handleAddSpell() {
        if (!newSpell.trim()) return;
        onUpdateChar({ ...char, spellsMagic: [...char.spellsMagic, newSpell.trim()] });
        setNewSpell("");
      }

      function applyHeal() {
        onHeal(char.id, parseInt(healInput, 10) || 0);
      }

      function applyDamage() {
        onDamage(char.id, parseInt(dmgInput, 10) || 0);
      }

      function toggleDeathSaveSuccess() {
        if (char.deathSaves.success < 3) {
          onUpdateChar({ ...char, deathSaves: { ...char.deathSaves, success: char.deathSaves.success + 1 } });
        }
      }

      function toggleDeathSaveFail() {
        if (char.deathSaves.fail < 3) {
          onUpdateChar({ ...char, deathSaves: { ...char.deathSaves, fail: char.deathSaves.fail + 1 } });
        }
      }

      function resetDeathSaves() {
        onUpdateChar({ ...char, deathSaves: { success: 0, fail: 0 } });
      }

      const mainContentStyle = collapsed ? { maxHeight: 0, padding: 0 } : { maxHeight: "9999px" };

      if (isEditing) {
        return (
          <div className="bg-white p-4 rounded-lg shadow space-y-2 mb-4">
            <div className="flex justify-between items-center">
              <h3 className="font-bold">Editing {char.name}</h3>
              <button className="px-2 py-1 bg-red-500 text-white rounded hover:bg-red-600" onClick={() => onRemoveChar(char.id)}>Remove</button>
            </div>
            <div className="grid grid-cols-2 gap-2">
              <input className="border p-1 rounded" placeholder="Name" value={editName} onChange={(e) => setEditName(e.target.value)} />
              <input className="border p-1 rounded" placeholder="Class" value={editClass} onChange={(e) => setEditClass(e.target.value)} />
              <input type="number" className="border p-1 rounded" placeholder="Max Health" value={editMaxHealth} onChange={(e) => setEditMaxHealth(e.target.value)} />
              <input type="number" className="border p-1 rounded" placeholder="Level" value={editLevel} onChange={(e) => setEditLevel(e.target.value)} />
              <input type="number" className="border p-1 rounded" placeholder="XP" value={editXP} onChange={(e) => setEditXP(e.target.value)} />
              <input type="number" className="border p-1 rounded" placeholder="Initiative" value={editInitiative} onChange={(e) => setEditInitiative(e.target.value)} />
            </div>
            <textarea className="border p-1 rounded w-full" rows={3} placeholder="Notes / Bio / Extra Info" value={editNotes} onChange={(e) => setEditNotes(e.target.value)} />
            <div className="flex gap-2">
              <button className="px-3 py-1 bg-green-500 text-white rounded hover:bg-green-600" onClick={handleSave}>Save</button>
              <button className="px-2 py-1 bg-gray-400 text-white rounded hover:bg-gray-500" onClick={() => setIsEditing(false)}>Cancel</button>
            </div>
          </div>
        );
      }

      return (
        <div className={`bg-white p-4 rounded-lg shadow mb-4 ${collapsed ? "collapsed" : ""}`}>
          <div className="flex justify-between items-center">
            <div className="flex items-center gap-2">
              <button onClick={() => onToggleCollapse(char.id)} className="text-sm font-bold">{char.name}</button>
              <span className="text-sm text-gray-600">({char.class})</span>
            </div>
            <div className="flex items-center gap-2">
              <span className="text-sm">Init: {char.initiative || 0} | Lvl: {char.level || 1}</span>
              <button className="px-2 py-1 bg-amber-700 text-white rounded hover:bg-amber-800 text-sm" onClick={() => setIsEditing(true)}>Edit</button>
              <button className="px-2 py-1 bg-red-500 text-white rounded hover:bg-red-600 text-sm" onClick={() => onRemoveChar(char.id)}>Remove</button>
            </div>
          </div>

          <div className="transition-all duration-300 ease-in-out" style={mainContentStyle}>
            <div className={collapsed ? "hidden" : "block"}>
              <div className="text-sm mb-1 mt-2">XP: {char.xp || 0}</div>
              <div className="flex items-start gap-4 mt-2">
                <div>
                  <label className="block text-sm font-medium text-gray-700">Character Image</label>
                  <div className="flex items-center gap-2 mt-1">
                    {char.image ? (
                      <img src={char.image} alt={char.name} className="w-12 h-12 object-cover rounded-full" />
                    ) : (
                      <div className="w-12 h-12 bg-gray-300 rounded-full flex items-center justify-center text-gray-500 text-xs">No Image</div>
                    )}
                    <input type="file" accept="image/*" onChange={handleImageUpload} className="mt-1 text-sm" />
                    {char.image && (
                      <button className="px-2 py-1 bg-red-500 text-white rounded hover:bg-red-600 text-sm" onClick={() => onUpdateChar({ ...char, image: null })}>
                        Remove Image
                      </button>
                    )}
                  </div>
                </div>
                <div className="flex-1">
                  <h4 className="font-semibold text-sm">Background/Bio:</h4>
                  <p className="text-sm whitespace-pre-line">{char.notes || "No background information available."}</p>
                </div>
              </div>

              <div className="flex items-center gap-2 mt-2">
                <span className="text-red-600 font-bold">♥</span>
                <div className="w-full bg-gray-200 rounded-full h-4">
                  <div className="bg-red-600 rounded-full h-4" style={{ width: (char.health / char.maxHealth) * 100 + "%" }}></div>
                </div>
                <span className="text-sm">{char.health}/{char.maxHealth}</span>
              </div>

              <div className="mt-4 flex gap-4 flex-wrap">
                <div>
                  <label className="text-sm block">Heal #</label>
                  <div className="flex items-center gap-2">
                    <input type="number" className="w-16 border rounded p-1 text-sm" value={healInput} onChange={(e) => setHealInput(e.target.value)} />
                    <button className="px-3 py-1 bg-green-500 text-white rounded hover:bg-green-600 text-sm" onClick={applyHeal}>Heal</button>
                  </div>
                </div>
                <div>
                  <label className="text-sm block">Damage #</label>
                  <div className="flex items-center gap-2">
                    <input type="number" className="w-16 border rounded p-1 text-sm" value={dmgInput} onChange={(e) => setDmgInput(e.target.value)} />
                    <button className="px-3 py-1 bg-red-500 text-white rounded hover:bg-red-600 text-sm" onClick={applyDamage}>Damage</button>
                  </div>
                </div>
              </div>

              <div className="mt-2">
                <label className="text-sm block">Status</label>
                <div className="flex flex-wrap gap-2 mt-1">
                  {char.status.map((s, idx) => (
                    <span key={idx} className="inline-flex items-center px-2 py-1 bg-gray-200 rounded text-sm">
                      {s} <button className="ml-1 text-red-500 hover:text-red-700" onClick={() => onRemoveStatus(char.id, idx)}>×</button>
                    </span>
                  ))}
                  <input type="text" className="border rounded p-1 text-sm" value={newStatus} onChange={(e) => setNewStatus(e.target.value)} placeholder="Add status" onKeyPress={(e) => e.key === "Enter" && handleAddStatus()} />
                  <button className="px-2 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm" onClick={handleAddEffect}>Add</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    }

    /** 5) EnemyCard */
    function EnemyCard({ enemy, collapsed, onToggleCollapse, onHealEnemy, onDamageEnemy, onRemoveEnemy, onUpdateEnemy }) {
      const [isEditing, setIsEditing] = React.useState(false);
      const [editName, setEditName] = React.useState(enemy.name);
      const [editMaxHealth, setEditMaxHealth] = React.useState(String(enemy.maxHealth));
      const [editHealth, setEditHealth] = React.useState(String(enemy.health));
      const [healInput, setHealInput] = React.useState("0");
      const [dmgInput, setDmgInput] = React.useState("0");

      React.useEffect(() => {
        setEditName(enemy.name);
        setEditMaxHealth(String(enemy.maxHealth));
        setEditHealth(String(enemy.health));
      }, [enemy]);

      function handleSave() {
        const parsedMax = parseInt(editMaxHealth, 10) || 0;
        const parsedHealth = parseInt(editHealth, 10) || 0;
        const clippedHealth = Math.min(parsedHealth, parsedMax);
        onUpdateEnemy({ ...enemy, name: editName, maxHealth: parsedMax, health: clippedHealth });
        setIsEditing(false);
      }

      function applyHeal() {
        onHealEnemy(enemy.id, parseInt(healInput, 10) || 0);
      }

      function applyDamage() {
        onDamageEnemy(enemy.id, parseInt(dmgInput, 10) || 0);
      }

      const mainContentStyle = collapsed ? { maxHeight: 0, padding: 0 } : { maxHeight: "9999px" };

      if (isEditing) {
        return (
          <div className="bg-white p-4 rounded-lg shadow space-y-2 mb-4">
            <div className="flex justify-between items-center">
              <h3 className="font-bold">Editing Enemy</h3>
              <button className="px-2 py-1 bg-red-500 text-white rounded hover:bg-red-600" onClick={() => onRemoveEnemy(enemy.id)}>Defeat</button>
            </div>
            <div className="flex flex-col gap-2">
              <input className="border p-1 rounded" placeholder="Name" value={editName} onChange={(e) => setEditName(e.target.value)} />
              <input type="number" className="border p-1 rounded" placeholder="Max Health" value={editMaxHealth} onChange={(e) => setEditMaxHealth(e.target.value)} />
              <input type="number" className="border p-1 rounded" placeholder="Current Health" value={editHealth} onChange={(e) => setEditHealth(e.target.value)} />
              <div className="flex gap-2">
                <button className="px-3 py-1 bg-green-500 text-white rounded hover:bg-green-600" onClick={handleSave}>Save</button>
                <button className="px-2 py-1 bg-gray-400 text-white rounded hover:bg-gray-500" onClick={() => setIsEditing(false)}>Cancel</button>
              </div>
            </div>
          </div>
        );
      }

      return (
        <div className={`bg-white p-4 rounded-lg shadow mb-4 ${collapsed ? "collapsed" : ""}`}>
          <div className="flex justify-between items-center">
            <button onClick={() => onToggleCollapse(enemy.id)} className="text-sm font-bold">{enemy.name}</button>
            <div className="flex gap-2 items-center">
              <button className="px-2 py-1 bg-amber-700 text-white rounded hover:bg-amber-800 text-sm" onClick={() => setIsEditing(true)}>Edit</button>
              <button className="px-2 py-1 bg-red-500 text-white rounded hover:bg-red-600 text-sm" onClick={() => onRemoveEnemy(enemy.id)}>Defeat</button>
            </div>
          </div>
          <div className="transition-all duration-300 ease-in-out" style={mainContentStyle}>
            <div className={collapsed ? "hidden" : "block"}>
              <div className="flex items-center gap-2 mt-2">
                <span className="text-red-600 font-bold">♥</span>
                <div className="w-full bg-gray-200 rounded-full h-4">
                  <div className="bg-red-600 rounded-full h-4" style={{ width: (enemy.health / enemy.maxHealth) * 100 + "%" }}></div>
                </div>
                <span className="text-sm">{enemy.health}/{enemy.maxHealth}</span>
              </div>
              <div className="mt-4 flex gap-4 flex-wrap">
                <div>
                  <label className="text-sm block">Heal #</label>
                  <div className="flex items-center gap-2">
                    <input type="number" className="w-16 border rounded p-1 text-sm" value={healInput} onChange={(e) => setHealInput(e.target.value)} />
                    <button className="px-3 py-1 bg-green-500 text-white rounded hover:bg-green-600 text-sm" onClick={applyHeal}>Heal</button>
                  </div>
                </div>
                <div>
                  <label className="text-sm block">Damage #</label>
                  <div className="flex items-center gap-2">
                    <input type="number" className="w-16 border rounded p-1 text-sm" value={dmgInput} onChange={(e) => setDmgInput(e.target.value)} />
                    <button className="px-3 py-1 bg-red-500 text-white rounded hover:bg-red-600 text-sm" onClick={applyDamage}>Damage</button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    }

    /** 6) StatsSection */
    function StatsSection({ statRows, setStatRows }) {
      const [nextId, setNextId] = React.useState(statRows.length ? Math.max(...statRows.map((r) => r.id)) + 1 : 2);

      function addStatRow() {
        setStatRows((prev) => [
          ...prev,
          { id: nextId, label: `Character #${nextId}`, str: 10, dex: 10, con: 10, int: 10, wis: 10, cha: 10 },
        ]);
        setNextId(nextId + 1);
      }

      function removeStatRow(rowId) {
        setStatRows((prev) => prev.filter((row) => row.id !== rowId));
      }

      function updateStatRow(rowId, updated) {
        setStatRows((prev) => prev.map((row) => (row.id === rowId ? updated : row)));
      }

      function clampScore(val) {
        return Math.max(6, Math.min(20, val));
      }

      function computeMod(score) {
        const mod = Math.floor((score - 10) / 2);
        return mod >= 0 ? "+" + mod : "" + mod;
      }

      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <div className="flex justify-between items-center mb-2">
            <h2 className="text-2xl font-bold">Stat Calculator</h2>
            <button className="px-2 py-1 bg-blue-500 text-white rounded hover:bg-blue-600" onClick={addStatRow}>Add Stat Row</button>
          </div>
          <p className="text-sm text-gray-700 mb-4">Enter scores (6–20) to see modifiers.</p>
          <div className="max-h-96 overflow-y-auto">
            {statRows.map((row) => {
              const modSTR = computeMod(row.str);
              const modDEX = computeMod(row.dex);
              const modCON = computeMod(row.con);
              const modINT = computeMod(row.int);
              const modWIS = computeMod(row.wis);
              const modCHA = computeMod(row.cha);

              return (
                <div key={row.id} className="bg-white p-4 rounded shadow mb-4 space-y-2">
                  <div className="flex justify-between items-center">
                    <input
                      className="border rounded p-1 text-sm"
                      value={row.label}
                      onChange={(e) => updateStatRow(row.id, { ...row, label: e.target.value })}
                    />
                    <button className="px-2 py-1 bg-red-500 text-white rounded hover:bg-red-600 text-sm" onClick={() => removeStatRow(row.id)}>Remove</button>
                  </div>
                  <div className="grid grid-cols-6 gap-2 mt-2">
                    {["str", "dex", "con", "int", "wis", "cha"].map((stat) => (
                      <div key={stat} className="flex flex-col">
                        <label className="font-semibold text-xs">{stat.toUpperCase()}</label>
                        <input
                          type="number"
                          className="border p-1 rounded text-sm"
                          value={row[stat]}
                          onChange={(e) => updateStatRow(row.id, { ...row, [stat]: clampScore(parseInt(e.target.value) || 10) })}
                        />
                        <span className="text-center text-blue-600 text-xs mt-1">{computeMod(row[stat])}</span>
                      </div>
                    ))}
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      );
    }

    /** 7) DiceRoller */
    function DiceRoller() {
      const [rollHistory, setRollHistory] = React.useState([]);
      const audioRef = React.useRef(null);

      function rollD(sides) {
        if (audioRef.current) {
          audioRef.current.currentTime = 0;
          audioRef.current.play().catch(() => {});
        }
        const result = Math.floor(Math.random() * sides) + 1;
        setRollHistory((prev) => [`d${sides} → ${result}`, ...prev.slice(0, 9)]);
      }

      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">Dice Roller</h2>
          <audio ref={audioRef} src="https://www.soundjay.com/misc/sounds/dice-1.mp3" />
          <div className="flex flex-wrap gap-2 mb-2">
            {[2, 4, 6, 8, 10, 12, 15, 20].map((sides) => (
              <button key={sides} onClick={() => rollD(sides)} className="px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm">
                d{sides}
              </button>
            ))}
          </div>
          <div>
            <h3 className="text-sm font-semibold mb-1">Recent Rolls:</h3>
            <ul className="list-disc list-inside text-sm max-h-24 overflow-y-auto">
              {rollHistory.length === 0 && <li>No rolls yet</li>}
              {rollHistory.map((entry, idx) => (
                <li key={idx}>{entry}</li>
              ))}
            </ul>
          </div>
        </div>
      );
    }

    /** 8) MapSection (Fixed) */
    function MapSection({ mapImage, setMapImage, dotPositions, setDotPositions }) {
      const [isDragging, setIsDragging] = React.useState(null);
      const mapRef = React.useRef(null);

      function handleImageUpload(event) {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            setMapImage(e.target.result);
            setDotPositions([
              { x: 20, y: 20, color: "red" },
              { x: 40, y: 40, color: "blue" },
              { x: 60, y: 60, color: "green" },
              { x: 80, y: 80, color: "purple" },
              { x: 50, y: 50, color: "orange" },
            ]);
          };
          reader.readAsDataURL(file);
        }
      }

      function handleDeleteImage() {
        setMapImage(null);
        setDotPositions([]);
      }

      function handleMouseDown(index) {
        return (e) => {
          e.preventDefault();
          setIsDragging(index);
        };
      }

      function handleMouseMove(e) {
        if (isDragging !== null && mapRef.current) {
          const rect = mapRef.current.getBoundingClientRect();
          const x = ((e.clientX - rect.left) / rect.width) * 100;
          const y = ((e.clientY - rect.top) / rect.height) * 100;
          setDotPositions((prev) =>
            prev.map((dot, i) =>
              i === isDragging ? { ...dot, x: Math.max(0, Math.min(100, x)), y: Math.max(0, Math.min(100, y)) } : dot
            )
          );
        }
      }

      function handleMouseUp() {
        setIsDragging(null);
      }

      return (
        <div className="bg-gray-100 p-4 rounded-lg mb-4">
          <h2 className="text-xl font-bold mb-2">Party & Enemy Location Map</h2>
          {mapImage ? (
            <div style={{ position: "relative" }}>
              <div
                ref={mapRef}
                className="w-full h-96 overflow-hidden"
                onMouseMove={handleMouseMove}
                onMouseUp={handleMouseUp}
                onMouseLeave={handleMouseUp}
              >
                <img src={mapImage} alt="Map" className="w-full h-full object-contain" />
                {dotPositions.map((dot, index) => (
                  <div
                    key={index}
                    className="absolute rounded-full border-2 border-white select-none"
                    style={{
                      width: "16px",
                      height: "16px",
                      left: `${dot.x}%`,
                      top: `${dot.y}%`,
                      transform: "translate(-50%, -50%)",
                      backgroundColor: dot.color,
                      cursor: isDragging === index ? "grabbing" : "grab",
                      zIndex: 10,
                    }}
                    onMouseDown={handleMouseDown(index)}
                  />
                ))}
              </div>
              <div className="mt-2 flex justify-between items-center">
                <p className="text-xs text-gray-700">Red: P1 | Blue: P2 | Green: P3 | Purple: P4 | Orange: Enemies</p>
                <button className="px-2 py-1 bg-red-500 text-white rounded hover:bg-red-600 text-sm" onClick={handleDeleteImage}>Delete Map</button>
              </div>
            </div>
          ) : (
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">Upload Map Image</label>
              <input type="file" accept="image/*" onChange={handleImageUpload} className="border p-1 rounded text-sm" />
            </div>
          )}
        </div>
      );
    }

    /** 9) PartyImages */
    function PartyImages({ characters }) {
      return (
        <div className="bg-gray-100 p-4 rounded-lg mb-4">
          <h2 className="text-xl font-bold mb-2">Party Member Images</h2>
          <div className="grid grid-cols-3 md:grid-cols-6 gap-2 max-h-48 overflow-y-auto">
            {characters.map((char) => (
              <div key={char.id} className="text-center">
                {char.image ? (
                  <img src={char.image} alt={char.name} className="w-10 h-10 object-cover rounded-full mx-auto" />
                ) : (
                  <div className="w-10 h-10 bg-gray-300 rounded-full mx-auto flex items-center justify-center">
                    <span className="text-gray-500 text-xs">No Img</span>
                  </div>
                )}
                <p className="mt-1 text-xs truncate">{char.name}</p>
              </div>
            ))}
          </div>
        </div>
      );
    }

    /** 10) CopyButton */
    function CopyButton({ characters, enemies }) {
      function handleCopy() {
        const text = [
          "### Characters",
          ...characters.map((c) => {
            return (
              "Character: " + c.name +
              "\nClass: " + c.class +
              "\nLevel: " + (c.level || 1) +
              "\nXP: " + (c.xp || 0) +
              "\nInitiative: " + (c.initiative || 0) +
              "\nHealth: " + c.health + "/" + c.maxHealth +
              "\nStatus: " + (c.status.length ? c.status.join(", ") : "None") +
              "\nEffects: " + (c.effects.length ? c.effects.join(", ") : "None") +
              "\nInventory: " + (c.inventory.length ? c.inventory.join(", ") : "None") +
              "\nAbilities: " + (c.specialAbilities.length ? c.specialAbilities.join(", ") : "None") +
              "\nSpells: " + (c.spellsMagic.length ? c.spellsMagic.join(", ") : "None") +
              "\nNotes: " + (c.notes || "None") +
              "\nImage: " + (c.image ? "Yes" : "No")
            );
          }),
          "",
          "### Enemies",
          ...enemies.map((e) => "Enemy: " + e.name + "\nHealth: " + e.health + "/" + e.maxHealth),
        ].join("\n\n");

        navigator.clipboard.writeText(text).then(() => alert("Data copied to clipboard!")).catch((err) => {
          console.error("Failed to copy: ", err);
          alert("Failed to copy data.");
        });
      }

      return (
        <button className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 mb-2 text-sm" onClick={handleCopy}>
          Copy for Prompt
        </button>
      );
    }

    /** 11) ClassesSection */
    function ClassesSection() {
      const classes = [
        { name: "Barbarian", desc: "Rage-fueled warriors with high strength and resilience." },
        { name: "Bard", desc: "Charismatic performers using magic and inspiration." },
        { name: "Cleric", desc: "Divine healers and warriors channeling godly power." },
        { name: "Druid", desc: "Nature’s guardians with shapeshifting and elemental magic." },
        { name: "Fighter", desc: "Versatile combatants excelling in martial prowess." },
        { name: "Monk", desc: "Agile martial artists using ki for supernatural feats." },
        { name: "Paladin", desc: "Holy knights blending combat and divine magic." },
        { name: "Ranger", desc: "Skilled trackers with nature magic and ranged combat." },
        { name: "Rogue", desc: "Stealthy tricksters specializing in sneak attacks." },
        { name: "Sorcerer", desc: "Innate spellcasters with raw magical power." },
        { name: "Warlock", desc: "Pact-bound casters wielding eldritch magic." },
        { name: "Wizard", desc: "Scholars mastering arcane spells through study." },
      ];

      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">D&D Classes</h2>
          <ul className="list-disc list-inside space-y-2">
            {classes.map((cls) => (
              <li key={cls.name}><span className="font-semibold">{cls.name}</span>: {cls.desc}</li>
            ))}
          </ul>
        </div>
      );
    }

    /** 12) RacesSection */
    function RacesSection() {
      const races = [
        { name: "Dwarf", desc: "Stout and resilient with a knack for crafting." },
        { name: "Elf", desc: "Graceful and long-lived with keen senses." },
        { name: "Halfling", desc: "Small and lucky with nimble movements." },
        { name: "Human", desc: "Versatile and adaptable to any role." },
        { name: "Dragonborn", desc: "Draconic humanoids with breath weapons." },
        { name: "Gnome", desc: "Clever inventors with magical resistance." },
        { name: "Half-Elf", desc: "Blend of human and elven traits." },
        { name: "Half-Orc", desc: "Strong and enduring warriors." },
        { name: "Tiefling", desc: "Fiendish humanoids with infernal magic." },
      ];

      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">D&D Races</h2>
          <ul className="list-disc list-inside space-y-1">
            {races.map((race) => (
              <li key={race.name}><span className="font-semibold">{race.name}</span>: {race.desc}</li>
            ))}
          </ul>
        </div>
      );
    }

    /** 13) MonsterCreatureList */
    function MonsterCreatureList() {
      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">Monster/Creature List</h2>
          <p className="mb-2">Access monster stats at: <a href="https://www.aidedd.org/dnd-filters/monsters.php" target="_blank" rel="noreferrer" className="text-blue-500 hover:underline">AIDEDD Monster Database</a></p>
        </div>
      );
    }

    /** 14) BulkActions */
    function BulkActions({ onBulkHeal, onBulkDamage }) {
      const [amount, setAmount] = React.useState("0");
      const [targetType, setTargetType] = React.useState("characters");

      function handleHeal() {
        const amt = parseInt(amount, 10) || 0;
        if (amt > 0) onBulkHeal(targetType, amt);
      }

      function handleDamage() {
        const amt = parseInt(amount, 10) || 0;
        if (amt > 0) onBulkDamage(targetType, amt);
      }

      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">Bulk Heal/Damage</h2>
          <div className="flex flex-wrap items-end gap-2">
            <div>
              <label className="block text-sm font-medium mb-1">Amount</label>
              <input type="number" className="border rounded p-1 text-sm w-20" value={amount} onChange={(e) => setAmount(e.target.value)} />
            </div>
            <div>
              <label className="block text-sm font-medium mb-1">Target</label>
              <select className="border rounded p-1 text-sm" value={targetType} onChange={(e) => setTargetType(e.target.value)}>
                <option value="characters">All Characters</option>
                <option value="enemies">All Enemies</option>
              </select>
            </div>
            <div className="flex gap-2">
              <button className="px-2 py-1 bg-green-500 text-white rounded hover:bg-green-600 text-sm" onClick={handleHeal}>Bulk Heal</button>
              <button className="px-2 py-1 bg-red-500 text-white rounded hover:bg-red-600 text-sm" onClick={handleDamage}>Bulk Damage</button>
            </div>
          </div>
        </div>
      );
    }

    /** 15) Main DnDTracker */
    function DnDTracker() {
      const [collapsedCharacters, toggleCharacterCollapse] = useCollapseState("collapsedCharacters");
      const [collapsedEnemies, toggleEnemyCollapse] = useCollapseState("collapsedEnemies");

      const [characters, setCharacters] = React.useState(() => {
        const saved = localStorage.getItem("characters");
        let loaded = saved ? JSON.parse(saved) : [{
          id: 1,
          name: "Jory",
          class: "Cleric",
          health: 100,
          maxHealth: 100,
          status: [],
          effects: [],
          inventory: ["Mace", "Shield"],
          specialAbilities: ["Turn Undead"],
          spellsMagic: ["Cure Wounds"],
          image: null,
          level: 1,
          xp: 0,
          initiative: 0,
          notes: "",
          deathSaves: { success: 0, fail: 0 },
        }];
        return loaded.map((c) => ({
          ...c,
          level: c.level || 1,
          xp: c.xp || 0,
          initiative: c.initiative || 0,
          notes: c.notes || "",
          deathSaves: c.deathSaves || { success: 0, fail: 0 },
        }));
      });

      const [enemies, setEnemies] = React.useState(() => {
        const saved = localStorage.getItem("enemies");
        return saved ? JSON.parse(saved) : [];
      });

      const [statRows, setStatRows] = React.useState(() => {
        const saved = localStorage.getItem("statRows");
        return saved ? JSON.parse(saved) : [{ id: 1, label: "Jory", str: 10, dex: 10, con: 10, int: 10, wis: 10, cha: 10 }];
      });

      const [mapImage, setMapImage] = React.useState(() => localStorage.getItem("mapImage") || null);
      const [dotPositions, setDotPositions] = React.useState(() => {
        const saved = localStorage.getItem("dotPositions");
        return saved ? JSON.parse(saved) : [];
      });

      React.useEffect(() => {
        localStorage.setItem("characters", JSON.stringify(characters));
      }, [characters]);
      React.useEffect(() => {
        localStorage.setItem("enemies", JSON.stringify(enemies));
      }, [enemies]);
      React.useEffect(() => {
        localStorage.setItem("statRows", JSON.stringify(statRows));
      }, [statRows]);
      React.useEffect(() => {
        localStorage.setItem("mapImage", mapImage);
        localStorage.setItem("dotPositions", JSON.stringify(dotPositions));
      }, [mapImage, dotPositions]);

      function addCharacter() {
        const newId = Date.now();
        setCharacters((prev) => [
          ...prev,
          {
            id: newId,
            name: "New Character",
            class: "Unassigned",
            health: 50,
            maxHealth: 50,
            status: [],
            effects: [],
            inventory: [],
            specialAbilities: [],
            spellsMagic: [],
            image: null,
            level: 1,
            xp: 0,
            initiative: 0,
            notes: "",
            deathSaves: { success: 0, fail: 0 },
          },
        ]);
      }

      function removeCharacter(charId) {
        setCharacters((prev) => prev.filter((c) => c.id !== charId));
      }

      function updateCharacter(updated) {
        setCharacters((prev) => prev.map((c) => (c.id === updated.id ? updated : c)));
      }

      function healCharacter(charId, amt) {
        setCharacters((prev) => prev.map((c) => (c.id === charId ? { ...c, health: Math.min(c.maxHealth, c.health + amt) } : c)));
      }

      function damageCharacter(charId, amt) {
        setCharacters((prev) => prev.map((c) => (c.id === charId ? { ...c, health: Math.max(0, c.health - amt) } : c)));
      }

      function removeStatus(charId, idx) {
        setCharacters((prev) => prev.map((c) => {
          if (c.id === charId) {
            const updated = [...c.status];
            updated.splice(idx, 1);
            return { ...c, status: updated };
          }
          return c;
        }));
      }

      function removeEffect(charId, idx) {
        setCharacters((prev) => prev.map((c) => {
          if (c.id === charId) {
            const updated = [...c.effects];
            updated.splice(idx, 1);
            return { ...c, effects: updated };
          }
          return c;
        }));
      }

      function removeItem(charId, idx) {
        setCharacters((prev) => prev.map((c) => {
          if (c.id === charId) {
            const updated = [...c.inventory];
            updated.splice(idx, 1);
            return { ...c, inventory: updated };
          }
          return c;
        }));
      }

      function removeAbility(charId, idx) {
        setCharacters((prev) => prev.map((c) => {
          if (c.id === charId) {
            const updated = [...c.specialAbilities];
            updated.splice(idx, 1);
            return { ...c, specialAbilities: updated };
          }
          return c;
        }));
      }

      function removeSpell(charId, idx) {
        setCharacters((prev) => prev.map((c) => {
          if (c.id === charId) {
            const updated = [...c.spellsMagic];
            updated.splice(idx, 1);
            return { ...c, spellsMagic: updated };
          }
          return c;
        }));
      }

      function addEnemy() {
        setEnemies((prev) => [
          ...prev,
          { id: Date.now(), name: "Enemy " + (prev.length + 1), health: 50, maxHealth: 50 },
        ]);
      }

      function removeEnemy(enemyId) {
        setEnemies((prev) => prev.filter((e) => e.id !== enemyId));
      }

      function healEnemy(enemyId, amt) {
        setEnemies((prev) => prev.map((e) => (e.id === enemyId ? { ...e, health: Math.min(e.maxHealth, e.health + amt) } : e)));
      }

      function damageEnemy(enemyId, amt) {
        setEnemies((prev) => prev.map((e) => (e.id === enemyId ? { ...e, health: Math.max(0, e.health - amt) } : e)));
      }

      function updateEnemy(updated) {
        setEnemies((prev) => prev.map((e) => (e.id === updated.id ? updated : e)));
      }

      function handleBulkHeal(target, amt) {
        if (target === "characters") {
          setCharacters((prev) => prev.map((c) => ({ ...c, health: Math.min(c.maxHealth, c.health + amt) })));
        } else {
          setEnemies((prev) => prev.map((e) => ({ ...e, health: Math.min(e.maxHealth, e.health + amt) })));
        }
      }

      function handleBulkDamage(target, amt) {
        if (target === "characters") {
          setCharacters((prev) => prev.map((c) => ({ ...c, health: Math.max(0, c.health - amt) })));
        } else {
          setEnemies((prev) => prev.map((e) => ({ ...e, health: Math.max(0, e.health - amt) })));
        }
      }

      return (
        <div className="container mx-auto p-4 space-y-4">
          <div className="flex justify-between items-center mb-4">
            <DarkModeToggle />
            <div className="flex gap-2">
              <button className="px-3 py-1 bg-amber-700 text-white rounded hover:bg-amber-800 text-sm" onClick={backupLocalStorage}>Backup</button>
              <input type="file" accept=".json" onChange={(e) => restoreLocalStorage(e.target.files)} className="border p-1 rounded text-sm" />
            </div>
          </div>

          <CopyButton characters={characters} enemies={enemies} />

          <div className="grid gap-4">
            {/* Party Status */}
            <div className="bg-gray-100 p-4 rounded-lg">
              <div className="flex justify-between items-center mb-4">
                <h2 className="text-xl font-bold">Party Status</h2>
                <button className="px-3 py-1 bg-green-500 text-white rounded hover:bg-green-600" onClick={addCharacter}>Add Character</button>
              </div>
              <div className="grid gap-4">
                {characters.map((char) => (
                  <CharacterCard
                    key={char.id}
                    char={char}
                    collapsed={collapsedCharacters[char.id]}
                    onToggleCollapse={toggleCharacterCollapse}
                    onUpdateChar={updateCharacter}
                    onHeal={healCharacter}
                    onDamage={damageCharacter}
                    onRemoveStatus={removeStatus}
                    onRemoveEffect={removeEffect}
                    onRemoveItem={removeItem}
                    onRemoveAbility={removeAbility}
                    onRemoveSpell={removeSpell}
                    onRemoveChar={removeCharacter}
                  />
                ))}
              </div>
            </div>

            <PartyImages characters={characters} />
            <StatsSection statRows={statRows} setStatRows={setStatRows} />

            {/* Enemy Section */}
            <div className="bg-gray-100 p-4 rounded-lg">
              <div className="flex justify-between items-center mb-4">
                <h2 className="text-xl font-bold">Enemies</h2>
                <button className="px-3 py-1 bg-purple-500 text-white rounded hover:bg-purple-600" onClick={addEnemy}>Add Enemy</button>
              </div>
              <div className="grid gap-4">
                {enemies.map((enemy) => (
                  <EnemyCard
                    key={enemy.id}
                    enemy={enemy}
                    collapsed={collapsedEnemies[enemy.id]}
                    onToggleCollapse={toggleEnemyCollapse}
                    onHealEnemy={healEnemy}
                    onDamageEnemy={damageEnemy}
                    onRemoveEnemy={removeEnemy}
                    onUpdateEnemy={updateEnemy}
                  />
                ))}
              </div>
            </div>

            <BulkActions onBulkHeal={handleBulkHeal} onBulkDamage={handleBulkDamage} />
            <MapSection mapImage={mapImage} setMapImage={setMapImage} dotPositions={dotPositions} setDotPositions={setDotPositions} />
            <DiceRoller />
            <ClassesSection />
            <RacesSection />
            <MonsterCreatureList />
          </div>
        </div>
      );
    }

    ReactDOM.render(<DnDTracker />, document.getElementById("root"));
  </script>
</body>
</html>
