<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>D&D Player Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="mobile-web-app-capable" content="yes" />

  <!-- Tailwind CSS from unpkg -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/tailwindcss@3.3.2/dist/tailwind.min.css"
  />

  <!-- React + ReactDOM 17 from unpkg -->
  <script
    src="https://unpkg.com/react@17/umd/react.development.js"
    type="text/javascript"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"
    type="text/javascript"
    crossorigin="anonymous"
  ></script>

  <!-- Babel for inline JSX (development usage) -->
  <script
    src="https://unpkg.com/babel-standalone@6/babel.min.js"
    type="text/javascript"
  ></script>

  <!-- Google font (optional for a D&D vibe) -->
  <link
    href="https://fonts.googleapis.com/css2?family=Cinzel&display=swap"
    rel="stylesheet"
  />

  <style>
    /* Example D&D-ish font and some transitions */
    body {
      font-family: "Cinzel", serif;
      transition: background-color 0.3s, color 0.3s;
    }
    .dark {
      background-color: #1a1a1a;
      color: #fafafa;
    }
    /* Simple parchment-like background if desired */
    .parchment-bg {
      background: url("https://www.transparenttextures.com/patterns/aged-paper.png");
    }
    /* Expand/collapse icons */
    .collapse-button::after {
      content: "▼";
      display: inline-block;
      margin-left: 0.25rem;
    }
    .collapsed .collapse-button::after {
      content: "▶";
    }
    .collapsible-content {
      transition: max-height 0.3s ease;
      overflow: hidden;
    }
  </style>
</head>

<body class="bg-gray-50 text-gray-800">
  <div id="root" class="p-4"></div>

  <!-- Main Script with type="text/babel" so Babel will transform JSX in-browser -->
  <script type="text/babel">
    /**************************************************
     * Single-File D&D Tracker (React + Tailwind + Babel)
     * Make sure to serve over HTTP (not file://).
     **************************************************/

    /********************************************
     * 1) UTILS: LocalStorage Backup/Restore
     ********************************************/
    function backupLocalStorage() {
      const data = {
        characters: localStorage.getItem("characters"),
        enemies: localStorage.getItem("enemies"),
        statRows: localStorage.getItem("statRows"),
        mapImage: localStorage.getItem("mapImage"),
        dotPositions: localStorage.getItem("dotPositions"),
        collapsedCharacters: localStorage.getItem("collapsedCharacters"),
        collapsedEnemies: localStorage.getItem("collapsedEnemies"),
        darkMode: localStorage.getItem("darkMode"),
        sessionNotes: localStorage.getItem("sessionNotes"),
      };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "dnd_tracker_backup.json";
      a.click();
      URL.revokeObjectURL(url);
    }

    function restoreLocalStorage(files) {
      if (!files || !files.length) return;
      const file = files[0];
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          for (const key in data) {
            if (data[key] !== null && data[key] !== undefined) {
              localStorage.setItem(key, data[key]);
            }
          }
          alert("LocalStorage restored. Please refresh the page.");
        } catch (err) {
          console.error(err);
          alert("Failed to restore. Invalid JSON?");
        }
      };
      reader.readAsText(file);
    }

    /********************************************
     * 2) DarkModeToggle
     ********************************************/
    function DarkModeToggle() {
      const [darkMode, setDarkMode] = React.useState(() => {
        return localStorage.getItem("darkMode") === "true";
      });

      React.useEffect(() => {
        if (darkMode) {
          document.body.classList.add("dark");
        } else {
          document.body.classList.remove("dark");
        }
        localStorage.setItem("darkMode", darkMode);
      }, [darkMode]);

      return (
        <button
          className="px-3 py-1 bg-yellow-600 text-white rounded hover:bg-yellow-700"
          onClick={() => setDarkMode(!darkMode)}
        >
          {darkMode ? "Light Mode" : "Dark Mode"}
        </button>
      );
    }

    /********************************************
     * 3) Collapse Logic Hook
     ********************************************/
    // A hook that returns [collapseState, toggleFunc].
    // collapseState is an object keyed by ID with boolean values.
    function useCollapseState(storageKey) {
      const [collapseState, setCollapseState] = React.useState(() => {
        const saved = localStorage.getItem(storageKey);
        return saved ? JSON.parse(saved) : {};
      });

      function toggleCollapse(id) {
        setCollapseState((prev) => {
          const newVal = { ...prev, [id]: !prev[id] };
          localStorage.setItem(storageKey, JSON.stringify(newVal));
          return newVal;
        });
      }

      return [collapseState, toggleCollapse];
    }

    /********************************************
     * 4) CharacterCard
     ********************************************/
    function CharacterCard(props) {
      const {
        char,
        collapsed,
        onToggleCollapse,
        onUpdateChar,
        onHeal,
        onDamage,
        onRemoveStatus,
        onRemoveEffect,
        onRemoveItem,
        onRemoveAbility,
        onRemoveSpell,
        onRemoveChar,
      } = props;

      const [isEditing, setIsEditing] = React.useState(false);

      // Extended fields
      const [editName, setEditName] = React.useState(char.name);
      const [editClass, setEditClass] = React.useState(char.class);
      const [editMaxHealth, setEditMaxHealth] = React.useState(String(char.maxHealth));
      const [editLevel, setEditLevel] = React.useState(String(char.level || 1));
      const [editXP, setEditXP] = React.useState(String(char.xp || 0));
      const [editInitiative, setEditInitiative] = React.useState(String(char.initiative || 0));
      const [editNotes, setEditNotes] = React.useState(char.notes || "");

      const [newStatus, setNewStatus] = React.useState("");
      const [newEffect, setNewEffect] = React.useState("");
      const [newItem, setNewItem] = React.useState("");
      const [newAbility, setNewAbility] = React.useState("");
      const [newSpell, setNewSpell] = React.useState("");

      const [healInput, setHealInput] = React.useState("0");
      const [dmgInput, setDmgInput] = React.useState("0");

      React.useEffect(() => {
        setEditName(char.name);
        setEditClass(char.class);
        setEditMaxHealth(String(char.maxHealth));
        setEditLevel(String(char.level || 1));
        setEditXP(String(char.xp || 0));
        setEditInitiative(String(char.initiative || 0));
        setEditNotes(char.notes || "");
      }, [char]);

      function handleImageUpload(e) {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (evt) => {
            onUpdateChar({ ...char, image: evt.target.result });
          };
          reader.readAsDataURL(file);
        }
      }

      function handleSave() {
        const parsedMax = parseInt(editMaxHealth, 10) || 0;
        const clippedHealth = Math.min(char.health, parsedMax);

        onUpdateChar({
          ...char,
          name: editName,
          class: editClass,
          maxHealth: parsedMax,
          health: clippedHealth,
          level: parseInt(editLevel, 10) || 1,
          xp: parseInt(editXP, 10) || 0,
          initiative: parseInt(editInitiative, 10) || 0,
          notes: editNotes,
        });
        setIsEditing(false);
      }

      function handleAddStatus() {
        if (!newStatus.trim()) return;
        const updated = [...char.status, newStatus.trim()];
        onUpdateChar({ ...char, status: updated });
        setNewStatus("");
      }
      function handleAddEffect() {
        if (!newEffect.trim()) return;
        const updated = [...char.effects, newEffect.trim()];
        onUpdateChar({ ...char, effects: updated });
        setNewEffect("");
      }
      function handleAddItem() {
        if (!newItem.trim()) return;
        const updated = [...char.inventory, newItem.trim()];
        onUpdateChar({ ...char, inventory: updated });
        setNewItem("");
      }
      function handleAddAbility() {
        if (!newAbility.trim()) return;
        const updated = [...char.specialAbilities, newAbility.trim()];
        onUpdateChar({ ...char, specialAbilities: updated });
        setNewAbility("");
      }
      function handleAddSpell() {
        if (!newSpell.trim()) return;
        const updated = [...char.spellsMagic, newSpell.trim()];
        onUpdateChar({ ...char, spellsMagic: updated });
        setNewSpell("");
      }

      function applyHeal() {
        const amt = parseInt(healInput, 10) || 0;
        onHeal(char.id, amt);
      }
      function applyDamage() {
        const amt = parseInt(dmgInput, 10) || 0;
        onDamage(char.id, amt);
      }

      // Death Saves
      function toggleDeathSaveSuccess() {
        const successCount = char.deathSaves.success;
        if (successCount < 3) {
          onUpdateChar({
            ...char,
            deathSaves: {
              ...char.deathSaves,
              success: successCount + 1,
            },
          });
        }
      }
      function toggleDeathSaveFail() {
        const failCount = char.deathSaves.fail;
        if (failCount < 3) {
          onUpdateChar({
            ...char,
            deathSaves: {
              ...char.deathSaves,
              fail: failCount + 1,
            },
          });
        }
      }
      function resetDeathSaves() {
        onUpdateChar({
          ...char,
          deathSaves: { success: 0, fail: 0 },
        });
      }

      // Collapsible content
      const mainContentStyle = collapsed
        ? { maxHeight: 0, padding: 0 }
        : { maxHeight: "9999px" };

      if (isEditing) {
        return (
          <div className="bg-white p-4 rounded-lg shadow space-y-2 mb-4">
            <div className="flex justify-between items-center">
              <h3 className="font-bold">Editing {char.name}</h3>
              <button
                className="px-2 py-1 bg-red-500 text-white rounded"
                onClick={() => onRemoveChar(char.id)}
              >
                Remove
              </button>
            </div>
            <div className="grid md:grid-cols-2 gap-2">
              <input
                className="border p-1 rounded"
                placeholder="Name"
                value={editName}
                onChange={(e) => setEditName(e.target.value)}
              />
              <input
                className="border p-1 rounded"
                placeholder="Class"
                value={editClass}
                onChange={(e) => setEditClass(e.target.value)}
              />
              <input
                className="border p-1 rounded"
                placeholder="Max Health"
                type="number"
                value={editMaxHealth}
                onChange={(e) => setEditMaxHealth(e.target.value)}
              />
              <input
                className="border p-1 rounded"
                placeholder="Level"
                type="number"
                value={editLevel}
                onChange={(e) => setEditLevel(e.target.value)}
              />
              <input
                className="border p-1 rounded"
                placeholder="XP"
                type="number"
                value={editXP}
                onChange={(e) => setEditXP(e.target.value)}
              />
              <input
                className="border p-1 rounded"
                placeholder="Initiative"
                type="number"
                value={editInitiative}
                onChange={(e) => setEditInitiative(e.target.value)}
              />
            </div>
            <textarea
              className="border p-1 rounded w-full"
              rows={3}
              placeholder="Notes / Bio / Extra Info"
              value={editNotes}
              onChange={(e) => setEditNotes(e.target.value)}
            />
            <div className="flex gap-2">
              <button
                className="px-3 py-1 bg-green-500 text-white rounded"
                onClick={handleSave}
              >
                Save
              </button>
              <button
                className="px-2 py-1 bg-gray-400 text-white rounded"
                onClick={() => setIsEditing(false)}
              >
                Cancel
              </button>
            </div>
          </div>
        );
      }

      return (
        <div
          className={`bg-white p-4 rounded-lg shadow mb-4 ${
            collapsed ? "collapsed" : ""
          }`}
        >
          <div className="flex justify-between items-center">
            <div className="flex items-center gap-2">
              <button
                onClick={() => onToggleCollapse(char.id)}
                className="collapse-button text-sm font-bold"
              >
                {char.name}
              </button>
              <span className="text-sm text-gray-600">({char.class})</span>
            </div>
            <div className="flex items-center gap-2">
              <span className="text-sm">
                Init: {(char.initiative || 0)} | Lvl: {(char.level || 1)}
              </span>
              <button
                className="p-1 text-gray-500 hover:text-gray-700"
                onClick={() => setIsEditing(true)}
              >
                [EDIT]
              </button>
              <button
                className="px-2 py-1 bg-red-500 text-white rounded"
                onClick={() => onRemoveChar(char.id)}
              >
                Remove
              </button>
            </div>
          </div>

          <div
            className="collapsible-content transition-all duration-300 ease-in-out"
            style={mainContentStyle}
          >
            <div className={collapsed ? "hidden" : "block"}>
              {/* XP */}
              <div className="text-sm mb-1 mt-2">XP: {(char.xp || 0)}</div>
              {/* Image */}
              <label className="block text-sm font-medium text-gray-700">
                Character Image
              </label>
              {char.image ? (
                <div className="flex items-center gap-2 mt-1">
                  <img
                    src={char.image}
                    alt={char.name}
                    className="w-16 h-16 object-cover rounded-full"
                  />
                  <button
                    className="px-2 py-1 bg-red-500 text-white rounded text-sm"
                    onClick={() => onUpdateChar({ ...char, image: null })}
                  >
                    Remove Image
                  </button>
                </div>
              ) : (
                <input
                  type="file"
                  accept="image/*"
                  onChange={handleImageUpload}
                  className="mt-1 text-sm"
                />
              )}
              {/* Health Bar */}
              <div className="mt-2">
                <div className="flex items-center gap-2">
                  <span className="text-red-500">❤️</span>
                  <div className="w-full bg-gray-200 rounded-full h-4">
                    <div
                      className="bg-red-500 rounded-full h-4"
                      style={{
                        width: `${(char.health / char.maxHealth) * 100}%`,
                      }}
                    ></div>
                  </div>
                  <span className="text-sm">
                    {char.health}/{char.maxHealth}
                  </span>
                </div>
              </div>
              {/* Status */}
              <div className="mt-2">
                <h4 className="font-semibold text-sm">Status Conditions:</h4>
                <div className="flex flex-wrap gap-1 mt-1">
                  {char.status.map((stat, idx) => (
                    <span
                      key={idx}
                      className="px-2 py-1 text-sm bg-red-100 text-red-800 rounded-full flex items-center gap-1"
                    >
                      {stat}
                      <button
                        className="hover:text-red-500"
                        onClick={() => onRemoveStatus(char.id, idx)}
                      >
                        [X]
                      </button>
                    </span>
                  ))}
                </div>
                <div className="flex gap-2 mt-1">
                  <input
                    className="border p-1 rounded text-sm"
                    value={newStatus}
                    onChange={(e) => setNewStatus(e.target.value)}
                    placeholder="Add status"
                  />
                  <button
                    className="px-2 py-1 bg-red-500 text-white rounded text-sm"
                    onClick={handleAddStatus}
                  >
                    Add
                  </button>
                </div>
              </div>
              {/* Effects */}
              <div className="mt-2">
                <h4 className="font-semibold text-sm">Effects:</h4>
                <div className="flex flex-wrap gap-1 mt-1">
                  {char.effects.map((eff, idx) => (
                    <span
                      key={idx}
                      className="px-2 py-1 text-sm bg-blue-100 text-blue-800 rounded-full flex items-center gap-1"
                    >
                      {eff}
                      <button
                        className="hover:text-red-500"
                        onClick={() => onRemoveEffect(char.id, idx)}
                      >
                        [X]
                      </button>
                    </span>
                  ))}
                </div>
                <div className="flex gap-2 mt-1">
                  <input
                    className="border p-1 rounded text-sm"
                    value={newEffect}
                    onChange={(e) => setNewEffect(e.target.value)}
                    placeholder="Add effect"
                  />
                  <button
                    className="px-2 py-1 bg-blue-500 text-white rounded text-sm"
                    onClick={handleAddEffect}
                  >
                    Add
                  </button>
                </div>
              </div>
              {/* Inventory */}
              <div className="mt-2">
                <h4 className="font-semibold text-sm">Inventory:</h4>
                <div className="flex flex-wrap gap-1 mt-1">
                  {char.inventory.map((item, idx) => (
                    <span
                      key={idx}
                      className="px-2 py-1 text-sm bg-gray-100 rounded-full flex items-center gap-1"
                    >
                      {item}
                      <button
                        className="hover:text-red-500"
                        onClick={() => onRemoveItem(char.id, idx)}
                      >
                        [X]
                      </button>
                    </span>
                  ))}
                </div>
                <div className="flex gap-2 mt-1">
                  <input
                    className="border p-1 rounded text-sm"
                    value={newItem}
                    onChange={(e) => setNewItem(e.target.value)}
                    placeholder="New item"
                  />
                  <button
                    className="px-2 py-1 bg-gray-500 text-white rounded text-sm"
                    onClick={handleAddItem}
                  >
                    Add
                  </button>
                </div>
              </div>
              {/* Special Abilities */}
              <div className="mt-2">
                <h4 className="font-semibold text-sm">Special Abilities:</h4>
                <div className="flex flex-wrap gap-1 mt-1">
                  {char.specialAbilities.map((ability, idx) => (
                    <span
                      key={idx}
                      className="px-2 py-1 text-sm bg-green-100 text-green-800 rounded-full flex items-center gap-1"
                    >
                      {ability}
                      <button
                        className="hover:text-red-500"
                        onClick={() => onRemoveAbility(char.id, idx)}
                      >
                        [X]
                      </button>
                    </span>
                  ))}
                </div>
                <div className="flex gap-2 mt-1">
                  <input
                    className="border p-1 rounded text-sm"
                    value={newAbility}
                    onChange={(e) => setNewAbility(e.target.value)}
                    placeholder="Add ability/move"
                  />
                  <button
                    className="px-2 py-1 bg-green-600 text-white rounded text-sm"
                    onClick={handleAddAbility}
                  >
                    Add
                  </button>
                </div>
              </div>
              {/* Spells */}
              <div className="mt-2">
                <h4 className="font-semibold text-sm">Spells/Magic:</h4>
                <div className="flex flex-wrap gap-1 mt-1">
                  {char.spellsMagic.map((spell, idx) => (
                    <span
                      key={idx}
                      className="px-2 py-1 text-sm bg-purple-100 text-purple-800 rounded-full flex items-center gap-1"
                    >
                      {spell}
                      <button
                        className="hover:text-purple-500"
                        onClick={() => onRemoveSpell(char.id, idx)}
                      >
                        [X]
                      </button>
                    </span>
                  ))}
                </div>
                <div className="flex gap-2 mt-1">
                  <input
                    className="border p-1 rounded text-sm"
                    value={newSpell}
                    onChange={(e) => setNewSpell(e.target.value)}
                    placeholder="Add spell"
                  />
                  <button
                    className="px-2 py-1 bg-purple-600 text-white rounded text-sm"
                    onClick={handleAddSpell}
                  >
                    Add
                  </button>
                </div>
              </div>
              {/* Heal / Damage */}
              <div className="mt-4 flex gap-4 flex-wrap">
                <div>
                  <label className="text-sm block">Heal #</label>
                  <div className="flex items-center gap-2">
                    <input
                      type="number"
                      className="w-16 border rounded p-1 text-sm"
                      value={healInput}
                      onChange={(e) => setHealInput(e.target.value)}
                    />
                    <button
                      className="px-3 py-1 bg-green-500 text-white rounded text-sm"
                      onClick={applyHeal}
                    >
                      Heal
                    </button>
                  </div>
                </div>
                <div>
                  <label className="text-sm block">Damage #</label>
                  <div className="flex items-center gap-2">
                    <input
                      type="number"
                      className="w-16 border rounded p-1 text-sm"
                      value={dmgInput}
                      onChange={(e) => setDmgInput(e.target.value)}
                    />
                    <button
                      className="px-3 py-1 bg-red-500 text-white rounded text-sm"
                      onClick={applyDamage}
                    >
                      Damage
                    </button>
                  </div>
                </div>
              </div>
              {/* Death Saves (if HP <= 0) */}
              {char.health <= 0 && (
                <div className="mt-4">
                  <h4 className="font-semibold text-sm">Death Saves</h4>
                  <p className="text-xs text-gray-600">
                    Successes: {char.deathSaves.success} / Failures: {char.deathSaves.fail}
                  </p>
                  <div className="flex gap-2 mt-1">
                    <button
                      className="px-2 py-1 bg-green-400 text-white rounded text-sm"
                      onClick={toggleDeathSaveSuccess}
                      disabled={char.deathSaves.success >= 3}
                    >
                      + Success
                    </button>
                    <button
                      className="px-2 py-1 bg-red-400 text-white rounded text-sm"
                      onClick={toggleDeathSaveFail}
                      disabled={char.deathSaves.fail >= 3}
                    >
                      + Fail
                    </button>
                    <button
                      className="px-2 py-1 bg-gray-400 text-white rounded text-sm"
                      onClick={resetDeathSaves}
                    >
                      Reset
                    </button>
                  </div>
                </div>
              )}
              {/* Notes */}
              {char.notes && (
                <div className="mt-4">
                  <h4 className="font-semibold text-sm">Notes/Bio:</h4>
                  <p className="text-sm whitespace-pre-line">{char.notes}</p>
                </div>
              )}
            </div>
          </div>
        </div>
      );
    }

    /********************************************
     * 5) EnemyCard
     ********************************************/
    function EnemyCard(props) {
      const {
        enemy,
        collapsed,
        onToggleCollapse,
        onHealEnemy,
        onDamageEnemy,
        onRemoveEnemy,
        onUpdateEnemy,
      } = props;

      const [isEditing, setIsEditing] = React.useState(false);
      const [editName, setEditName] = React.useState(enemy.name);
      const [editMaxHealth, setEditMaxHealth] = React.useState(String(enemy.maxHealth));
      const [editHealth, setEditHealth] = React.useState(String(enemy.health));
      const [healInput, setHealInput] = React.useState("0");
      const [dmgInput, setDmgInput] = React.useState("0");

      React.useEffect(() => {
        setEditName(enemy.name);
        setEditMaxHealth(String(enemy.maxHealth));
        setEditHealth(String(enemy.health));
      }, [enemy]);

      function handleSave() {
        const parsedMax = parseInt(editMaxHealth, 10) || 0;
        const parsedHealth = parseInt(editHealth, 10) || 0;
        const clippedHealth = Math.min(parsedHealth, parsedMax);
        onUpdateEnemy({
          ...enemy,
          name: editName,
          maxHealth: parsedMax,
          health: clippedHealth,
        });
        setIsEditing(false);
      }

      function applyHeal() {
        const amt = parseInt(healInput, 10) || 0;
        onHealEnemy(enemy.id, amt);
      }
      function applyDamage() {
        const amt = parseInt(dmgInput, 10) || 0;
        onDamageEnemy(enemy.id, amt);
      }

      const mainContentStyle = collapsed
        ? { maxHeight: 0, padding: 0 }
        : { maxHeight: "9999px" };

      if (isEditing) {
        return (
          <div className="bg-white p-4 rounded-lg shadow space-y-2 mb-4">
            <div className="flex justify-between items-center">
              <h3 className="font-bold">Editing Enemy</h3>
              <button
                className="px-2 py-1 bg-red-500 text-white rounded"
                onClick={() => onRemoveEnemy(enemy.id)}
              >
                Defeat
              </button>
            </div>
            <div className="flex flex-col gap-2">
              <input
                className="border p-1 rounded"
                placeholder="Name"
                value={editName}
                onChange={(e) => setEditName(e.target.value)}
              />
              <input
                type="number"
                className="border p-1 rounded"
                placeholder="Max Health"
                value={editMaxHealth}
                onChange={(e) => setEditMaxHealth(e.target.value)}
              />
              <input
                type="number"
                className="border p-1 rounded"
                placeholder="Current Health"
                value={editHealth}
                onChange={(e) => setEditHealth(e.target.value)}
              />
              <div className="flex gap-2">
                <button
                  className="px-3 py-1 bg-green-500 text-white rounded"
                  onClick={handleSave}
                >
                  Save
                </button>
                <button
                  className="px-2 py-1 bg-gray-400 text-white rounded"
                  onClick={() => setIsEditing(false)}
                >
                  Cancel
                </button>
              </div>
            </div>
          </div>
        );
      }

      return (
        <div
          className={`bg-white p-4 rounded-lg shadow mb-4 ${
            collapsed ? "collapsed" : ""
          }`}
        >
          <div className="flex justify-between items-center">
            <div className="flex items-center gap-2">
              <button
                onClick={() => onToggleCollapse(enemy.id)}
                className="collapse-button text-sm font-bold"
              >
                {enemy.name}
              </button>
            </div>
            <div className="flex gap-2 items-center">
              <button
                className="p-1 text-gray-500 hover:text-gray-700"
                onClick={() => setIsEditing(true)}
              >
                [EDIT]
              </button>
              <button
                className="px-2 py-1 bg-red-500 text-white rounded"
                onClick={() => onRemoveEnemy(enemy.id)}
              >
                Defeat
              </button>
            </div>
          </div>
          <div
            className="collapsible-content transition-all duration-300 ease-in-out"
            style={mainContentStyle}
          >
            <div className={collapsed ? "hidden" : "block"}>
              <div className="flex items-center gap-2 mt-2">
                <span className="text-red-500">❤️</span>
                <div className="w-full bg-gray-200 rounded-full h-4">
                  <div
                    className="bg-red-500 rounded-full h-4"
                    style={{
                      width: `${(enemy.health / enemy.maxHealth) * 100}%`,
                    }}
                  ></div>
                </div>
                <span className="text-sm">
                  {enemy.health}/{enemy.maxHealth}
                </span>
              </div>
              <div className="mt-4 flex gap-4 flex-wrap">
                <div>
                  <label className="text-sm block">Heal #</label>
                  <div className="flex items-center gap-2">
                    <input
                      type="number"
                      className="w-16 border rounded p-1 text-sm"
                      value={healInput}
                      onChange={(e) => setHealInput(e.target.value)}
                    />
                    <button
                      className="px-3 py-1 bg-green-500 text-white rounded text-sm"
                      onClick={applyHeal}
                    >
                      Heal
                    </button>
                  </div>
                </div>
                <div>
                  <label className="text-sm block">Damage #</label>
                  <div className="flex items-center gap-2">
                    <input
                      type="number"
                      className="w-16 border rounded p-1 text-sm"
                      value={dmgInput}
                      onChange={(e) => setDmgInput(e.target.value)}
                    />
                    <button
                      className="px-3 py-1 bg-red-500 text-white rounded text-sm"
                      onClick={applyDamage}
                    >
                      Damage
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    }

    /********************************************
     * 6) StatsSection
     ********************************************/
    function StatsSection({ statRows, setStatRows }) {
      const [nextId, setNextId] = React.useState(
        statRows.length ? Math.max(...statRows.map((r) => r.id)) + 1 : 2
      );

      function addStatRow() {
        setStatRows((prev) => [
          ...prev,
          {
            id: nextId,
            label: `Character #${nextId}`,
            str: 10,
            dex: 10,
            con: 10,
            int: 10,
            wis: 10,
            cha: 10,
          },
        ]);
        setNextId((n) => n + 1);
      }

      function removeStatRow(rowId) {
        setStatRows((prev) => prev.filter((row) => row.id !== rowId));
      }

      function updateStatRow(rowId, updated) {
        setStatRows((prev) =>
          prev.map((row) => (row.id === rowId ? updated : row))
        );
      }

      function clampScore(val) {
        if (val < 6) return 6;
        if (val > 30) return 30;
        return val;
      }

      function computeMod(score) {
        const mod = Math.floor((score - 10) / 2);
        return mod >= 0 ? "+" + mod : "" + mod;
      }

      function sortByAbility(ability) {
        setStatRows((prev) => {
          return [...prev].sort((a, b) => b[ability] - a[ability]);
        });
      }

      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <div className="flex justify-between items-center mb-2">
            <h2 className="text-xl font-bold">Stat Calculator</h2>
            <button
              className="px-2 py-1 bg-blue-500 text-white rounded"
              onClick={addStatRow}
            >
              Add Stat Row
            </button>
          </div>
          <p className="text-sm text-gray-700 mb-4">
            Enter scores (6–30) to see modifiers. Each row can represent a different character.
          </p>
          <div className="mb-2 flex gap-2">
            <button
              className="px-2 py-1 bg-blue-400 text-white rounded text-sm"
              onClick={() => sortByAbility("str")}
            >
              Sort by STR
            </button>
            <button
              className="px-2 py-1 bg-blue-400 text-white rounded text-sm"
              onClick={() => sortByAbility("dex")}
            >
              Sort by DEX
            </button>
            <button
              className="px-2 py-1 bg-blue-400 text-white rounded text-sm"
              onClick={() => sortByAbility("con")}
            >
              Sort by CON
            </button>
            <button
              className="px-2 py-1 bg-blue-400 text-white rounded text-sm"
              onClick={() => sortByAbility("int")}
            >
              Sort by INT
            </button>
            <button
              className="px-2 py-1 bg-blue-400 text-white rounded text-sm"
              onClick={() => sortByAbility("wis")}
            >
              Sort by WIS
            </button>
            <button
              className="px-2 py-1 bg-blue-400 text-white rounded text-sm"
              onClick={() => sortByAbility("cha")}
            >
              Sort by CHA
            </button>
          </div>

          {statRows.map((row) => {
            const modSTR = computeMod(row.str);
            const modDEX = computeMod(row.dex);
            const modCON = computeMod(row.con);
            const modINT = computeMod(row.int);
            const modWIS = computeMod(row.wis);
            const modCHA = computeMod(row.cha);

            return (
              <div key={row.id} className="bg-white p-4 rounded shadow mb-4 space-y-2">
                <div className="flex justify-between items-center">
                  <input
                    className="border rounded p-1 text-sm"
                    value={row.label}
                    onChange={(e) =>
                      updateStatRow(row.id, { ...row, label: e.target.value })
                    }
                  />
                  <button
                    className="px-2 py-1 bg-red-500 text-white rounded text-sm"
                    onClick={() => removeStatRow(row.id)}
                  >
                    Remove Row
                  </button>
                </div>
                <div className="grid grid-cols-3 md:grid-cols-6 gap-4 mt-2">
                  {/* STR */}
                  <div className="flex flex-col">
                    <label className="font-semibold">STR</label>
                    <input
                      type="number"
                      className="border p-1 rounded"
                      value={row.str}
                      onChange={(e) => {
                        const val = clampScore(parseInt(e.target.value) || 10);
                        updateStatRow(row.id, { ...row, str: val });
                      }}
                    />
                    <span className="text-center text-blue-600 mt-1">
                      {modSTR}
                    </span>
                  </div>
                  {/* DEX */}
                  <div className="flex flex-col">
                    <label className="font-semibold">DEX</label>
                    <input
                      type="number"
                      className="border p-1 rounded"
                      value={row.dex}
                      onChange={(e) => {
                        const val = clampScore(parseInt(e.target.value) || 10);
                        updateStatRow(row.id, { ...row, dex: val });
                      }}
                    />
                    <span className="text-center text-blue-600 mt-1">
                      {modDEX}
                    </span>
                  </div>
                  {/* CON */}
                  <div className="flex flex-col">
                    <label className="font-semibold">CON</label>
                    <input
                      type="number"
                      className="border p-1 rounded"
                      value={row.con}
                      onChange={(e) => {
                        const val = clampScore(parseInt(e.target.value) || 10);
                        updateStatRow(row.id, { ...row, con: val });
                      }}
                    />
                    <span className="text-center text-blue-600 mt-1">
                      {modCON}
                    </span>
                  </div>
                  {/* INT */}
                  <div className="flex flex-col">
                    <label className="font-semibold">INT</label>
                    <input
                      type="number"
                      className="border p-1 rounded"
                      value={row.int}
                      onChange={(e) => {
                        const val = clampScore(parseInt(e.target.value) || 10);
                        updateStatRow(row.id, { ...row, int: val });
                      }}
                    />
                    <span className="text-center text-blue-600 mt-1">
                      {modINT}
                    </span>
                  </div>
                  {/* WIS */}
                  <div className="flex flex-col">
                    <label className="font-semibold">WIS</label>
                    <input
                      type="number"
                      className="border p-1 rounded"
                      value={row.wis}
                      onChange={(e) => {
                        const val = clampScore(parseInt(e.target.value) || 10);
                        updateStatRow(row.id, { ...row, wis: val });
                      }}
                    />
                    <span className="text-center text-blue-600 mt-1">
                      {modWIS}
                    </span>
                  </div>
                  {/* CHA */}
                  <div className="flex flex-col">
                    <label className="font-semibold">CHA</label>
                    <input
                      type="number"
                      className="border p-1 rounded"
                      value={row.cha}
                      onChange={(e) => {
                        const val = clampScore(parseInt(e.target.value) || 10);
                        updateStatRow(row.id, { ...row, cha: val });
                      }}
                    />
                    <span className="text-center text-blue-600 mt-1">
                      {modCHA}
                    </span>
                  </div>
                </div>
              </div>
            );
          })}
        </div>
      );
    }

    /********************************************
     * 7) DiceRoller
     ********************************************/
    function DiceRoller() {
      const [rollHistory, setRollHistory] = React.useState([]);
      const audioRef = React.useRef(null);

      function rollD(sides) {
        if (audioRef.current) {
          audioRef.current.currentTime = 0;
          audioRef.current.play().catch(() => {});
        }
        const result = Math.floor(Math.random() * sides) + 1;
        const newEntry = "d" + sides + " → " + result;
        setRollHistory((prev) => [newEntry].concat(prev.slice(0, 9)));
      }

      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">Dice Roller</h2>
          <audio ref={audioRef} src="https://www.soundjay.com/misc/sounds/dice-1.mp3" />
          <div className="flex flex-wrap gap-2 mb-2">
            {[2, 4, 6, 8, 10, 12, 15, 20].map((sides) => (
              <button
                key={sides}
                onClick={() => rollD(sides)}
                className="px-3 py-1 bg-blue-500 text-white rounded"
              >
                d{sides}
              </button>
            ))}
          </div>
          <div>
            <h3 className="text-sm font-semibold mb-1">Recent Rolls:</h3>
            <ul className="list-disc list-inside text-sm">
              {rollHistory.length === 0 && <li>No rolls yet</li>}
              {rollHistory.map((entry, idx) => (
                <li key={idx}>{entry}</li>
              ))}
            </ul>
          </div>
        </div>
      );
    }

    /********************************************
     * 8) MapSection with Zoom + Pan + Markers
     ********************************************/
    function MapSection(props) {
      const { mapImage, setMapImage, dotPositions, setDotPositions } = props;
      const [isDragging, setIsDragging] = React.useState(null);
      const containerRef = React.useRef(null);

      const [scale, setScale] = React.useState(1);
      const [offset, setOffset] = React.useState({ x: 0, y: 0 });
      const [isPanning, setIsPanning] = React.useState(false);
      const [panStart, setPanStart] = React.useState({ x: 0, y: 0 });

      function handleImageUpload(e) {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (evt) => {
            setMapImage(evt.target.result);
            setDotPositions([]);
            setScale(1);
            setOffset({ x: 0, y: 0 });
          };
          reader.readAsDataURL(file);
        }
      }

      function handleDeleteImage() {
        setMapImage(null);
        setDotPositions([]);
      }

      function handleMouseDown(index) {
        return (e) => {
          e.stopPropagation(); // so we don't start panning
          setIsDragging(index);
          moveDot(index, e);
        };
      }

      function handleMouseMove(e) {
        if (isDragging !== null) {
          moveDot(isDragging, e);
        } else if (isPanning) {
          const dx = e.clientX - panStart.x;
          const dy = e.clientY - panStart.y;
          setPanStart({ x: e.clientX, y: e.clientY });
          setOffset((prev) => ({ x: prev.x + dx, y: prev.y + dy }));
        }
      }

      function handleMouseUp() {
        setIsDragging(null);
        setIsPanning(false);
      }

      function moveDot(index, e) {
        if (!containerRef.current || !mapImage) return;
        const rect = containerRef.current.getBoundingClientRect();
        const xPercent = ((e.clientX - rect.left - offset.x) / (rect.width * scale)) * 100;
        const yPercent = ((e.clientY - rect.top - offset.y) / (rect.height * scale)) * 100;

        setDotPositions((prev) =>
          prev.map((dot, i) =>
            i === index
              ? {
                  ...dot,
                  x: Math.max(0, Math.min(100, xPercent)),
                  y: Math.max(0, Math.min(100, yPercent)),
                }
              : dot
          )
        );
      }

      function handleWheel(e) {
        if (!mapImage) return;
        e.preventDefault();
        const delta = e.deltaY > 0 ? -0.1 : 0.1;
        const newScale = Math.min(Math.max(0.5, scale + delta), 3);
        setScale(newScale);
      }

      function handlePanStart(e) {
        setIsPanning(true);
        setPanStart({ x: e.clientX, y: e.clientY });
      }

      function zoomIn() {
        setScale((prev) => Math.min(prev + 0.1, 3));
      }
      function zoomOut() {
        setScale((prev) => Math.max(prev - 0.1, 0.5));
      }
      function resetView() {
        setScale(1);
        setOffset({ x: 0, y: 0 });
      }

      function addDot() {
        setDotPositions((prev) => [
          ...prev,
          { x: 50, y: 50, color: getRandomColor(), label: "New Marker" },
        ]);
      }

      function removeDot(idx) {
        setDotPositions((prev) => prev.filter((_, i) => i !== idx));
      }

      function updateDotLabel(idx, value) {
        setDotPositions((prev) =>
          prev.map((dot, i) => (i === idx ? { ...dot, label: value } : dot))
        );
      }

      function updateDotColor(idx, value) {
        setDotPositions((prev) =>
          prev.map((dot, i) => (i === idx ? { ...dot, color: value } : dot))
        );
      }

      function getRandomColor() {
        const colors = ["red", "blue", "green", "purple", "orange", "yellow", "black", "pink"];
        return colors[Math.floor(Math.random() * colors.length)];
      }

      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">Party & Enemy Location Map</h2>
          {mapImage ? (
            <div>
              <div
                className="relative overflow-hidden border-2 border-gray-300"
                style={{
                  width: "100%",
                  height: "500px",
                  cursor: isPanning ? "grabbing" : "grab",
                }}
                onMouseMove={handleMouseMove}
                onMouseUp={handleMouseUp}
                onMouseLeave={handleMouseUp}
                onWheel={handleWheel}
                ref={containerRef}
                onMouseDown={handlePanStart}
              >
                <img
                  src={mapImage}
                  alt="Map"
                  style={{
                    width: "100%",
                    height: "100%",
                    transformOrigin: "top left",
                    transform: `translate(${offset.x}px, ${offset.y}px) scale(${scale})`,
                  }}
                />
                {dotPositions.map((dot, index) => (
                  <div
                    key={index}
                    className="absolute w-6 h-6 rounded-full border-2 border-white flex items-center justify-center text-xs font-bold"
                    style={{
                      left: `calc(${dot.x}% + ${offset.x}px)`,
                      top: `calc(${dot.y}% + ${offset.y}px)`,
                      transform: `translate(-50%, -50%) scale(${scale})`,
                      backgroundColor: dot.color,
                      cursor: "grab",
                    }}
                    onMouseDown={handleMouseDown(index)}
                  ></div>
                ))}
              </div>
              <div className="mt-2">
                <p className="text-sm text-gray-700 mb-2">
                  Scroll wheel to zoom. Drag to pan. Drag dots to move them.
                </p>
                <div className="flex gap-2 flex-wrap mb-2">
                  <button onClick={zoomIn} className="px-2 py-1 bg-blue-400 text-white rounded">
                    Zoom In
                  </button>
                  <button onClick={zoomOut} className="px-2 py-1 bg-blue-400 text-white rounded">
                    Zoom Out
                  </button>
                  <button onClick={resetView} className="px-2 py-1 bg-blue-400 text-white rounded">
                    Reset View
                  </button>
                  <button onClick={addDot} className="px-2 py-1 bg-green-400 text-white rounded">
                    Add Marker
                  </button>
                  <button
                    className="px-2 py-1 bg-red-500 text-white rounded"
                    onClick={handleDeleteImage}
                  >
                    Delete Map
                  </button>
                </div>
                {dotPositions.length > 0 && (
                  <div className="bg-white p-2 rounded shadow text-sm">
                    <h4 className="font-bold">Markers:</h4>
                    {dotPositions.map((dot, idx) => (
                      <div key={idx} className="flex items-center gap-2 my-1">
                        <input
                          type="text"
                          className="border p-1 rounded"
                          value={dot.label}
                          onChange={(e) => updateDotLabel(idx, e.target.value)}
                          placeholder="Marker Label"
                        />
                        <select
                          className="border p-1 rounded"
                          value={dot.color}
                          onChange={(e) => updateDotColor(idx, e.target.value)}
                        >
                          <option value="red">Red</option>
                          <option value="blue">Blue</option>
                          <option value="green">Green</option>
                          <option value="purple">Purple</option>
                          <option value="orange">Orange</option>
                          <option value="yellow">Yellow</option>
                          <option value="black">Black</option>
                          <option value="pink">Pink</option>
                        </select>
                        <button
                          className="px-2 py-1 bg-red-400 text-white rounded"
                          onClick={() => removeDot(idx)}
                        >
                          Remove
                        </button>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            </div>
          ) : (
            <div className="flex items-center gap-2">
              <input
                type="file"
                accept="image/*"
                onChange={handleImageUpload}
                className="border p-1 rounded"
              />
            </div>
          )}
        </div>
      );
    }

    /********************************************
     * 9) PartyImages
     ********************************************/
    function PartyImages({ characters }) {
      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">Party Member Images</h2>
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            {characters.map((char) => (
              <div key={char.id} className="text-center">
                {char.image ? (
                  <img
                    src={char.image}
                    alt={char.name}
                    className="w-24 h-24 object-cover rounded-full mx-auto"
                  />
                ) : (
                  <div className="w-24 h-24 bg-gray-300 rounded-full mx-auto flex items-center justify-center">
                    <span className="text-gray-500 text-sm">No Image</span>
                  </div>
                )}
                <p className="mt-2 text-sm">{char.name}</p>
              </div>
            ))}
          </div>
        </div>
      );
    }

    /********************************************
     * 10) CopyButton
     ********************************************/
    function CopyButton({ characters, enemies }) {
      function handleCopy() {
        const text = [
          "### Characters",
          ...characters.map((c) => {
            return (
              "Character: " + c.name +
              "\nClass: " + c.class +
              "\nLevel: " + (c.level || 1) +
              "\nXP: " + (c.xp || 0) +
              "\nInitiative: " + (c.initiative || 0) +
              "\nHealth: " + c.health + "/" + c.maxHealth +
              "\nStatus: " + (c.status.length ? c.status.join(", ") : "None") +
              "\nEffects: " + (c.effects.length ? c.effects.join(", ") : "None") +
              "\nInventory: " + (c.inventory.length ? c.inventory.join(", ") : "None") +
              "\nAbilities: " + (c.specialAbilities.length ? c.specialAbilities.join(", ") : "None") +
              "\nSpells: " + (c.spellsMagic.length ? c.spellsMagic.join(", ") : "None") +
              "\nNotes: " + (c.notes || "None") +
              "\nImage: " + (c.image ? "Yes" : "No")
            );
          }),
          "\n### Enemies",
          ...enemies.map((e) => {
            return (
              "Enemy: " + e.name +
              "\nHealth: " + e.health + "/" + e.maxHealth
            );
          }),
        ].join("\n\n");

        navigator.clipboard.writeText(text).then(() => {
          alert("Character and enemy data copied to clipboard!");
        }).catch((err) => {
          console.error("Failed to copy text: ", err);
          alert("Failed to copy data. Check console for details.");
        });
      }

      return (
        <button
          className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 mb-2"
          onClick={handleCopy}
        >
          Copy for Prompt
        </button>
      );
    }

    /********************************************
     * 11) ClassesSection
     ********************************************/
    function ClassesSection() {
      const classes = [
        { name: "Artificer (Tinkerers & Inventors)", desc: "Artificers..." },
        { name: "Barbarian (Unstoppable Warriors)", desc: "Barbarians..." },
        { name: "Bard (Charming Performers & Spellcasters)", desc: "Bards..." },
        { name: "Cleric (Divine Warriors & Healers)", desc: "Clerics..." },
        { name: "Druid (Nature’s Guardians & Shapeshifters)", desc: "Druids..." },
        // etc. Add all your class descriptions
      ];

      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">D&D 5th Edition Classes</h2>
          <p className="mb-2 text-sm">
            Source:{" "}
            <a
              href="https://rpgbot.net/dnd5/characters/classes/"
              target="_blank"
              rel="noreferrer"
              className="text-blue-500 hover:underline"
            >
              RPGBot Classes
            </a>
          </p>
          <ul className="list-disc list-inside space-y-2 text-sm">
            {classes.map((cls) => (
              <li key={cls.name}>
                <span className="font-semibold">{cls.name}</span>: {cls.desc}
              </li>
            ))}
          </ul>
        </div>
      );
    }

    /********************************************
     * 12) RacesSection
     ********************************************/
    function RacesSection() {
      const races = [
        { name: "Aarakocra", desc: "Bird-like humanoids..." },
        { name: "Aasimar", desc: "Celestial-touched beings..." },
        // etc. Add more races
      ];

      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">D&D 5th Edition Races</h2>
          <p className="mb-2 text-sm">
            Source:{" "}
            <a
              href="https://rpgbot.net/dnd5/characters/races/"
              target="_blank"
              rel="noreferrer"
              className="text-blue-500 hover:underline"
            >
              RPGBot Races
            </a>
          </p>
          <ul className="list-disc list-inside space-y-1 text-sm">
            {races.map((race) => (
              <li key={race.name}>
                <span className="font-semibold">{race.name}</span>: {race.desc}
              </li>
            ))}
          </ul>
        </div>
      );
    }

    /********************************************
     * 13) MonsterCreatureList
     ********************************************/
    function MonsterCreatureList() {
      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">Monster/Creature List</h2>
          <p className="mb-2 text-sm">
            Access a comprehensive database of D&D monsters and creatures at:
          </p>
          <a
            href="https://www.aidedd.org/dnd-filters/monsters.php"
            target="_blank"
            rel="noreferrer"
            className="text-blue-500 hover:underline"
          >
            AIDEDD Monster Database
          </a>
          <p className="mt-2 text-sm text-gray-700">
            Use this resource to find detailed stats for monsters in your campaign.
          </p>
        </div>
      );
    }

    /********************************************
     * 14) SessionNotes
     ********************************************/
    function SessionNotes() {
      const [notes, setNotes] = React.useState(() => {
        return localStorage.getItem("sessionNotes") || "";
      });

      React.useEffect(() => {
        localStorage.setItem("sessionNotes", notes);
      }, [notes]);

      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">Session Notes</h2>
          <textarea
            className="border p-2 rounded w-full h-32 text-sm"
            placeholder="DM's notes, story hooks, etc."
            value={notes}
            onChange={(e) => setNotes(e.target.value)}
          />
        </div>
      );
    }

    /********************************************
     * 15) BulkActions
     ********************************************/
    function BulkActions({ onBulkHeal, onBulkDamage }) {
      const [amount, setAmount] = React.useState("0");
      const [targetType, setTargetType] = React.useState("characters");

      function handleHeal() {
        const amt = parseInt(amount, 10) || 0;
        if (amt > 0) onBulkHeal(targetType, amt);
      }
      function handleDamage() {
        const amt = parseInt(amount, 10) || 0;
        if (amt > 0) onBulkDamage(targetType, amt);
      }

      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">Bulk Heal/Damage</h2>
          <div className="flex flex-wrap items-end gap-2">
            <div>
              <label className="block text-sm font-medium mb-1">Amount</label>
              <input
                type="number"
                className="border rounded p-1 text-sm w-24"
                value={amount}
                onChange={(e) => setAmount(e.target.value)}
              />
            </div>
            <div>
              <label className="block text-sm font-medium mb-1">Target</label>
              <select
                className="border rounded p-1 text-sm"
                value={targetType}
                onChange={(e) => setTargetType(e.target.value)}
              >
                <option value="characters">All Characters</option>
                <option value="enemies">All Enemies</option>
              </select>
            </div>
            <div className="flex gap-2">
              <button
                className="px-2 py-1 bg-green-500 text-white rounded text-sm"
                onClick={handleHeal}
              >
                Heal
              </button>
              <button
                className="px-2 py-1 bg-red-500 text-white rounded text-sm"
                onClick={handleDamage}
              >
                Damage
              </button>
            </div>
          </div>
        </div>
      );
    }

    /********************************************
     * Main DnDTracker
     ********************************************/
    function DnDTracker() {
      const [collapsedCharacters, toggleCharacterCollapse] = useCollapseState("collapsedCharacters");
      const [collapsedEnemies, toggleEnemyCollapse] = useCollapseState("collapsedEnemies");

      // Characters
      const [characters, setCharacters] = React.useState(() => {
        const saved = localStorage.getItem("characters");
        let loaded = saved
          ? JSON.parse(saved)
          : [
              {
                id: 1,
                name: "Jory",
                class: "Cleric",
                health: 100,
                maxHealth: 100,
                status: [],
                effects: [],
                inventory: ["Mace", "Shield"],
                specialAbilities: ["Turn Undead"],
                spellsMagic: ["Cure Wounds"],
                image: null,
              },
            ];
        // Add missing fields
        return loaded.map((c) => ({
          ...c,
          level: c.level || 1,
          xp: c.xp || 0,
          initiative: c.initiative || 0,
          notes: c.notes || "",
          deathSaves: c.deathSaves || { success: 0, fail: 0 },
        }));
      });

      // Enemies
      const [enemies, setEnemies] = React.useState(() => {
        const saved = localStorage.getItem("enemies");
        return saved ? JSON.parse(saved) : [];
      });

      // Stats
      const [statRows, setStatRows] = React.useState(() => {
        const saved = localStorage.getItem("statRows");
        return saved
          ? JSON.parse(saved)
          : [{ id: 1, label: "Character #1", str: 10, dex: 10, con: 10, int: 10, wis: 10, cha: 10 }];
      });

      // Map
      const [mapImage, setMapImage] = React.useState(() => localStorage.getItem("mapImage") || null);
      const [dotPositions, setDotPositions] = React.useState(() => {
        const saved = localStorage.getItem("dotPositions");
        return saved ? JSON.parse(saved) : [];
      });

      // Sync changes to localStorage
      React.useEffect(() => {
        localStorage.setItem("characters", JSON.stringify(characters));
      }, [characters]);

      React.useEffect(() => {
        localStorage.setItem("enemies", JSON.stringify(enemies));
      }, [enemies]);

      React.useEffect(() => {
        localStorage.setItem("statRows", JSON.stringify(statRows));
      }, [statRows]);

      React.useEffect(() => {
        localStorage.setItem("mapImage", mapImage);
        localStorage.setItem("dotPositions", JSON.stringify(dotPositions));
      }, [mapImage, dotPositions]);

      // Character CRUD
      function addCharacter() {
        const newId = Date.now();
        setCharacters((prev) => [
          ...prev,
          {
            id: newId,
            name: "New Character",
            class: "Unassigned",
            health: 50,
            maxHealth: 50,
            status: [],
            effects: [],
            inventory: [],
            specialAbilities: [],
            spellsMagic: [],
            image: null,
            level: 1,
            xp: 0,
            initiative: 0,
            notes: "",
            deathSaves: { success: 0, fail: 0 },
          },
        ]);
      }
      function removeCharacter(charId) {
        setCharacters((prev) => prev.filter((c) => c.id !== charId));
      }
      function updateCharacter(updated) {
        setCharacters((prev) => prev.map((c) => (c.id === updated.id ? updated : c)));
      }
      function healCharacter(charId, amount) {
        setCharacters((prev) =>
          prev.map((c) =>
            c.id === charId
              ? { ...c, health: Math.min(c.maxHealth, c.health + amount) }
              : c
          )
        );
      }
      function damageCharacter(charId, amount) {
        setCharacters((prev) =>
          prev.map((c) =>
            c.id === charId
              ? { ...c, health: Math.max(0, c.health - amount) }
              : c
          )
        );
      }
      function removeStatus(charId, idx) {
        setCharacters((prev) =>
          prev.map((c) => {
            if (c.id === charId) {
              const updated = [...c.status];
              updated.splice(idx, 1);
              return { ...c, status: updated };
            }
            return c;
          })
        );
      }
      function removeEffect(charId, idx) {
        setCharacters((prev) =>
          prev.map((c) => {
            if (c.id === charId) {
              const updated = [...c.effects];
              updated.splice(idx, 1);
              return { ...c, effects: updated };
            }
            return c;
          })
        );
      }
      function removeItem(charId, idx) {
        setCharacters((prev) =>
          prev.map((c) => {
            if (c.id === charId) {
              const updated = [...c.inventory];
              updated.splice(idx, 1);
              return { ...c, inventory: updated };
            }
            return c;
          })
        );
      }
      function removeAbility(charId, idx) {
        setCharacters((prev) =>
          prev.map((c) => {
            if (c.id === charId) {
              const updated = [...c.specialAbilities];
              updated.splice(idx, 1);
              return { ...c, specialAbilities: updated };
            }
            return c;
          })
        );
      }
      function removeSpell(charId, idx) {
        setCharacters((prev) =>
          prev.map((c) => {
            if (c.id === charId) {
              const updated = [...c.spellsMagic];
              updated.splice(idx, 1);
              return { ...c, spellsMagic: updated };
            }
            return c;
          })
        );
      }

      // Enemy CRUD
      function addEnemy() {
        setEnemies((prev) => [
          ...prev,
          {
            id: Date.now(),
            name: "Enemy " + (prev.length + 1),
            health: 50,
            maxHealth: 50,
          },
        ]);
      }
      function removeEnemy(enemyId) {
        setEnemies((prev) => prev.filter((e) => e.id !== enemyId));
      }
      function healEnemy(enemyId, amount) {
        setEnemies((prev) =>
          prev.map((e) =>
            e.id === enemyId
              ? { ...e, health: Math.min(e.maxHealth, e.health + amount) }
              : e
          )
        );
      }
      function damageEnemy(enemyId, amount) {
        setEnemies((prev) =>
          prev.map((e) =>
            e.id === enemyId
              ? { ...e, health: Math.max(0, e.health - amount) }
              : e
          )
        );
      }
      function updateEnemy(updated) {
        setEnemies((prev) => prev.map((e) => (e.id === updated.id ? updated : e)));
      }

      // Bulk Heal/Damage
      function handleBulkHeal(target, amt) {
        if (target === "characters") {
          setCharacters((prev) =>
            prev.map((c) => ({
              ...c,
              health: Math.min(c.maxHealth, c.health + amt),
            }))
          );
        } else {
          // enemies
          setEnemies((prev) =>
            prev.map((e) => ({
              ...e,
              health: Math.min(e.maxHealth, e.health + amt),
            }))
          );
        }
      }
      function handleBulkDamage(target, amt) {
        if (target === "characters") {
          setCharacters((prev) =>
            prev.map((c) => ({
              ...c,
              health: Math.max(0, c.health - amt),
            }))
          );
        } else {
          setEnemies((prev) =>
            prev.map((e) => ({
              ...e,
              health: Math.max(0, e.health - amt),
            }))
          );
        }
      }

      return (
        <div className="container mx-auto p-4 space-y-4 parchment-bg">
          {/* Top Controls: Copy, Dark Mode, Backup/Restore */}
          <div className="flex flex-wrap justify-between items-center mb-2">
            <div className="flex gap-2">
              <CopyButton characters={characters} enemies={enemies} />
              <DarkModeToggle />
            </div>
            <div className="flex gap-2">
              <button
                className="px-2 py-1 bg-gray-500 text-white rounded"
                onClick={backupLocalStorage}
              >
                Backup Data
              </button>
              <label className="px-2 py-1 bg-gray-500 text-white rounded cursor-pointer">
                Restore
                <input
                  type="file"
                  className="hidden"
                  accept=".json"
                  onChange={(e) => restoreLocalStorage(e.target.files)}
                />
              </label>
            </div>
          </div>

          {/* Bulk Heal/Damage */}
          <BulkActions onBulkHeal={handleBulkHeal} onBulkDamage={handleBulkDamage} />

          {/* Party (Characters) */}
          <div className="bg-gray-100 p-4 rounded-lg">
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-xl font-bold">Party Status</h2>
              <button
                className="px-3 py-1 bg-green-500 text-white rounded"
                onClick={addCharacter}
              >
                Add Character
              </button>
            </div>
            <div className="grid gap-4">
              {characters.map((char) => (
                <CharacterCard
                  key={char.id}
                  char={char}
                  collapsed={!!collapsedCharacters[char.id]}
                  onToggleCollapse={toggleCharacterCollapse}
                  onRemoveChar={removeCharacter}
                  onUpdateChar={updateCharacter}
                  onHeal={healCharacter}
                  onDamage={damageCharacter}
                  onRemoveStatus={removeStatus}
                  onRemoveEffect={removeEffect}
                  onRemoveItem={removeItem}
                  onRemoveAbility={removeAbility}
                  onRemoveSpell={removeSpell}
                />
              ))}
            </div>
          </div>

          {/* Party Images */}
          <PartyImages characters={characters} />

          {/* Stats */}
          <StatsSection statRows={statRows} setStatRows={setStatRows} />

          {/* Enemies */}
          <div className="bg-gray-100 p-4 rounded-lg">
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-xl font-bold">Enemies</h2>
              <button
                className="px-3 py-1 bg-purple-500 text-white rounded"
                onClick={addEnemy}
              >
                Add Enemy
              </button>
            </div>
            <div className="grid gap-4">
              {enemies.map((enemy) => (
                <EnemyCard
                  key={enemy.id}
                  enemy={enemy}
                  collapsed={!!collapsedEnemies[enemy.id]}
                  onToggleCollapse={toggleEnemyCollapse}
                  onRemoveEnemy={removeEnemy}
                  onHealEnemy={healEnemy}
                  onDamageEnemy={damageEnemy}
                  onUpdateEnemy={updateEnemy}
                />
              ))}
            </div>
          </div>

          {/* Map */}
          <MapSection
            mapImage={mapImage}
            setMapImage={setMapImage}
            dotPositions={dotPositions}
            setDotPositions={setDotPositions}
          />

          {/* Dice */}
          <DiceRoller />

          {/* Notes */}
          <SessionNotes />

          {/* Classes */}
          <ClassesSection />

          {/* Races */}
          <RacesSection />

          {/* Monsters */}
          <MonsterCreatureList />
        </div>
      );
    }

    // Finally, render the main component:
    ReactDOM.render(<DnDTracker />, document.getElementById("root"));
  </script>
</body>
</html>
