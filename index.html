<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>D&D Player Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="mobile-web-app-capable" content="yes" />

  <!-- Tailwind CSS (CDN, for demos) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- React + ReactDOM 17 from jsDelivr (to avoid MIME errors) -->
  <script
    src="https://cdn.jsdelivr.net/npm/react@17/umd/react.development.js"
    crossorigin
  ></script>
  <script
    src="https://cdn.jsdelivr.net/npm/react-dom@17/umd/react-dom.development.js"
    crossorigin
  ></script>

  <!-- Babel for inline JSX (not for production) -->
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
</head>

<body class="bg-gray-50 text-gray-800">
  <div id="root" class="p-4"></div>

  <script type="text/babel">
    /************************************************
     * 1) CharacterCard Component
     * 2) EnemyCard Component
     * 3) StatsSection (Multi-Row Stat Calculator)
     * 4) DiceRoller (d20, d10, d2, d4, d6, d8, d12, d15)
     * 5) MapSection (Enhanced: 4 Draggable Dots)
     * 6) PartyImages (Dynamic Character Images)
     * 7) ClassesSection (Updated: D&D 5e Classes with New Descriptions)
     * 8) RacesSection (D&D 5e Races with Links)
     * 9) CopyButton (NEW: Copies Character and Enemy Data)
     * 10) MonsterCreatureList (NEW: Links to Monster Database)
     * 11) InitiativeTracker (NEW: Manages combat order)
     * 12) SpellTracker (NEW: Tracks spell slots and prepared spells)
     * 13) RestTracker (NEW: Manages short and long rests)
     * 14) ConditionReference (NEW: Reference for all conditions) 
     * 15) CurrencyTracker (NEW: Tracks party gold, silver, copper)
     * 16) WeatherTimeTracker (NEW: Tracks in-game time and weather)
     * 17) CombatLog (NEW: Tracks combat actions and results)
     * 18) NotepadComponent (NEW: For tracking campaign notes)
     * 19) XpTracker (NEW: Tracks experience points and levels)
     * 20) SpellLookup (NEW: Quick reference for spells)
     * 21) Main DnDTracker
     ************************************************/

    /* ---------------------------
       CharacterCard
       - Includes image upload for each character
    ---------------------------- */
    function CharacterCard({
      char,
      onUpdateChar,
      onHeal,
      onDamage,
      onRemoveStatus,
      onRemoveEffect,
      onRemoveItem,
      onRemoveAbility,
      onRemoveSpell,
      onRemoveChar,
    }) {
      const [isEditing, setIsEditing] = React.useState(false);
      const [editName, setEditName] = React.useState(char.name);
      const [editClass, setEditClass] = React.useState(char.class);
      const [editMaxHealth, setEditMaxHealth] = React.useState(String(char.maxHealth));
      const [newStatus, setNewStatus] = React.useState("");
      const [newEffect, setNewEffect] = React.useState("");
      const [newItem, setNewItem] = React.useState("");
      const [newAbility, setNewAbility] = React.useState("");
      const [newSpell, setNewSpell] = React.useState("");
      const [healInput, setHealInput] = React.useState("0");
      const [dmgInput, setDmgInput] = React.useState("0");

      React.useEffect(() => {
        setEditName(char.name);
        setEditClass(char.class);
        setEditMaxHealth(String(char.maxHealth));
      }, [char]);

      function handleImageUpload(event) {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            onUpdateChar({ ...char, image: e.target.result });
          };
          reader.readAsDataURL(file);
        }
      }

      function handleSave() {
        const parsedMax = parseInt(editMaxHealth, 10) || 0;
        const clippedHealth = Math.min(char.health, parsedMax);
        onUpdateChar({
          ...char,
          name: editName,
          class: editClass,
          maxHealth: parsedMax,
          health: clippedHealth,
        });
        setIsEditing(false);
      }

      function handleAddStatus() {
        if (!newStatus.trim()) return;
        const updated = [...char.status, newStatus.trim()];
        onUpdateChar({ ...char, status: updated });
        setNewStatus("");
      }

      function handleAddEffect() {
        if (!newEffect.trim()) return;
        const updated = [...char.effects, newEffect.trim()];
        onUpdateChar({ ...char, effects: updated });
        setNewEffect("");
      }

      function handleAddItem() {
        if (!newItem.trim()) return;
        const updated = [...char.inventory, newItem.trim()];
        onUpdateChar({ ...char, inventory: updated });
        setNewItem("");
      }

      function handleAddAbility() {
        if (!newAbility.trim()) return;
        const updated = [...char.specialAbilities, newAbility.trim()];
        onUpdateChar({ ...char, specialAbilities: updated });
        setNewAbility("");
      }

      function handleAddSpell() {
        if (!newSpell.trim()) return;
        const updated = [...char.spellsMagic, newSpell.trim()];
        onUpdateChar({ ...char, spellsMagic: updated });
        setNewSpell("");
      }

      function applyHeal() {
        const amt = parseInt(healInput, 10) || 0;
        onHeal(char.id, amt);
      }

      function applyDamage() {
        const amt = parseInt(dmgInput, 10) || 0;
        onDamage(char.id, amt);
      }

      if (isEditing) {
        return (
          <div className="bg-white p-4 rounded-lg shadow space-y-2">
            <div className="flex gap-2">
              <input
                className="border p-1 rounded"
                value={editName}
                onChange={(e) => setEditName(e.target.value)}
                placeholder="Name"
              />
              <input
                className="border p-1 rounded"
                value={editClass}
                onChange={(e) => setEditClass(e.target.value)}
                placeholder="Class"
              />
            </div>
            <div className="flex gap-2 items-center">
              <input
                type="number"
                className="border p-1 rounded w-24"
                value={editMaxHealth}
                onChange={(e) => setEditMaxHealth(e.target.value)}
                placeholder="Max Health"
              />
              <button
                className="px-3 py-1 bg-green-500 text-white rounded"
                onClick={handleSave}
              >
                Save
              </button>
              <button
                className="px-2 py-1 bg-gray-400 text-white rounded"
                onClick={() => setIsEditing(false)}
              >
                Cancel
              </button>
            </div>
          </div>
        );
      }

      return (
        <div className="bg-white p-4 rounded-lg shadow">
          <div className="flex justify-between items-center">
            <h3 className="font-bold">{char.name}</h3>
            <div className="flex items-center gap-2">
              <span className="text-sm text-gray-600">{char.class}</span>
              <button
                className="p-1 text-gray-500 hover:text-gray-700"
                onClick={() => setIsEditing(true)}
              >
                [EDIT]
              </button>
              <button
                className="px-2 py-1 bg-red-500 text-white rounded"
                onClick={() => onRemoveChar(char.id)}
              >
                Remove
              </button>
            </div>
          </div>

          <div className="mt-2">
            <label className="block text-sm font-medium text-gray-700">Character Image</label>
            {char.image ? (
              <div className="flex items-center gap-2">
                <img src={char.image} alt={char.name} className="w-16 h-16 object-cover rounded-full" />
                <button
                  className="px-2 py-1 bg-red-500 text-white rounded text-sm"
                  onClick={() => onUpdateChar({ ...char, image: null })}
                >
                  Remove Image
                </button>
              </div>
            ) : (
              <input
                type="file"
                accept="image/*"
                onChange={handleImageUpload}
                className="mt-1"
              />
            )}
          </div>

          <div className="mt-2">
            <div className="flex items-center gap-2">
              <span className="text-red-500">❤️</span>
              <div className="w-full bg-gray-200 rounded-full h-4">
                <div
                  className="bg-red-500 rounded-full h-4"
                  style={{
                    width: `${(char.health / char.maxHealth) * 100}%`,
                  }}
                ></div>
              </div>
              <span className="text-sm">
                {char.health}/{char.maxHealth}
              </span>
            </div>
          </div>

          <div className="mt-2">
            <h4 className="font-semibold text-sm">Status Conditions:</h4>
            <div className="flex flex-wrap gap-1 mt-1">
              {char.status.map((stat, idx) => (
                <span
                  key={idx}
                  className="px-2 py-1 text-sm bg-red-100 text-red-800 rounded-full flex items-center gap-1"
                >
                  [SKULL] {stat}
                  <button
                    className="hover:text-red-500"
                    onClick={() => onRemoveStatus(char.id, idx)}
                  >
                    [X]
                  </button>
                </span>
              ))}
            </div>
            <div className="flex gap-2 mt-1">
              <input
                className="border p-1 rounded text-sm"
                value={newStatus}
                onChange={(e) => setNewStatus(e.target.value)}
                placeholder="Add status condition"
              />
              <button
                className="px-2 py-1 bg-red-500 text-white rounded text-sm"
                onClick={handleAddStatus}
              >
                Add
              </button>
            </div>
          </div>

          <div className="mt-2">
            <h4 className="font-semibold text-sm">Effects:</h4>
            <div className="flex flex-wrap gap-1 mt-1">
              {char.effects.map((eff, idx) => (
                <span
                  key={idx}
                  className="px-2 py-1 text-sm bg-blue-100 text-blue-800 rounded-full flex items-center gap-1"
                >
                  {eff}
                  <button
                    className="hover:text-red-500"
                    onClick={() => onRemoveEffect(char.id, idx)}
                  >
                    [X]
                  </button>
                </span>
              ))}
            </div>
            <div className="flex gap-2 mt-1">
              <input
                className="border p-1 rounded text-sm"
                value={newEffect}
                onChange={(e) => setNewEffect(e.target.value)}
                placeholder="Add buff/effect"
              />
              <button
                className="px-2 py-1 bg-blue-500 text-white rounded text-sm"
                onClick={handleAddEffect}
              >
                Add
              </button>
            </div>
          </div>

          <div className="mt-2">
            <h4 className="font-semibold text-sm">Inventory:</h4>
            <div className="flex flex-wrap gap-1 mt-1">
              {char.inventory.map((item, idx) => (
                <span
                  key={idx}
                  className="px-2 py-1 text-sm bg-gray-100 rounded-full flex items-center gap-1"
                >
                  {item}
                  <button
                    className="hover:text-red-500"
                    onClick={() => onRemoveItem(char.id, idx)}
                  >
                    [X]
                  </button>
                </span>
              ))}
            </div>
            <div className="flex gap-2 mt-1">
              <input
                className="border p-1 rounded text-sm"
                value={newItem}
                onChange={(e) => setNewItem(e.target.value)}
                placeholder="New item"
              />
              <button
                className="px-2 py-1 bg-gray-500 text-white rounded text-sm"
                onClick={handleAddItem}
              >
                Add
              </button>
            </div>
          </div>

          <div className="mt-2">
            <h4 className="font-semibold text-sm">Special Abilities/Moves:</h4>
            <div className="flex flex-wrap gap-1 mt-1">
              {char.specialAbilities.map((ability, idx) => (
                <span
                  key={idx}
                  className="px-2 py-1 text-sm bg-green-100 text-green-800 rounded-full flex items-center gap-1"
                >
                  {ability}
                  <button
                    className="hover:text-red-500"
                    onClick={() => onRemoveAbility(char.id, idx)}
                  >
                    [X]
                  </button>
                </span>
              ))}
            </div>
            <div className="flex gap-2 mt-1">
              <input
                className="border p-1 rounded text-sm"
                value={newAbility}
                onChange={(e) => setNewAbility(e.target.value)}
                placeholder="Add ability/move"
              />
              <button
                className="px-2 py-1 bg-green-600 text-white rounded text-sm"
                onClick={handleAddAbility}
              >
                Add
              </button>
            </div>
          </div>

          <div className="mt-2">
            <h4 className="font-semibold text-sm">Spells/Magic/Divinity:</h4>
            <div className="flex flex-wrap gap-1 mt-1">
              {char.spellsMagic.map((spell, idx) => (
                <span
                  key={idx}
                  className="px-2 py-1 text-sm bg-purple-100 text-purple-800 rounded-full flex items-center gap-1"
                >
                  {spell}
                  <button
                    className="hover:text-purple-500"
                    onClick={() => onRemoveSpell(char.id, idx)}
                  >
                    [X]
                  </button>
                </span>
              ))}
            </div>
            <div className="flex gap-2 mt-1">
              <input
                className="border p-1 rounded text-sm"
                value={newSpell}
                onChange={(e) => setNewSpell(e.target.value)}
                placeholder="Add spell"
              />
              <button
                className="px-2 py-1 bg-purple-600 text-white rounded text-sm"
                onClick={handleAddSpell}
              >
                Add
              </button>
            </div>
          </div>

          <div className="mt-4 flex gap-2 items-center flex-wrap">
            <div className="flex items-center gap-2">
              <input
                type="number"
                className="w-16 border rounded p-1"
                value={healInput}
                onChange={(e) => setHealInput(e.target.value)}
                placeholder="Heal #"
              />
              <button
                className="px-3 py-1 bg-green-500 text-white rounded"
                onClick={applyHeal}
              >
                Heal
              </button>
            </div>
            <div className="flex items-center gap-2">
              <input
                type="number"
                className="w-16 border rounded p-1"
                value={dmgInput}
                onChange={(e) => setDmgInput(e.target.value)}
                placeholder="Dmg #"
              />
              <button
                className="px-3 py-1 bg-red-500 text-white rounded"
                onClick={applyDamage}
              >
                Damage
              </button>
            </div>
          </div>
        </div>
      );
    }

    /* ---------------------------
       EnemyCard
    ---------------------------- */
    function EnemyCard({
      enemy,
      onHealEnemy,
      onDamageEnemy,
      onRemoveEnemy,
      onUpdateEnemy,
    }) {
      const [isEditing, setIsEditing] = React.useState(false);
      const [editName, setEditName] = React.useState(enemy.name);
      const [editMaxHealth, setEditMaxHealth] = React.useState(String(enemy.maxHealth));
      const [editHealth, setEditHealth] = React.useState(String(enemy.health));
      const [healInput, setHealInput] = React.useState("0");
      const [dmgInput, setDmgInput] = React.useState("0");

      React.useEffect(() => {
        setEditName(enemy.name);
        setEditMaxHealth(String(enemy.maxHealth));
        setEditHealth(String(enemy.health));
      }, [enemy]);

      function handleSave() {
        const parsedMax = parseInt(editMaxHealth, 10) || 0;
        const parsedHealth = parseInt(editHealth, 10) || 0;
        const clippedHealth = Math.min(parsedHealth, parsedMax);
        onUpdateEnemy({
          ...enemy,
          name: editName,
          maxHealth: parsedMax,
          health: clippedHealth,
        });
        setIsEditing(false);
      }

      function applyHeal() {
        const amt = parseInt(healInput, 10) || 0;
        onHealEnemy(enemy.id, amt);
      }

      function applyDamage() {
        const amt = parseInt(dmgInput, 10) || 0;
        onDamageEnemy(enemy.id, amt);
      }

      if (isEditing) {
        return (
          <div className="bg-white p-4 rounded-lg shadow space-y-2">
            <div className="flex justify-between items-center">
              <h3 className="font-bold">Editing Enemy</h3>
              <button
                className="px-2 py-1 bg-red-500 text-white rounded"
                onClick={() => onRemoveEnemy(enemy.id)}
              >
                Defeat
              </button>
            </div>
            <div className="flex flex-col gap-2">
              <input
                className="border p-1 rounded"
                placeholder="Name"
                value={editName}
                onChange={(e) => setEditName(e.target.value)}
              />
              <input
                type="number"
                className="border p-1 rounded"
                placeholder="Max Health"
                value={editMaxHealth}
                onChange={(e) => setEditMaxHealth(e.target.value)}
              />
              <input
                type="number"
                className="border p-1 rounded"
                placeholder="Current Health"
                value={editHealth}
                onChange={(e) => setEditHealth(e.target.value)}
              />
              <div className="flex gap-2">
                <button
                  className="px-3 py-1 bg-green-500 text-white rounded"
                  onClick={handleSave}
                >
                  Save
                </button>
                <button
                  className="px-2 py-1 bg-gray-400 text-white rounded"
                  onClick={() => setIsEditing(false)}
                >
                  Cancel
                </button>
              </div>
            </div>
          </div>
        );
      }

      return (
        <div className="bg-white p-4 rounded-lg shadow">
          <div className="flex justify-between items-center">
            <h3 className="font-bold">{enemy.name}</h3>
            <div className="flex gap-2 items-center">
              <button
                className="p-1 text-gray-500 hover:text-gray-700"
                onClick={() => setIsEditing(true)}
              >
                [EDIT]
              </button>
              <button
                className="px-2 py-1 bg-red-500 text-white rounded"
                onClick={() => onRemoveEnemy(enemy.id)}
              >
                Defeat
              </button>
            </div>
          </div>
          <div className="mt-2">
            <div className="flex items-center gap-2">
              <span className="text-red-500">❤️</span>
              <div className="w-full bg-gray-200 rounded-full h-4">
                <div
                  className="bg-red-500 rounded-full h-4"
                  style={{
                    width: `${(enemy.health / enemy.maxHealth) * 100}%`,
                  }}
                ></div>
              </div>
              <span className="text-sm">
                {enemy.health}/{enemy.maxHealth}
              </span>
            </div>
          </div>
          <div className="mt-4 flex gap-2 items-center">
            <div className="flex items-center gap-2">
              <input
                type="number"
                className="w-16 border rounded p-1"
                value={healInput}
                onChange={(e) => setHealInput(e.target.value)}
                placeholder="Heal #"
              />
              <button
                className="px-3 py-1 bg-green-500 text-white rounded"
                onClick={applyHeal}
              >
                Heal
              </button>
            </div>
            <div className="flex items-center gap-2">
              <input
                type="number"
                className="w-16 border rounded p-1"
                value={dmgInput}
                onChange={(e) => setDmgInput(e.target.value)}
                placeholder="Dmg #"
              />
              <button
                className="px-3 py-1 bg-red-500 text-white rounded"
                onClick={applyDamage}
              >
                Damage
              </button>
            </div>
          </div>
        </div>
      );
    }

    /* ---------------------------
       StatsSection
    ---------------------------- */
    function StatsSection({ statRows, setStatRows }) {
      const [nextId, setNextId] = React.useState(
        statRows.length ? Math.max(...statRows.map((r) => r.id)) + 1 : 2
      );

      function addStatRow() {
        setStatRows((prev) => [
          ...prev,
          {
            id: nextId,
            label: `Character #${nextId}`,
            str: 10,
            dex: 10,
            con: 10,
            int: 10,
            wis: 10,
            cha: 10,
          },
        ]);
        setNextId((n) => n + 1);
      }

      function removeStatRow(rowId) {
        setStatRows((prev) => prev.filter((row) => row.id !== rowId));
      }

      function updateStatRow(rowId, updated) {
        setStatRows((prev) =>
          prev.map((row) => (row.id === rowId ? updated : row))
        );
      }

      function clampScore(val) {
        if (val < 6) return 6;
        if (val > 20) return 20;
        return val;
      }

      function computeMod(score) {
        const mod = Math.floor((score - 10) / 2);
        return mod >= 0 ? `+${mod}` : `${mod}`;
      }

      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <div className="flex justify-between items-center mb-2">
            <h2 className="text-xl font-bold">Stat Calculator</h2>
            <button
              className="px-2 py-1 bg-blue-500 text-white rounded"
              onClick={addStatRow}
            >
              Add Stat Row
            </button>
          </div>
          <p className="text-sm text-gray-700 mb-4">
            Enter scores (6–20) to see modifiers. Each row can represent a different character.
          </p>

          {statRows.map((row) => {
            const modSTR = computeMod(row.str);
            const modDEX = computeMod(row.dex);
            const modCON = computeMod(row.con);
            const modINT = computeMod(row.int);
            const modWIS = computeMod(row.wis);
            const modCHA = computeMod(row.cha);

            return (
              <div key={row.id} className="bg-white p-4 rounded shadow mb-4 space-y-2">
                <div className="flex justify-between items-center">
                  <input
                    className="border rounded p-1 text-sm"
                    value={row.label}
                    onChange={(e) =>
                      updateStatRow(row.id, { ...row, label: e.target.value })
                    }
                  />
                  <button
                    className="px-2 py-1 bg-red-500 text-white rounded text-sm"
                    onClick={() => removeStatRow(row.id)}
                  >
                    Remove Row
                  </button>
                </div>
                <div className="grid grid-cols-3 md:grid-cols-6 gap-4 mt-2">
                  <div className="flex flex-col">
                    <label className="font-semibold">STR</label>
                    <input
                      type="number"
                      className="border p-1 rounded"
                      value={row.str}
                      onChange={(e) => {
                        const val = clampScore(parseInt(e.target.value) || 10);
                        updateStatRow(row.id, { ...row, str: val });
                      }}
                    />
                    <span className="text-center text-blue-600 mt-1">
                      {modSTR}
                    </span>
                  </div>
                  <div className="flex flex-col">
                    <label className="font-semibold">DEX</label>
                    <input
                      type="number"
                      className="border p-1 rounded"
                      value={row.dex}
                      onChange={(e) => {
                        const val = clampScore(parseInt(e.target.value) || 10);
                        updateStatRow(row.id, { ...row, dex: val });
                      }}
                    />
                    <span className="text-center text-blue-600 mt-1">
                      {modDEX}
                    </span>
                  </div>
                  <div className="flex flex-col">
                    <label className="font-semibold">CON</label>
                    <input
                      type="number"
                      className="border p-1 rounded"
                      value={row.con}
                      onChange={(e) => {
                        const val = clampScore(parseInt(e.target.value) || 10);
                        updateStatRow(row.id, { ...row, con: val });
                      }}
                    />
                    <span className="text-center text-blue-600 mt-1">
                      {modCON}
                    </span>
                  </div>
                  <div className="flex flex-col">
                    <label className="font-semibold">INT</label>
                    <input
                      type="number"
                      className="border p-1 rounded"
                      value={row.int}
                      onChange={(e) => {
                        const val = clampScore(parseInt(e.target.value) || 10);
                        updateStatRow(row.id, { ...row, int: val });
                      }}
                    />
                    <span className="text-center text-blue-600 mt-1">
                      {modINT}
                    </span>
                  </div>
                  <div className="flex flex-col">
                    <label className="font-semibold">WIS</label>
                    <input
                      type="number"
                      className="border p-1 rounded"
                      value={row.wis}
                      onChange={(e) => {
                        const val = clampScore(parseInt(e.target.value) || 10);
                        updateStatRow(row.id, { ...row, wis: val });
                      }}
                    />
                    <span className="text-center text-blue-600 mt-1">
                      {modWIS}
                    </span>
                  </div>
                  <div className="flex flex-col">
                    <label className="font-semibold">CHA</label>
                    <input
                      type="number"
                      className="border p-1 rounded"
                      value={row.cha}
                      onChange={(e) => {
                        const val = clampScore(parseInt(e.target.value) || 10);
                        updateStatRow(row.id, { ...row, cha: val });
                      }}
                    />
                    <span className="text-center text-blue-600 mt-1">
                      {modCHA}
                    </span>
                  </div>
                </div>
              </div>
            );
          })}
        </div>
      );
    }

    /* ---------------------------
       DiceRoller
       - Includes d2, d4, d6, d8, d10, d12, d15, d20
    ---------------------------- */
    function DiceRoller() {
      const [roll, setRoll] = React.useState(null);

      function rollD(sides) {
        const result = Math.floor(Math.random() * sides) + 1;
        setRoll(`Rolled d${sides} ⇒ ${result}`);
      }

      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">Dice Roller</h2>
          <p className="mb-2">{roll === null ? "No roll yet" : roll}</p>
          <div className="flex gap-2">
            <button onClick={() => rollD(2)} className="px-3 py-1 bg-blue-500 text-white rounded">
              Roll d2
            </button>
            <button onClick={() => rollD(4)} className="px-3 py-1 bg-blue-500 text-white rounded">
              Roll d4
            </button>
            <button onClick={() => rollD(6)} className="px-3 py-1 bg-blue-500 text-white rounded">
              Roll d6
            </button>
            <button onClick={() => rollD(8)} className="px-3 py-1 bg-blue-500 text-white rounded">
              Roll d8
            </button>
            <button onClick={() => rollD(10)} className="px-3 py-1 bg-blue-500 text-white rounded">
              Roll d10
            </button>
            <button onClick={() => rollD(12)} className="px-3 py-1 bg-blue-500 text-white rounded">
              Roll d12
            </button>
            <button onClick={() => rollD(15)} className="px-3 py-1 bg-blue-500 text-white rounded">
              Roll d15
            </button>
            <button onClick={() => rollD(20)} className="px-3 py-1 bg-blue-500 text-white rounded">
              Roll d20
            </button>
          </div>
        </div>
      );
    }

    /* ---------------------------
       MapSection
       - Enhanced: Allows uploading an image, placing 4 colored dots (party + enemies), all draggable
    ---------------------------- */
    function MapSection({ mapImage, setMapImage, dotPositions, setDotPositions }) {
      const [isDragging, setIsDragging] = React.useState(null); // Track which dot is being dragged
      const containerRef = React.useRef(null);

      const handleImageUpload = (event) => {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            setMapImage(e.target.result);
            // Initialize 4 dots if not already set
            setDotPositions([
              { x: 25, y: 25, color: "red" },      // Party member 1
              { x: 75, y: 25, color: "blue" },     // Party member 2
              { x: 25, y: 75, color: "green" },    // Party member 3
              { x: 75, y: 75, color: "purple" },   // Enemies
            ]);
          };
          reader.readAsDataURL(file);
        }
      };

      const handleDeleteImage = () => {
        setMapImage(null);
        setDotPositions([]);
      };

      const handleMouseDown = (index) => (e) => {
        setIsDragging(index);
        moveDot(index, e);
      };

      const handleMouseMove = (e) => {
        if (isDragging !== null) {
          moveDot(isDragging, e);
        }
      };

      const handleMouseUp = () => {
        setIsDragging(null);
      };

      const moveDot = (index, e) => {
        if (containerRef.current && mapImage) {
          const rect = containerRef.current.getBoundingClientRect();
          const x = ((e.clientX - rect.left) / rect.width) * 100;
          const y = ((e.clientY - rect.top) / rect.height) * 100;
          setDotPositions((prev) =>
            prev.map((dot, i) =>
              i === index ? { ...dot, x: Math.max(0, Math.min(100, x)), y: Math.max(0, Math.min(100, y)) } : dot
            )
          );
        }
      };

      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">Party & Enemy Location Map</h2>
          {mapImage ? (
            <div className="relative">
              <div
                ref={containerRef}
                className="relative cursor-pointer"
                onMouseMove={handleMouseMove}
                onMouseUp={handleMouseUp}
                onMouseLeave={handleMouseUp}
              >
                <img src={mapImage} alt="Map" className="w-full" />
                {dotPositions.map((dot, index) => (
                  <div
                    key={index}
                    className={`absolute w-4 h-4 rounded-full`}
                    style={{
                      left: `${dot.x}%`,
                      top: `${dot.y}%`,
                      transform: "translate(-50%, -50%)",
                      backgroundColor: dot.color,
                      cursor: "grab",
                    }}
                    onMouseDown={handleMouseDown(index)}
                  ></div>
                ))}
              </div>
              <div className="mt-2">
                <p className="text-sm text-gray-700 mb-2">
                  Red: Party 1 | Blue: Party 2 | Green: Party 3 | Purple: Enemies
                </p>
                <div className="flex gap-2">
                  <input
                    type="file"
                    accept="image/*"
                    onChange={handleImageUpload}
                    className="border p-1 rounded"
                  />
                  <button
                    className="px-2 py-1 bg-red-500 text-white rounded"
                    onClick={handleDeleteImage}
                  >
                    Delete Map
                  </button>
                </div>
              </div>
            </div>
          ) : (
            <input
              type="file"
              accept="image/*"
              onChange={handleImageUpload}
              className="border p-1 rounded"
            />
          )}
        </div>
      );
    }

    /* ---------------------------
       PartyImages
       - Displays all character images dynamically
    ---------------------------- */
    function PartyImages({ characters }) {
      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">Party Member Images</h2>
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            {characters.map((char) => (
              <div key={char.id} className="text-center">
                {char.image ? (
                  <img
                    src={char.image}
                    alt={char.name}
                    className="w-24 h-24 object-cover rounded-full mx-auto"
                  />
                ) : (
                  <div className="w-24 h-24 bg-gray-300 rounded-full mx-auto flex items-center justify-center">
                    <span className="text-gray-500">No Image</span>
                  </div>
                )}
                <p className="mt-2">{char.name}</p>
              </div>
            ))}
          </div>
        </div>
      );
    }

    /* ---------------------------
       NEW: CopyButton
       - Copies character and enemy data to clipboard in text format
    ---------------------------- */
    function CopyButton({ characters, enemies }) {
      const handleCopy = () => {
        const text = [
          "### Characters",
          ...characters.map((char) => `
Character: ${char.name}
Class: ${char.class}
Health: ${char.health}/${char.maxHealth}
Status Conditions: ${char.status.length ? char.status.join(", ") : "None"}
Effects: ${char.effects.length ? char.effects.join(", ") : "None"}
Inventory: ${char.inventory.length ? char.inventory.join(", ") : "None"}
Special Abilities: ${char.specialAbilities.length ? char.specialAbilities.join(", ") : "None"}
Spells/Magic: ${char.spellsMagic.length ? char.spellsMagic.join(", ") : "None"}
Image: ${char.image ? "Uploaded" : "No Image"}
          `.trim()),
          "\n### Enemies",
          ...enemies.map((enemy) => `
Enemy: ${enemy.name}
Health: ${enemy.health}/${enemy.maxHealth}
          `.trim()),
        ].join("\n\n");

        navigator.clipboard.writeText(text).then(() => {
          alert("Character and enemy data copied to clipboard!");
        }).catch((err) => {
          console.error("Failed to copy text: ", err);
          alert("Failed to copy data. Check console for details.");
        });
      };

      return (
        <button
          className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 mb-4"
          onClick={handleCopy}
        >
          Copy for Prompt
        </button>
      );
    }

    /* ---------------------------
       ClassesSection
       - Updated: Lists D&D 5e classes with new descriptions and link to RPGBot
    ---------------------------- */
    function ClassesSection() {
      const classes = [
        { name: "Artificer (Tinkerers & Inventors)", desc: "Artificers thrive on intelligence, crafting, and magical engineering. Gnomes are natural inventors with minor illusions and magic resistance, while Autognomes are durable constructs with mechanical resilience. Vedalken excel in logic and mental resistance, and Warforged are living constructs immune to many conditions. Artificers specialize in infusions, magical tinkering, and intelligence-based spellcasting, making these races ideal for their class." },
        { name: "Barbarian (Unstoppable Warriors)", desc: "Barbarians rely on raw strength, endurance, and primal fury. Goliaths reduce incoming damage and excel in athletics, while Orcs gain extra movement and resilience in combat. Minotaurs are melee-focused chargers, and Half-Orcs can survive near-fatal blows while delivering devastating crits. Lizardfolk add natural armor and self-healing through bites. Barbarians excel in rage-fueled combat, unarmored defense, and brutal critical hits." },
        { name: "Bard (Charming Performers & Spellcasters)", desc: "Bards blend charisma, magic, and storytelling. Half-Elves gain extra skills and social flexibility, while Satyrs resist magic and enhance musical abilities. Fairies provide flight and innate spells, and Tabaxi have agility and charm, making them excellent performers. Kenku mimic sounds perfectly, ideal for deception and intrigue. Bards specialize in inspiring allies, versatile spellcasting, and performance-based magic." },
        { name: "Cleric (Divine Warriors & Healers)", desc: "Clerics channel divine magic for healing and battle. Aasimar have celestial energy and radiant resistance, while Dwarves provide durability and divine weapon proficiencies. Tritons control water and communicate with sea creatures, and Firbolgs possess nature magic and invisibility. Owlin offer wisdom-based spellcasting with natural flight. Clerics excel in divine magic, healing, and powerful protective spells." },
        { name: "Druid (Nature's Guardians & Shapeshifters)", desc: "Druids command nature and transform into beasts. Firbolgs excel with plant communication and stealth, while Tortles provide natural armor for defense. Lizardfolk have primal instincts and self-healing, and Shifters channel lycanthropic abilities. Wood Elves thrive in forests with heightened agility. Druids master wild shape, nature magic, and elemental control." },
        { name: "Fighter (Master Combatants & Strategists)", desc: "Fighters dominate the battlefield with weapons and tactics. Half-Orcs hit hard and endure, while Goliaths resist damage and excel in athletics. Hobgoblins enhance teamwork and tactical advantage, and Warforged provide durability with built-in armor. Leonin use powerful roars to intimidate foes. Fighters specialize in multiple attacks, weapon mastery, and versatile combat styles." },
        { name: "Monk (Masters of Martial Arts & Speed)", desc: "Monks rely on speed, agility, and spiritual focus. Tabaxi are nimble and fast, while Harengon have quick reflexes and high jumps. Kenku are stealthy and precise, and Githzerai have psionic defenses. Lizardfolk enhance their unarmed strikes with natural weapons. Monks excel in unarmed combat, mobility, and ki-powered abilities." },
        { name: "Paladin (Holy Warriors & Protectors)", desc: "Paladins wield divine magic alongside martial prowess. Aasimar gain celestial blessings and radiant abilities, while Dragonborn channel draconic power with elemental breath weapons. Dwarves bring durability and divine weapon skills, and Tritons harness oceanic magic. Leonin have natural authority and powerful combat presence. Paladins specialize in divine smites, healing, and protective auras." },
        { name: "Ranger (Wilderness Scouts & Hunters)", desc: "Rangers track, hunt, and wield nature magic. Wood Elves have superior stealth and speed, while Tabaxi move swiftly and excel in scouting. Goliaths are rugged survivalists with cold resistance, and Firbolgs use magic to blend into nature. Kenku thrive in ambush tactics. Rangers excel in tracking, ranged combat, and natural exploration." },
        { name: "Rogue (Stealthy Assassins & Tricksters)", desc: "Rogues rely on cunning, speed, and precision. Halflings avoid misfortune with their luck trait, while Tabaxi use agility and speed for quick getaways. Kobolds have pack tactics for deadly strikes, and Kenku mimic voices for deception. Goblin rogues use their nimbleness and quick escapes. Rogues specialize in sneak attacks, evasive movement, and deception." },
        { name: "Sorcerer (Innate Spellcasters & Magical Prodigies)", desc: "Sorcerers wield raw, untamed magic. Dragonborn inherit draconic power with elemental resistances, while Tieflings draw strength from infernal ancestry. Aasimar harness celestial energy, and Genasi wield elemental magic. Fairies bring flight and innate spellcasting. Sorcerers specialize in metamagic, spontaneous casting, and magical surges." },
        { name: "Warlock (Pact-Bound Spellcasters & Eldritch Wielders)", desc: "Warlocks make pacts with powerful entities for magic. Tieflings tap into fiendish energy, while Hexbloods have
