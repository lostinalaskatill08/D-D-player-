<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>D&D Player Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="mobile-web-app-capable" content="yes" />

  <!-- Tailwind CSS (CDN, for demos) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- React + ReactDOM 17 from jsDelivr (to avoid MIME errors) -->
  <script
    src="https://cdn.jsdelivr.net/npm/react@17/umd/react.development.js"
    crossorigin
  ></script>
  <script
    src="https://cdn.jsdelivr.net/npm/react-dom@17/umd/react-dom.development.js"
    crossorigin
  ></script>

  <!-- Babel for inline JSX (not for production) -->
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
</head>

<body class="bg-gray-50 text-gray-800">
  <div id="root" class="p-4"></div>

  <script type="text/babel">
    /************************************************
     * 1) CharacterCard Component
     * 2) EnemyCard Component
     * 3) StatsSection (Multi-Row Stat Calculator)
     * 4) DiceRoller (d20, d10, d2, d4, d6, d8, d12, d15)
     * 5) MapSection (Enhanced: 4 Draggable Dots)
     * 6) PartyImages (Dynamic Character Images)
     * 7) ClassesSection (Updated: D&D 5e Classes with New Descriptions)
     * 8) RacesSection (D&D 5e Races with Links)
     * 9) CopyButton (NEW: Copies Character and Enemy Data)
     * 10) MonsterCreatureList (NEW: Links to Monster Database)
     * 11) InitiativeTracker (NEW: Manages combat order)
     * 12) SpellTracker (NEW: Tracks spell slots and prepared spells)
     * 13) RestTracker (NEW: Manages short and long rests)
     * 14) ConditionReference (NEW: Reference for all conditions) 
     * 15) CurrencyTracker (NEW: Tracks party gold, silver, copper)
     * 16) WeatherTimeTracker (NEW: Tracks in-game time and weather)
     * 17) CombatLog (NEW: Tracks combat actions and results)
     * 18) NotepadComponent (NEW: For tracking campaign notes)
     * 19) XpTracker (NEW: Tracks experience points and levels)
     * 20) SpellLookup (NEW: Quick reference for spells)
     * 21) Main DnDTracker
     ************************************************/

    /* ---------------------------
       CharacterCard
       - Includes image upload for each character
    ---------------------------- */
    function CharacterCard({
      char,
      onUpdateChar,
      onHeal,
      onDamage,
      onRemoveStatus,
      onRemoveEffect,
      onRemoveItem,
      onRemoveAbility,
      onRemoveSpell,
      onRemoveChar,
    }) {
      const [isEditing, setIsEditing] = React.useState(false);
      const [editName, setEditName] = React.useState(char.name);
      const [editClass, setEditClass] = React.useState(char.class);
      const [editMaxHealth, setEditMaxHealth] = React.useState(String(char.maxHealth));
      const [newStatus, setNewStatus] = React.useState("");
      const [newEffect, setNewEffect] = React.useState("");
      const [newItem, setNewItem] = React.useState("");
      const [newAbility, setNewAbility] = React.useState("");
      const [newSpell, setNewSpell] = React.useState("");
      const [healInput, setHealInput] = React.useState("0");
      const [dmgInput, setDmgInput] = React.useState("0");

      React.useEffect(() => {
        setEditName(char.name);
        setEditClass(char.class);
        setEditMaxHealth(String(char.maxHealth));
      }, [char]);

      function handleImageUpload(event) {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            onUpdateChar({ ...char, image: e.target.result });
          };
          reader.readAsDataURL(file);
        }
      }

      function handleSave() {
        const parsedMax = parseInt(editMaxHealth, 10) || 0;
        const clippedHealth = Math.min(char.health, parsedMax);
        onUpdateChar({
          ...char,
          name: editName,
          class: editClass,
          maxHealth: parsedMax,
          health: clippedHealth,
        });
        setIsEditing(false);
      }

      function handleAddStatus() {
        if (!newStatus.trim()) return;
        const updated = [...char.status, newStatus.trim()];
        onUpdateChar({ ...char, status: updated });
        setNewStatus("");
      }

      function handleAddEffect() {
        if (!newEffect.trim()) return;
        const updated = [...char.effects, newEffect.trim()];
        onUpdateChar({ ...char, effects: updated });
        setNewEffect("");
      }

      function handleAddItem() {
        if (!newItem.trim()) return;
        const updated = [...char.inventory, newItem.trim()];
        onUpdateChar({ ...char, inventory: updated });
        setNewItem("");
      }

      function handleAddAbility() {
        if (!newAbility.trim()) return;
        const updated = [...char.specialAbilities, newAbility.trim()];
        onUpdateChar({ ...char, specialAbilities: updated });
        setNewAbility("");
      }

      function handleAddSpell() {
        if (!newSpell.trim()) return;
        const updated = [...char.spellsMagic, newSpell.trim()];
        onUpdateChar({ ...char, spellsMagic: updated });
        setNewSpell("");
      }

      function applyHeal() {
        const amt = parseInt(healInput, 10) || 0;
        onHeal(char.id, amt);
      }

      function applyDamage() {
        const amt = parseInt(dmgInput, 10) || 0;
        onDamage(char.id, amt);
      }

      if (isEditing) {
        return (
          <div className="bg-white p-4 rounded-lg shadow space-y-2">
            <div className="flex gap-2">
              <input
                className="border p-1 rounded"
                value={editName}
                onChange={(e) => setEditName(e.target.value)}
                placeholder="Name"
              />
              <input
                className="border p-1 rounded"
                value={editClass}
                onChange={(e) => setEditClass(e.target.value)}
                placeholder="Class"
              />
            </div>
            <div className="flex gap-2 items-center">
              <input
                type="number"
                className="border p-1 rounded w-24"
                value={editMaxHealth}
                onChange={(e) => setEditMaxHealth(e.target.value)}
                placeholder="Max Health"
              />
              <button
                className="px-3 py-1 bg-green-500 text-white rounded"
                onClick={handleSave}
              >
                Save
              </button>
              <button
                className="px-2 py-1 bg-gray-400 text-white rounded"
                onClick={() => setIsEditing(false)}
              >
                Cancel
              </button>
            </div>
          </div>
        );
      }

      return (
        <div className="bg-white p-4 rounded-lg shadow">
          <div className="flex justify-between items-center">
            <h3 className="font-bold">{char.name}</h3>
            <div className="flex items-center gap-2">
              <span className="text-sm text-gray-600">{char.class}</span>
              <button
                className="p-1 text-gray-500 hover:text-gray-700"
                onClick={() => setIsEditing(true)}
              >
                [EDIT]
              </button>
              <button
                className="px-2 py-1 bg-red-500 text-white rounded"
                onClick={() => onRemoveChar(char.id)}
              >
                Remove
              </button>
            </div>
          </div>

          <div className="mt-2">
            <label className="block text-sm font-medium text-gray-700">Character Image</label>
            {char.image ? (
              <div className="flex items-center gap-2">
                <img src={char.image} alt={char.name} className="w-16 h-16 object-cover rounded-full" />
                <button
                  className="px-2 py-1 bg-red-500 text-white rounded text-sm"
                  onClick={() => onUpdateChar({ ...char, image: null })}
                >
                  Remove Image
                </button>
              </div>
            ) : (
              <input
                type="file"
                accept="image/*"
                onChange={handleImageUpload}
                className="mt-1"
              />
            )}
          </div>

          <div className="mt-2">
            <div className="flex items-center gap-2">
              <span className="text-red-500">❤️</span>
              <div className="w-full bg-gray-200 rounded-full h-4">
                <div
                  className="bg-red-500 rounded-full h-4"
                  style={{
                    width: `${(char.health / char.maxHealth) * 100}%`,
                  }}
                ></div>
              </div>
              <span className="text-sm">
                {char.health}/{char.maxHealth}
              </span>
            </div>
          </div>

          <div className="mt-2">
            <h4 className="font-semibold text-sm">Status Conditions:</h4>
            <div className="flex flex-wrap gap-1 mt-1">
              {char.status.map((stat, idx) => (
                <span
                  key={idx}
                  className="px-2 py-1 text-sm bg-red-100 text-red-800 rounded-full flex items-center gap-1"
                >
                  [SKULL] {stat}
                  <button
                    className="hover:text-red-500"
                    onClick={() => onRemoveStatus(char.id, idx)}
                  >
                    [X]
                  </button>
                </span>
              ))}
            </div>
            <div className="flex gap-2 mt-1">
              <input
                className="border p-1 rounded text-sm"
                value={newStatus}
                onChange={(e) => setNewStatus(e.target.value)}
                placeholder="Add status condition"
              />
              <button
                className="px-2 py-1 bg-red-500 text-white rounded text-sm"
                onClick={handleAddStatus}
              >
                Add
              </button>
            </div>
          </div>

          <div className="mt-2">
            <h4 className="font-semibold text-sm">Effects:</h4>
            <div className="flex flex-wrap gap-1 mt-1">
              {char.effects.map((eff, idx) => (
                <span
                  key={idx}
                  className="px-2 py-1 text-sm bg-blue-100 text-blue-800 rounded-full flex items-center gap-1"
                >
                  {eff}
                  <button
                    className="hover:text-red-500"
                    onClick={() => onRemoveEffect(char.id, idx)}
                  >
                    [X]
                  </button>
                </span>
              ))}
            </div>
            <div className="flex gap-2 mt-1">
              <input
                className="border p-1 rounded text-sm"
                value={newEffect}
                onChange={(e) => setNewEffect(e.target.value)}
                placeholder="Add buff/effect"
              />
              <button
                className="px-2 py-1 bg-blue-500 text-white rounded text-sm"
                onClick={handleAddEffect}
              >
                Add
              </button>
            </div>
          </div>

          <div className="mt-2">
            <h4 className="font-semibold text-sm">Inventory:</h4>
            <div className="flex flex-wrap gap-1 mt-1">
              {char.inventory.map((item, idx) => (
                <span
                  key={idx}
                  className="px-2 py-1 text-sm bg-gray-100 rounded-full flex items-center gap-1"
                >
                  {item}
                  <button
                    className="hover:text-red-500"
                    onClick={() => onRemoveItem(char.id, idx)}
                  >
                    [X]
                  </button>
                </span>
              ))}
            </div>
            <div className="flex gap-2 mt-1">
              <input
                className="border p-1 rounded text-sm"
                value={newItem}
                onChange={(e) => setNewItem(e.target.value)}
                placeholder="New item"
              />
              <button
                className="px-2 py-1 bg-gray-500 text-white rounded text-sm"
                onClick={handleAddItem}
              >
                Add
              </button>
            </div>
          </div>

          <div className="mt-2">
            <h4 className="font-semibold text-sm">Special Abilities/Moves:</h4>
            <div className="flex flex-wrap gap-1 mt-1">
              {char.specialAbilities.map((ability, idx) => (
                <span
                  key={idx}
                  className="px-2 py-1 text-sm bg-green-100 text-green-800 rounded-full flex items-center gap-1"
                >
                  {ability}
                  <button
                    className="hover:text-red-500"
                    onClick={() => onRemoveAbility(char.id, idx)}
                  >
                    [X]
                  </button>
                </span>
              ))}
            </div>
            <div className="flex gap-2 mt-1">
              <input
                className="border p-1 rounded text-sm"
                value={newAbility}
                onChange={(e) => setNewAbility(e.target.value)}
                placeholder="Add ability/move"
              />
              <button
                className="px-2 py-1 bg-green-600 text-white rounded text-sm"
                onClick={handleAddAbility}
              >
                Add
              </button>
            </div>
          </div>

          <div className="mt-2">
            <h4 className="font-semibold text-sm">Spells/Magic/Divinity:</h4>
            <div className="flex flex-wrap gap-1 mt-1">
              {char.spellsMagic.map((spell, idx) => (
                <span
                  key={idx}
                  className="px-2 py-1 text-sm bg-purple-100 text-purple-800 rounded-full flex items-center gap-1"
                >
                  {spell}
                  <button
                    className="hover:text-purple-500"
                    onClick={() => onRemoveSpell(char.id, idx)}
                  >
                    [X]
                  </button>
                </span>
              ))}
            </div>
            <div className="flex gap-2 mt-1">
              <input
                className="border p-1 rounded text-sm"
                value={newSpell}
                onChange={(e) => setNewSpell(e.target.value)}
                placeholder="Add spell"
              />
              <button
                className="px-2 py-1 bg-purple-600 text-white rounded text-sm"
                onClick={handleAddSpell}
              >
                Add
              </button>
            </div>
          </div>

          <div className="mt-4 flex gap-2 items-center flex-wrap">
            <div className="flex items-center gap-2">
              <input
                type="number"
                className="w-16 border rounded p-1"
                value={healInput}
                onChange={(e) => setHealInput(e.target.value)}
                placeholder="Heal #"
              />
              <button
                className="px-3 py-1 bg-green-500 text-white rounded"
                onClick={applyHeal}
              >
                Heal
              </button>
            </div>
            <div className="flex items-center gap-2">
              <input
                type="number"
                className="w-16 border rounded p-1"
                value={dmgInput}
                onChange={(e) => setDmgInput(e.target.value)}
                placeholder="Dmg #"
              />
              <button
                className="px-3 py-1 bg-red-500 text-white rounded"
                onClick={applyDamage}
              >
                Damage
              </button>
            </div>
          </div>
        </div>
      );
    }

    /* ---------------------------
       EnemyCard
    ---------------------------- */
    function EnemyCard({
      enemy,
      onHealEnemy,
      onDamageEnemy,
      onRemoveEnemy,
      onUpdateEnemy,
    }) {
      const [isEditing, setIsEditing] = React.useState(false);
      const [editName, setEditName] = React.useState(enemy.name);
      const [editMaxHealth, setEditMaxHealth] = React.useState(String(enemy.maxHealth));
      const [editHealth, setEditHealth] = React.useState(String(enemy.health));
      const [healInput, setHealInput] = React.useState("0");
      const [dmgInput, setDmgInput] = React.useState("0");

      React.useEffect(() => {
        setEditName(enemy.name);
        setEditMaxHealth(String(enemy.maxHealth));
        setEditHealth(String(enemy.health));
      }, [enemy]);

      function handleSave() {
        const parsedMax = parseInt(editMaxHealth, 10) || 0;
        const parsedHealth = parseInt(editHealth, 10) || 0;
        const clippedHealth = Math.min(parsedHealth, parsedMax);
        onUpdateEnemy({
          ...enemy,
          name: editName,
          maxHealth: parsedMax,
          health: clippedHealth,
        });
        setIsEditing(false);
      }

      function applyHeal() {
        const amt = parseInt(healInput, 10) || 0;
        onHealEnemy(enemy.id, amt);
      }

      function applyDamage() {
        const amt = parseInt(dmgInput, 10) || 0;
        onDamageEnemy(enemy.id, amt);
      }

      if (isEditing) {
        return (
          <div className="bg-white p-4 rounded-lg shadow space-y-2">
            <div className="flex justify-between items-center">
              <h3 className="font-bold">Editing Enemy</h3>
              <button
                className="px-2 py-1 bg-red-500 text-white rounded"
                onClick={() => onRemoveEnemy(enemy.id)}
              >
                Defeat
              </button>
            </div>
            <div className="flex flex-col gap-2">
              <input
                className="border p-1 rounded"
                placeholder="Name"
                value={editName}
                onChange={(e) => setEditName(e.target.value)}
              />
              <input
                type="number"
                className="border p-1 rounded"
                placeholder="Max Health"
                value={editMaxHealth}
                onChange={(e) => setEditMaxHealth(e.target.value)}
              />
              <input
                type="number"
                className="border p-1 rounded"
                placeholder="Current Health"
                value={editHealth}
                onChange={(e) => setEditHealth(e.target.value)}
              />
              <div className="flex gap-2">
                <button
                  className="px-3 py-1 bg-green-500 text-white rounded"
                  onClick={handleSave}
                >
                  Save
                </button>
                <button
                  className="px-2 py-1 bg-gray-400 text-white rounded"
                  onClick={() => setIsEditing(false)}
                >
                  Cancel
                </button>
              </div>
            </div>
          </div>
        );
      }

      return (
        <div className="bg-white p-4 rounded-lg shadow">
          <div className="flex justify-between items-center">
            <h3 className="font-bold">{enemy.name}</h3>
            <div className="flex gap-2 items-center">
              <button
                className="p-1 text-gray-500 hover:text-gray-700"
                onClick={() => setIsEditing(true)}
              >
                [EDIT]
              </button>
              <button
                className="px-2 py-1 bg-red-500 text-white rounded"
                onClick={() => onRemoveEnemy(enemy.id)}
              >
                Defeat
              </button>
            </div>
          </div>
          <div className="mt-2">
            <div className="flex items-center gap-2">
              <span className="text-red-500">❤️</span>
              <div className="w-full bg-gray-200 rounded-full h-4">
                <div
                  className="bg-red-500 rounded-full h-4"
                  style={{
                    width: `${(enemy.health / enemy.maxHealth) * 100}%`,
                  }}
                ></div>
              </div>
              <span className="text-sm">
                {enemy.health}/{enemy.maxHealth}
              </span>
            </div>
          </div>
          <div className="mt-4 flex gap-2 items-center">
            <div className="flex items-center gap-2">
              <input
                type="number"
                className="w-16 border rounded p-1"
                value={healInput}
                onChange={(e) => setHealInput(e.target.value)}
                placeholder="Heal #"
              />
              <button
                className="px-3 py-1 bg-green-500 text-white rounded"
                onClick={applyHeal}
              >
                Heal
              </button>
            </div>
            <div className="flex items-center gap-2">
              <input
                type="number"
                className="w-16 border rounded p-1"
                value={dmgInput}
                onChange={(e) => setDmgInput(e.target.value)}
                placeholder="Dmg #"
              />
              <button
                className="px-3 py-1 bg-red-500 text-white rounded"
                onClick={applyDamage}
              >
                Damage
              </button>
            </div>
          </div>
        </div>
      );
    }

    /* ---------------------------
       StatsSection
    ---------------------------- */
    function StatsSection({ statRows, setStatRows }) {
      const [nextId, setNextId] = React.useState(
        statRows.length ? Math.max(...statRows.map((r) => r.id)) + 1 : 2
      );

      function addStatRow() {
        setStatRows((prev) => [
          ...prev,
          {
            id: nextId,
            label: `Character #${nextId}`,
            str: 10,
            dex: 10,
            con: 10,
            int: 10,
            wis: 10,
            cha: 10,
          },
        ]);
        setNextId((n) => n + 1);
      }

      function removeStatRow(rowId) {
        setStatRows((prev) => prev.filter((row) => row.id !== rowId));
      }

      function updateStatRow(rowId, updated) {
        setStatRows((prev) =>
          prev.map((row) => (row.id === rowId ? updated : row))
        );
      }

      function clampScore(val) {
        if (val < 6) return 6;
        if (val > 20) return 20;
        return val;
      }

      function computeMod(score) {
        const mod = Math.floor((score - 10) / 2);
        return mod >= 0 ? `+${mod}` : `${mod}`;
      }

      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <div className="flex justify-between items-center mb-2">
            <h2 className="text-xl font-bold">Stat Calculator</h2>
            <button
              className="px-2 py-1 bg-blue-500 text-white rounded"
              onClick={addStatRow}
            >
              Add Stat Row
            </button>
          </div>
          <p className="text-sm text-gray-700 mb-4">
            Enter scores (6–20) to see modifiers. Each row can represent a different character.
          </p>

          {statRows.map((row) => {
            const modSTR = computeMod(row.str);
            const modDEX = computeMod(row.dex);
            const modCON = computeMod(row.con);
            const modINT = computeMod(row.int);
            const modWIS = computeMod(row.wis);
            const modCHA = computeMod(row.cha);

            return (
              <div key={row.id} className="bg-white p-4 rounded shadow mb-4 space-y-2">
                <div className="flex justify-between items-center">
                  <input
                    className="border rounded p-1 text-sm"
                    value={row.label}
                    onChange={(e) =>
                      updateStatRow(row.id, { ...row, label: e.target.value })
                    }
                  />
                  <button
                    className="px-2 py-1 bg-red-500 text-white rounded text-sm"
                    onClick={() => removeStatRow(row.id)}
                  >
                    Remove Row
                  </button>
                </div>
                <div className="grid grid-cols-3 md:grid-cols-6 gap-4 mt-2">
                  <div className="flex flex-col">
                    <label className="font-semibold">STR</label>
                    <input
                      type="number"
                      className="border p-1 rounded"
                      value={row.str}
                      onChange={(e) => {
                        const val = clampScore(parseInt(e.target.value) || 10);
                        updateStatRow(row.id, { ...row, str: val });
                      }}
                    />
                    <span className="text-center text-blue-600 mt-1">
                      {modSTR}
                    </span>
                  </div>
                  <div className="flex flex-col">
                    <label className="font-semibold">DEX</label>
                    <input
                      type="number"
                      className="border p-1 rounded"
                      value={row.dex}
                      onChange={(e) => {
                        const val = clampScore(parseInt(e.target.value) || 10);
                        updateStatRow(row.id, { ...row, dex: val });
                      }}
                    />
                    <span className="text-center text-blue-600 mt-1">
                      {modDEX}
                    </span>
                  </div>
                  <div className="flex flex-col">
                    <label className="font-semibold">CON</label>
                    <input
                      type="number"
                      className="border p-1 rounded"
                      value={row.con}
                      onChange={(e) => {
                        const val = clampScore(parseInt(e.target.value) || 10);
                        updateStatRow(row.id, { ...row, con: val });
                      }}
                    />
                    <span className="text-center text-blue-600 mt-1">
                      {modCON}
                    </span>
                  </div>
                  <div className="flex flex-col">
                    <label className="font-semibold">INT</label>
                    <input
                      type="number"
                      className="border p-1 rounded"
                      value={row.int}
                      onChange={(e) => {
                        const val = clampScore(parseInt(e.target.value) || 10);
                        updateStatRow(row.id, { ...row, int: val });
                      }}
                    />
                    <span className="text-center text-blue-600 mt-1">
                      {modINT}
                    </span>
                  </div>
                  <div className="flex flex-col">
                    <label className="font-semibold">WIS</label>
                    <input
                      type="number"
                      className="border p-1 rounded"
                      value={row.wis}
                      onChange={(e) => {
                        const val = clampScore(parseInt(e.target.value) || 10);
                        updateStatRow(row.id, { ...row, wis: val });
                      }}
                    />
                    <span className="text-center text-blue-600 mt-1">
                      {modWIS}
                    </span>
                  </div>
                  <div className="flex flex-col">
                    <label className="font-semibold">CHA</label>
                    <input
                      type="number"
                      className="border p-1 rounded"
                      value={row.cha}
                      onChange={(e) => {
                        const val = clampScore(parseInt(e.target.value) || 10);
                        updateStatRow(row.id, { ...row, cha: val });
                      }}
                    />
                    <span className="text-center text-blue-600 mt-1">
                      {modCHA}
                    </span>
                  </div>
                </div>
              </div>
            );
          })}
        </div>
      );
    }

    /* ---------------------------
       DiceRoller
       - Includes d2, d4, d6, d8, d10, d12, d15, d20
    ---------------------------- */
    function DiceRoller() {
      const [roll, setRoll] = React.useState(null);

      function rollD(sides) {
        const result = Math.floor(Math.random() * sides) + 1;
        setRoll(`Rolled d${sides} ⇒ ${result}`);
      }

      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">Dice Roller</h2>
          <p className="mb-2">{roll === null ? "No roll yet" : roll}</p>
          <div className="flex gap-2">
            <button onClick={() => rollD(2)} className="px-3 py-1 bg-blue-500 text-white rounded">
              Roll d2
            </button>
            <button onClick={() => rollD(4)} className="px-3 py-1 bg-blue-500 text-white rounded">
              Roll d4
            </button>
            <button onClick={() => rollD(6)} className="px-3 py-1 bg-blue-500 text-white rounded">
              Roll d6
            </button>
            <button onClick={() => rollD(8)} className="px-3 py-1 bg-blue-500 text-white rounded">
              Roll d8
            </button>
            <button onClick={() => rollD(10)} className="px-3 py-1 bg-blue-500 text-white rounded">
              Roll d10
            </button>
            <button onClick={() => rollD(12)} className="px-3 py-1 bg-blue-500 text-white rounded">
              Roll d12
            </button>
            <button onClick={() => rollD(15)} className="px-3 py-1 bg-blue-500 text-white rounded">
              Roll d15
            </button>
            <button onClick={() => rollD(20)} className="px-3 py-1 bg-blue-500 text-white rounded">
              Roll d20
            </button>
          </div>
        </div>
      );
    }

    /* ---------------------------
       MapSection
       - Enhanced: Allows uploading an image, placing 4 colored dots (party + enemies), all draggable
    ---------------------------- */
    function MapSection({ mapImage, setMapImage, dotPositions, setDotPositions }) {
      const [isDragging, setIsDragging] = React.useState(null); // Track which dot is being dragged
      const containerRef = React.useRef(null);

      const handleImageUpload = (event) => {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            setMapImage(e.target.result);
            // Initialize 4 dots if not already set
            setDotPositions([
              { x: 25, y: 25, color: "red" },      // Party member 1
              { x: 75, y: 25, color: "blue" },     // Party member 2
              { x: 25, y: 75, color: "green" },    // Party member 3
              { x: 75, y: 75, color: "purple" },   // Enemies
            ]);
          };
          reader.readAsDataURL(file);
        }
      };

      const handleDeleteImage = () => {
        setMapImage(null);
        setDotPositions([]);
      };

      const handleMouseDown = (index) => (e) => {
        setIsDragging(index);
        moveDot(index, e);
      };

      const handleMouseMove = (e) => {
        if (isDragging !== null) {
          moveDot(isDragging, e);
        }
      };

      const handleMouseUp = () => {
        setIsDragging(null);
      };

      const moveDot = (index, e) => {
        if (containerRef.current && mapImage) {
          const rect = containerRef.current.getBoundingClientRect();
          const x = ((e.clientX - rect.left) / rect.width) * 100;
          const y = ((e.clientY - rect.top) / rect.height) * 100;
          setDotPositions((prev) =>
            prev.map((dot, i) =>
              i === index ? { ...dot, x: Math.max(0, Math.min(100, x)), y: Math.max(0, Math.min(100, y)) } : dot
            )
          );
        }
      };

      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">Party & Enemy Location Map</h2>
          {mapImage ? (
            <div className="relative">
              <div
                ref={containerRef}
                className="relative cursor-pointer"
                onMouseMove={handleMouseMove}
                onMouseUp={handleMouseUp}
                onMouseLeave={handleMouseUp}
              >
                <img src={mapImage} alt="Map" className="w-full" />
                {dotPositions.map((dot, index) => (
                  <div
                    key={index}
                    className={`absolute w-4 h-4 rounded-full`}
                    style={{
                      left: `${dot.x}%`,
                      top: `${dot.y}%`,
                      transform: "translate(-50%, -50%)",
                      backgroundColor: dot.color,
                      cursor: "grab",
                    }}
                    onMouseDown={handleMouseDown(index)}
                  ></div>
                ))}
              </div>
              <div className="mt-2">
                <p className="text-sm text-gray-700 mb-2">
                  Red: Party 1 | Blue: Party 2 | Green: Party 3 | Purple: Enemies
                </p>
                <div className="flex gap-2">
                  <input
                    type="file"
                    accept="image/*"
                    onChange={handleImageUpload}
                    className="border p-1 rounded"
                  />
                  <button
                    className="px-2 py-1 bg-red-500 text-white rounded"
                    onClick={handleDeleteImage}
                  >
                    Delete Map
                  </button>
                </div>
              </div>
            </div>
          ) : (
            <input
              type="file"
              accept="image/*"
              onChange={handleImageUpload}
              className="border p-1 rounded"
            />
          )}
        </div>
      );
    }

    /* ---------------------------
       PartyImages
       - Displays all character images dynamically
    ---------------------------- */
    function PartyImages({ characters }) {
      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">Party Member Images</h2>
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            {characters.map((char) => (
              <div key={char.id} className="text-center">
                {char.image ? (
                  <img
                    src={char.image}
                    alt={char.name}
                    className="w-24 h-24 object-cover rounded-full mx-auto"
                  />
                ) : (
                  <div className="w-24 h-24 bg-gray-300 rounded-full mx-auto flex items-center justify-center">
                    <span className="text-gray-500">No Image</span>
                  </div>
                )}
                <p className="mt-2">{char.name}</p>
              </div>
            ))}
          </div>
        </div>
      );
    }

    /* ---------------------------
       NEW: CopyButton
       - Copies character and enemy data to clipboard in text format
    ---------------------------- */
    function CopyButton({ characters, enemies }) {
      const handleCopy = () => {
        const text = [
          "### Characters",
          ...characters.map((char) => `
Character: ${char.name}
Class: ${char.class}
Health: ${char.health}/${char.maxHealth}
Status Conditions: ${char.status.length ? char.status.join(", ") : "None"}
Effects: ${char.effects.length ? char.effects.join(", ") : "None"}
Inventory: ${char.inventory.length ? char.inventory.join(", ") : "None"}
Special Abilities: ${char.specialAbilities.length ? char.specialAbilities.join(", ") : "None"}
Spells/Magic: ${char.spellsMagic.length ? char.spellsMagic.join(", ") : "None"}
Image: ${char.image ? "Uploaded" : "No Image"}
          `.trim()),
          "\n### Enemies",
          ...enemies.map((enemy) => `
Enemy: ${enemy.name}
Health: ${enemy.health}/${enemy.maxHealth}
          `.trim()),
        ].join("\n\n");

        navigator.clipboard.writeText(text).then(() => {
          alert("Character and enemy data copied to clipboard!");
        }).catch((err) => {
          console.error("Failed to copy text: ", err);
          alert("Failed to copy data. Check console for details.");
        });
      };

      return (
        <button
          className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 mb-4"
          onClick={handleCopy}
        >
          Copy for Prompt
        </button>
      );
    }

    /* ---------------------------
       ClassesSection
       - Updated: Lists D&D 5e classes with new descriptions and link to RPGBot
    ---------------------------- */
    function ClassesSection() {
      const classes = [
        { name: "Artificer (Tinkerers & Inventors)", desc: "Artificers thrive on intelligence, crafting, and magical engineering. Gnomes are natural inventors with minor illusions and magic resistance, while Autognomes are durable constructs with mechanical resilience. Vedalken excel in logic and mental resistance, and Warforged are living constructs immune to many conditions. Artificers specialize in infusions, magical tinkering, and intelligence-based spellcasting, making these races ideal for their class." },
        { name: "Barbarian (Unstoppable Warriors)", desc: "Barbarians rely on raw strength, endurance, and primal fury. Goliaths reduce incoming damage and excel in athletics, while Orcs gain extra movement and resilience in combat. Minotaurs are melee-focused chargers, and Half-Orcs can survive near-fatal blows while delivering devastating crits. Lizardfolk add natural armor and self-healing through bites. Barbarians excel in rage-fueled combat, unarmored defense, and brutal critical hits." },
        { name: "Bard (Charming Performers & Spellcasters)", desc: "Bards blend charisma, magic, and storytelling. Half-Elves gain extra skills and social flexibility, while Satyrs resist magic and enhance musical abilities. Fairies provide flight and innate spells, and Tabaxi have agility and charm, making them excellent performers. Kenku mimic sounds perfectly, ideal for deception and intrigue. Bards specialize in inspiring allies, versatile spellcasting, and performance-based magic." },
        { name: "Cleric (Divine Warriors & Healers)", desc: "Clerics channel divine magic for healing and battle. Aasimar have celestial energy and radiant resistance, while Dwarves provide durability and divine weapon proficiencies. Tritons control water and communicate with sea creatures, and Firbolgs possess nature magic and invisibility. Owlin offer wisdom-based spellcasting with natural flight. Clerics excel in divine magic, healing, and powerful protective spells." },
        { name: "Druid (Nature's Guardians & Shapeshifters)", desc: "Druids command nature and transform into beasts. Firbolgs excel with plant communication and stealth, while Tortles provide natural armor for defense. Lizardfolk have primal instincts and self-healing, and Shifters channel lycanthropic abilities. Wood Elves thrive in forests with heightened agility. Druids master wild shape, nature magic, and elemental control." },
        { name: "Fighter (Master Combatants & Strategists)", desc: "Fighters dominate the battlefield with weapons and tactics. Half-Orcs hit hard and endure, while Goliaths resist damage and excel in athletics. Hobgoblins enhance teamwork and tactical advantage, and Warforged provide durability with built-in armor. Leonin use powerful roars to intimidate foes. Fighters specialize in multiple attacks, weapon mastery, and versatile combat styles." },
        { name: "Monk (Masters of Martial Arts & Speed)", desc: "Monks rely on speed, agility, and spiritual focus. Tabaxi are nimble and fast, while Harengon have quick reflexes and high jumps. Kenku are stealthy and precise, and Githzerai have psionic defenses. Lizardfolk enhance their unarmed strikes with natural weapons. Monks excel in unarmed combat, mobility, and ki-powered abilities." },
        { name: "Paladin (Holy Warriors & Protectors)", desc: "Paladins wield divine magic alongside martial prowess. Aasimar gain celestial blessings and radiant abilities, while Dragonborn channel draconic power with elemental breath weapons. Dwarves bring durability and divine weapon skills, and Tritons harness oceanic magic. Leonin have natural authority and powerful combat presence. Paladins specialize in divine smites, healing, and protective auras." },
        { name: "Ranger (Wilderness Scouts & Hunters)", desc: "Rangers track, hunt, and wield nature magic. Wood Elves have superior stealth and speed, while Tabaxi move swiftly and excel in scouting. Goliaths are rugged survivalists with cold resistance, and Firbolgs use magic to blend into nature. Kenku thrive in ambush tactics. Rangers excel in tracking, ranged combat, and natural exploration." },
        { name: "Rogue (Stealthy Assassins & Tricksters)", desc: "Rogues rely on cunning, speed, and precision. Halflings avoid misfortune with their luck trait, while Tabaxi use agility and speed for quick getaways. Kobolds have pack tactics for deadly strikes, and Kenku mimic voices for deception. Goblin rogues use their nimbleness and quick escapes. Rogues specialize in sneak attacks, evasive movement, and deception." },
        { name: "Sorcerer (Innate Spellcasters & Magical Prodigies)", desc: "Sorcerers wield raw, untamed magic. Dragonborn inherit draconic power with elemental resistances, while Tieflings draw strength from infernal ancestry. Aasimar harness celestial energy, and Genasi wield elemental magic. Fairies bring flight and innate spellcasting. Sorcerers specialize in metamagic, spontaneous casting, and magical surges." },
        { name: "Warlock (Pact-Bound Spellcasters & Eldritch Wielders)", desc: "Warlocks make pacts with powerful entities for magic. Tieflings tap into fiendish energy, while Hexbloods have hag-like magic. Reborn warlocks possess undead resilience, and Githyanki wield psionic gifts. Drow Elves enhance darkness magic. Warlocks excel in eldritch invocations, powerful cantrips, and supernatural pacts." },
        { name: "Wizard (Scholars of Magic & Arcane Masters)", desc: "Wizards master magic through study and knowledge. Gnomes have magical resistance and keen intellect, while Elves bring heightened senses and arcane heritage. Hobgoblins store magical energy for later use, and Vedalken provide logic-based spellcasting. Warforged offer a unique take on magical constructs. Wizards specialize in ritual magic, vast spell knowledge, and arcane mastery." },
      ];

      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">D&D 5th Edition Classes</h2>
          <p className="mb-2">
            Source:{" "}
            <a
              href="https://rpgbot.net/dnd5/characters/classes/"
              target="_blank"
              rel="noreferrer"
              className="text-blue-500 hover:underline"
            >
              RPGBot Classes
            </a>
          </p>
          <ul className="list-disc list-inside space-y-2">
            {classes.map((cls) => (
              <li key={cls.name}>
                <span className="font-semibold">{cls.name}</span>: {cls.desc}
              </li>
            ))}
          </ul>
        </div>
      );
    }

    /* ---------------------------
       RacesSection
       - Lists D&D 5e races with descriptions and a link to RPGBot
    ---------------------------- */
    function RacesSection() {
      const races = [
        { name: "Aarakocra", desc: "Bird-like humanoids with the ability to fly and sharp talons, often living in high-altitude environments." },
        { name: "Aasimar", desc: "Celestial-touched beings with divine power, resistant to necrotic and radiant damage, and capable of radiant transformations." },
        { name: "Autognome", desc: "Small robotic beings from Spelljammer, resilient with built-in mechanical advantages." },
        { name: "Bugbear", desc: "Large goblinoid ambush predators with extended reach and powerful surprise attacks." },
        { name: "Centaur", desc: "Half-human, half-horse creatures with natural speed and melee combat prowess." },
        { name: "Changeling", desc: "Shapeshifters who can alter their appearance at will, making them excellent spies and social manipulators." },
        { name: "Custom Lineage", desc: "A flexible non-race option that allows custom origins, granting a feat and bonus abilities." },
        { name: "Dhampir", desc: "Half-vampires with supernatural abilities such as wall-climbing and life-draining bites." },
        { name: "Dragonborn", desc: "Draconic humanoids with breath weapons and elemental resistances based on their draconic ancestry." },
        { name: "Dwarf", desc: "Stocky, resilient warriors and craftsmen known for their endurance, resistance to poison, and expertise in mining." },
        { name: "Elf", desc: "Graceful, long-lived humanoids with various subraces offering magical abilities and keen perception." },
        { name: "Fairy", desc: "Tiny winged beings with natural flight and innate spellcasting abilities." },
        { name: "Firbolg", desc: "Gentle giant-kin with druidic abilities, including limited invisibility and plant communication." },
        { name: "Genasi", desc: "Elemental humanoids influenced by air, earth, fire, or water, each with unique traits and spell-like abilities." },
        { name: "Giff", desc: "Large, gun-wielding hippo-like humanoids from Spelljammer with strength-based combat prowess." },
        { name: "Gith", desc: "Psionic humanoids split into Githyanki (warriors and conquerors) and Githzerai (monks and mystics)." },
        { name: "Gnome", desc: "Small, inventive, and magically inclined humanoids with innate resistance to mind-affecting magic." },
        { name: "Goblin", desc: "Small, quick, and cunning humanoids with mobility-focused traits and the ability to disengage easily." },
        { name: "Goliath", desc: "Towering mountain-dwellers with natural endurance and damage-reducing abilities." },
        { name: "Hadozee", desc: "Gliding, monkey-like humanoids from Spelljammer with prehensile feet." },
        { name: "Half-Elf", desc: "A mix of humans and elves, gaining benefits from both, including adaptability and social skills." },
        { name: "Half-Orc", desc: "Fierce warriors with relentless endurance and the ability to deal devastating critical strikes." },
        { name: "Halfling", desc: "Small, lucky humanoids known for their nimbleness and ability to reroll natural 1s on d20 rolls." },
        { name: "Harengon", desc: "Rabbit-like humanoids with enhanced reflexes and exceptional mobility." },
        { name: "Hexblood", desc: "Individuals influenced by hags, gaining minor divination and disguise-based magic." },
        { name: "Hobgoblin", desc: "Military-minded goblinoids with teamwork-based abilities and martial discipline." },
        { name: "Human", desc: "Versatile and adaptable, with a variant option allowing for a feat at level 1." },
        { name: "Kalashtar", desc: "Psychic beings connected to the plane of dreams, resistant to psychic damage and skilled in telepathy." },
        { name: "Kender", desc: "Mischievous, fear-resistant humanoids from Krynn (Dragonlance) with a knack for acquiring random objects." },
        { name: "Kenku", desc: "Crow-like humanoids that can perfectly mimic sounds, making them excellent spies and thieves." },
        { name: "Kobold", desc: "Small draconic humanoids, often working in groups, with a variety of combat-focused abilities." },
        { name: "Leonin", desc: "Lion-like humanoids with powerful roars and natural combat prowess." },
        { name: "Lizardfolk", desc: "Cold-blooded reptilian humanoids with durable scales, natural weapons, and an ability to craft from slain foes." },
        { name: "Loxodon", desc: "Elephant-like humanoids with tough skin, a powerful trunk, and a calm, meditative nature." },
        { name: "Minotaur", desc: "Large, bull-headed warriors built for charging into battle with deadly efficiency." },
        { name: "Orc", desc: "Powerful and resilient warriors with a drive for battle and an ability to endure massive damage." },
        { name: "Owlin", desc: "Owl-like humanoids with natural flight and silent movement, making them great scouts." },
        { name: "Plasmoid", desc: "Ooze-like beings with amorphous bodies, able to squeeze through tight spaces and extend pseudopods." },
        { name: "Reborn", desc: "Undead or resurrected beings with fragmented memories and resistance to disease and poison." },
        { name: "Satyr", desc: "Goat-like humanoids with magical resistance and an affinity for revelry and adventure." },
        { name: "Shifter", desc: "Werebeast-like humanoids that can temporarily transform into more animalistic forms." },
        { name: "Simic Hybrid", desc: "Magically altered humanoids with animal-like features and customizable traits." },
        { name: "Tabaxi", desc: "Cat-like humanoids with keen senses, exceptional speed, and curiosity-driven instincts." },
        { name: "Thri-Kreen", desc: "Four-armed, mantis-like humanoids with natural armor and telepathic communication." },
        { name: "Tiefling", desc: "Fiend-touched humanoids with infernal resistances, innate magic, and an affinity for dark powers." },
        { name: "Tortle", desc: "Turtle-like humanoids with natural armor and a laid-back but sturdy nature." },
        { name: "Triton", desc: "Amphibious ocean-dwellers with command over sea creatures and innate water-based magic." },
        { name: "Vedalken", desc: "Intellectual, blue-skinned humanoids with heightened mental resistance and a focus on logic." },
        { name: "Verdan", desc: "Green-skinned, magically mutating humanoids that change in size as they age." },
        { name: "Warforged", desc: "Living constructs built for durability and adaptability, making them excellent warriors or spellcasters." },
        { name: "Yuan-Ti", desc: "Snake-like humanoids with resistance to poison and magic, often linked to dark deities." },
      ];

      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">D&D 5th Edition Races</h2>
          <p className="mb-2">
            Source:{" "}
            <a
              href="https://rpgbot.net/dnd5/characters/races/"
              target="_blank"
              rel="noreferrer"
              className="text-blue-500 hover:underline"
            >
              RPGBot Races
            </a>
          </p>
          <ul className="list-disc list-inside space-y-1">
            {races.map((race) => (
              <li key={race.name}>
                <span className="font-semibold">{race.name}</span>: {race.desc}
              </li>
            ))}
          </ul>
        </div>
      );
    }

    /* ---------------------------
       MonsterCreatureList
       - Links to monster database for easy reference
    ---------------------------- */
    function MonsterCreatureList() {
      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">Monster/Creature List</h2>
          <p className="mb-2">
            Access a comprehensive database of D&D monsters and creatures at:
          </p>
          <a
            href="https://www.aidedd.org/dnd-filters/monsters.php"
            target="_blank"
            rel="noreferrer"
            className="text-blue-500 hover:underline"
          >
            AIDEDD Monster Database
          </a>
          <p className="mt-2 text-sm text-gray-700">
            Use this resource to find detailed stats and information for monsters in your campaign.
          </p>
        </div>
      );
    }

    /* ---------------------------
       InitiativeTracker Component
       - Manages combat order
    ---------------------------- */
    function InitiativeTracker() {
      const [initiativeList, setInitiativeList] = React.useState(() => {
        const saved = localStorage.getItem("initiativeList");
        return saved ? JSON.parse(saved) : [];
      });
      const [newName, setNewName] = React.useState("");
      const [newInit, setNewInit] = React.useState("");
      const [isActive, setIsActive] = React.useState(() => {
        return localStorage.getItem("initiativeActive") === "true";
      });
      const [currentTurn, setCurrentTurn] = React.useState(() => {
        return parseInt(localStorage.getItem("currentInitiativeTurn") || "0");
      });
      const [round, setRound] = React.useState(() => {
        return parseInt(localStorage.getItem("initiativeRound") || "1");
      });

      React.useEffect(() => {
        localStorage.setItem("initiativeList", JSON.stringify(initiativeList));
      }, [initiativeList]);

      React.useEffect(() => {
        localStorage.setItem("initiativeActive", isActive.toString());
      }, [isActive]);

      React.useEffect(() => {
        localStorage.setItem("currentInitiativeTurn", currentTurn.toString());
      }, [currentTurn]);

      React.useEffect(() => {
        localStorage.setItem("initiativeRound", round.toString());
      }, [round]);

      function addEntity() {
        if (!newName.trim()) return;
        const initValue = parseInt(newInit) || 0;
        const newEntity = {
          id: Date.now(),
          name: newName.trim(),
          initiative: initValue,
          isPlayer: false, // Default to NPC
          hasGoneThisRound: false,
          conditions: []
        };

        setInitiativeList(prev => {
          const updated = [...prev, newEntity].sort((a, b) => b.initiative - a.initiative);
          return updated;
        });
        setNewName("");
        setNewInit("");
      }

      function removeEntity(id) {
        setInitiativeList(prev => prev.filter(e => e.id !== id));
        if (currentTurn >= initiativeList.length - 1) {
          setCurrentTurn(0);
        }
      }

      function nextTurn() {
        if (initiativeList.length === 0) return;
        
        let nextTurnIndex = (currentTurn + 1) % initiativeList.length;
        
        // If we've looped back to the start, increment the round
        if (nextTurnIndex === 0) {
          setRound(prev => prev + 1);
          // Reset all hasGoneThisRound flags
          setInitiativeList(prev => 
            prev.map(entity => ({ ...entity, hasGoneThisRound: false }))
          );
        }
        
        // Mark the current entity as having gone this round
        setInitiativeList(prev => 
          prev.map((entity, idx) => 
            idx === currentTurn 
              ? { ...entity, hasGoneThisRound: true } 
              : entity
          )
        );
        
        setCurrentTurn(nextTurnIndex);
      }

      function startCombat() {
        if (initiativeList.length === 0) return;
        setIsActive(true);
        setCurrentTurn(0);
        setRound(1);
        setInitiativeList(prev => 
          prev.map(entity => ({ ...entity, hasGoneThisRound: false }))
        );
      }

      function endCombat() {
        setIsActive(false);
        // Clear any combat-specific conditions
        setInitiativeList(prev => 
          prev.map(entity => ({
            ...entity,
            hasGoneThisRound: false,
            conditions: entity.conditions.filter(c => !c.isCombatOnly)
          }))
        );
      }

      function togglePlayerStatus(id) {
        setInitiativeList(prev => 
          prev.map(entity => 
            entity.id === id 
              ? { ...entity, isPlayer: !entity.isPlayer } 
              : entity
          )
        );
      }

      function addCondition(entityId, condition, duration) {
        setInitiativeList(prev => 
          prev.map(entity => {
            if (entity.id === entityId) {
              return {
                ...entity,
                conditions: [
                  ...entity.conditions,
                  {
                    name: condition,
                    duration: parseInt(duration) || 0,
                    isCombatOnly: true
                  }
                ]
              };
            }
            return entity;
          })
        );
      }

      function removeCondition(entityId, conditionIndex) {
        setInitiativeList(prev => 
          prev.map(entity => {
            if (entity.id === entityId) {
              const updatedConditions = [...entity.conditions];
              updatedConditions.splice(conditionIndex, 1);
              return {
                ...entity,
                conditions: updatedConditions
              };
            }
            return entity;
          })
        );
      }

      function sortInitiative() {
        setInitiativeList(prev => [...prev].sort((a, b) => b.initiative - a.initiative));
      }

      const currentEntity = initiativeList[currentTurn];

      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">Initiative Tracker</h2>
          
          {/* Add Entity Form */}
          <div className="flex gap-2 mb-4">
            <input
              className="border p-2 rounded flex-grow"
              placeholder="Character/Enemy Name"
              value={newName}
              onChange={e => setNewName(e.target.value)}
            />
            <input
              className="border p-2 rounded w-20"
              placeholder="Init"
              type="number"
              value={newInit}
              onChange={e => setNewInit(e.target.value)}
            />
            <button 
              className="px-3 py-1 bg-green-500 text-white rounded"
              onClick={addEntity}
            >
              Add
            </button>
            <button 
              className="px-3 py-1 bg-blue-500 text-white rounded"
              onClick={sortInitiative}
            >
              Sort
            </button>
          </div>
          
          {/* Combat Controls */}
          <div className="flex gap-2 mb-4">
            {!isActive ? (
              <button 
                className="px-3 py-1 bg-red-500 text-white rounded"
                onClick={startCombat}
                disabled={initiativeList.length === 0}
              >
                Start Combat
              </button>
            ) : (
              <>
                <button 
                  className="px-3 py-1 bg-blue-500 text-white rounded"
                  onClick={nextTurn}
                >
                  Next Turn
                </button>
                <button 
                  className="px-3 py-1 bg-gray-500 text-white rounded"
                  onClick={endCombat}
                >
                  End Combat
                </button>
                <span className="ml-2 flex items-center">
                  Round: {round} | 
                  Current Turn: {currentEntity?.name || "None"}
                </span>
              </>
            )}
          </div>
          
          {/* Initiative List */}
          <div className="space-y-2">
            {initiativeList.map((entity, index) => (
              <div 
                key={entity.id} 
                className={`p-2 rounded flex items-center gap-2 ${
                  isActive && index === currentTurn 
                    ? "bg-yellow-100 border-2 border-yellow-500" 
                    : "bg-white"
                } ${entity.hasGoneThisRound ? "opacity-60" : ""}`}
              >
                <span className="font-bold w-8 text-center">
                  {entity.initiative}
                </span>
                <span className={`flex-grow ${entity.isPlayer ? "text-blue-600 font-semibold" : "text-red-600"}`}>
                  {entity.name}
                </span>
                
                {/* Conditions */}
                <div className="flex gap-1">
                  {entity.conditions.map((condition, condIdx) => (
                    <span 
                      key={condIdx}
                      className="px-2 py-1 text-xs bg-purple-100 text-purple-800 rounded-full flex items-center gap-1"
                    >
                      {condition.name}
                      {condition.duration > 0 && <span>({condition.duration})</span>}
                      <button
                        className="hover:text-red-500 ml-1"
                        onClick={() => removeCondition(entity.id, condIdx)}
                      >
                        ×
                      </button>
                    </span>
                  ))}
                </div>
                
                <button
                  className={`px-2 py-1 text-xs ${entity.isPlayer ? "bg-red-100 text-red-800" : "bg-blue-100 text-blue-800"} rounded`}
                  onClick={() => togglePlayerStatus(entity.id)}
                >
                  {entity.isPlayer ? "PC" : "NPC"}
                </button>
                
                <button
                  className="px-2 py-1 text-xs bg-red-500 text-white rounded"
                  onClick={() => removeEntity(entity.id)}
                >
                  Remove
                </button>
              </div>
            ))}
            
            {initiativeList.length === 0 && (
              <div className="text-center p-4 text-gray-500">
                Add characters and enemies to track initiative
              </div>
            )}
          </div>
        </div>
      );
    }

    /* ---------------------------
       SpellTracker Component
       - Tracks spell slots and prepared spells
    ---------------------------- */
    function SpellTracker({ characters, onUpdateChar }) {
      const [activeCharId, setActiveCharId] = React.useState(null);
      const [spellSlots, setSpellSlots] = React.useState(() => {
        const saved = localStorage.getItem("spellSlots");
        return saved ? JSON.parse(saved) : {};
      });
      const [newSpell, setNewSpell] = React.useState({ name: "", level: 1, prepared: false });

      // Get the active character
      const activeChar = characters.find(c => c.id === activeCharId);

      React.useEffect(() => {
        localStorage.setItem("spellSlots", JSON.stringify(spellSlots));
      }, [spellSlots]);

      // Initialize new character spell slots
      React.useEffect(() => {
        const missingChars = characters.filter(c => !spellSlots[c.id]);
        
        if (missingChars.length > 0) {
          const updates = {};
          
          missingChars.forEach(char => {
            updates[char.id] = {
              maxSlots: [0, 4, 3, 2, 0, 0, 0, 0, 0, 0], // Default for a level 3 caster
              currentSlots: [0, 4, 3, 2, 0, 0, 0, 0, 0, 0],
              cantrips: [],
              knownSpells: []
            };
          });
          
          setSpellSlots(prev => ({
            ...prev,
            ...updates
          }));
        }
      }, [characters, spellSlots]);

      function handleCharSelect(charId) {
        setActiveCharId(charId);
      }

      function updateMaxSlots(level, value) {
        if (!activeCharId) return;
        
        const newValue = Math.max(0, parseInt(value) || 0);
        
        setSpellSlots(prev => {
          const charSlots = {...prev[activeCharId]};
          charSlots.maxSlots[level] = newValue;
          charSlots.currentSlots[level] = Math.min(charSlots.currentSlots[level], newValue);
          
          return {
            ...prev,
            [activeCharId]: charSlots
          };
        });
      }

      function updateCurrentSlots(level, value) {
        if (!activeCharId) return;
        
        const newValue = Math.max(0, parseInt(value) || 0);
        const maxForLevel = spellSlots[activeCharId].maxSlots[level];
        
        setSpellSlots(prev => {
          const charSlots = {...prev[activeCharId]};
          charSlots.currentSlots[level] = Math.min(newValue, maxForLevel);
          
          return {
            ...prev,
            [activeCharId]: charSlots
          };
        });
      }

      function castSpell(level) {
        if (!activeCharId) return;
        
        setSpellSlots(prev => {
          const charSlots = {...prev[activeCharId]};
          if (charSlots.currentSlots[level] > 0) {
            charSlots.currentSlots[level]--;
          }
          
          return {
            ...prev,
            [activeCharId]: charSlots
          };
        });
      }

      function restoreSlot(level) {
        if (!activeCharId) return;
        
        setSpellSlots(prev => {
          const charSlots = {...prev[activeCharId]};
          if (charSlots.currentSlots[level] < charSlots.maxSlots[level]) {
            charSlots.currentSlots[level]++;
          }
          
          return {
            ...prev,
            [activeCharId]: charSlots
          };
        });
      }

      function shortRest() {
        // Short rest doesn't restore spell slots in standard 5e rules
        // but could be used for class features that recharge on short rest
        // like a Warlock's spell slots
        if (!activeCharId) return;
        
        setSpellSlots(prev => {
          const charSlots = {...prev[activeCharId]};
          
          // For Warlocks (just an example)
          if (activeChar && activeChar.class.toLowerCase().includes("warlock")) {
            charSlots.currentSlots = [...charSlots.maxSlots];
          }
          
          return {
            ...prev,
            [activeCharId]: charSlots
          };
        });
      }

      function longRest() {
        if (!activeCharId) return;
        
        setSpellSlots(prev => {
          const charSlots = {...prev[activeCharId]};
          charSlots.currentSlots = [...charSlots.maxSlots];
          
          return {
            ...prev,
            [activeCharId]: charSlots
          };
        });
      }

      function addSpell() {
        if (!activeCharId || !newSpell.name.trim()) return;
        
        if (newSpell.level === 0) {
          // Add cantrip
          setSpellSlots(prev => {
            const charSlots = {...prev[activeCharId]};
            charSlots.cantrips = [...charSlots.cantrips, newSpell.name.trim()];
            
            return {
              ...prev,
              [activeCharId]: charSlots
            };
          });
        } else {
          // Add leveled spell
          setSpellSlots(prev => {
            const charSlots = {...prev[activeCharId]};
            charSlots.knownSpells = [
              ...charSlots.knownSpells, 
              {
                name: newSpell.name.trim(),
                level: newSpell.level,
                prepared: newSpell.prepared
              }
            ];
            
            return {
              ...prev,
              [activeCharId]: charSlots
            };
          });
        }
        
        setNewSpell({ name: "", level: 1, prepared: false });
      }

      function removeSpell(type, index) {
        if (!activeCharId) return;
        
        setSpellSlots(prev => {
          const charSlots = {...prev[activeCharId]};
          
          if (type === 'cantrip') {
            charSlots.cantrips = charSlots.cantrips.filter((_, i) => i !== index);
          } else if (type === 'spell') {
            charSlots.knownSpells = charSlots.knownSpells.filter((_, i) => i !== index);
          }
          
          return {
            ...prev,
            [activeCharId]: charSlots
          };
        });
      }

      function togglePrepared(index) {
        if (!activeCharId) return;
        
        setSpellSlots(prev => {
          const charSlots = {...prev[activeCharId]};
          charSlots.knownSpells = charSlots.knownSpells.map((spell, i) => 
            i === index ? { ...spell, prepared: !spell.prepared } : spell
          );
          
          return {
            ...prev,
            [activeCharId]: charSlots
          };
        });
      }

      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">Spell Tracker</h2>
          
          {/* Character Selection */}
          <div className="mb-4">
            <label className="block mb-2">Select Character:</label>
            <div className="flex flex-wrap gap-2">
              {characters.map(char => (
                <button
                  key={char.id}
                  className={`px-3 py-1 rounded ${
                    activeCharId === char.id 
                      ? "bg-blue-500 text-white" 
                      : "bg-gray-200"
                  }`}
                  onClick={() => handleCharSelect(char.id)}
                >
                  {char.name}
                </button>
              ))}
            </div>
          </div>
          
          {activeCharId && (
            <>
              {/* Spell Slots */}
              <div className="mb-4">
                <h3 className="font-bold mb-2">Spell Slots</h3>
                <div className="grid grid-cols-5 gap-2">
                  {[1, 2, 3, 4, 5, 6, 7, 8, 9].map(level => (
                    <div key={level} className="bg-white p-2 rounded shadow">
                      <div className="font-semibold text-center mb-1">Level {level}</div>
                      <div className="flex justify-between items-center mb-1">
                        <span>Max:</span>
                        <input
                          type="number"
                          min="0"
                          className="border rounded w-12 p-1 text-center"
                          value={spellSlots[activeCharId].maxSlots[level]}
                          onChange={e => updateMaxSlots(level, e.target.value)}
                        />
                      </div>
                      <div className="flex justify-between items-center mb-1">
                        <span>Current:</span>
                        <input
                          type="number"
                          min="0"
                          className="border rounded w-12 p-1 text-center"
                          value={spellSlots[activeCharId].currentSlots[level]}
                          onChange={e => updateCurrentSlots(level, e.target.value)}
                        />
                      </div>
                      <div className="flex justify-between gap-1 mt-2">
                        <button
                          className="px-2 py-1 bg-red-500 text-white rounded text-xs flex-grow"
                          onClick={() => castSpell(level)}
                          disabled={spellSlots[activeCharId].currentSlots[level] <= 0}
                        >
                          Cast
                        </button>
                        <button
                          className="px-2 py-1 bg-green-500 text-white rounded text-xs flex-grow"
                          onClick={() => restoreSlot(level)}
                          disabled={spellSlots[activeCharId].currentSlots[level] >= spellSlots[activeCharId].maxSlots[level]}
                        >
                          Restore
                        </button>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
              
              {/* Rest Buttons */}
              <div className="flex gap-2 mb-4">
                <button
                  className="px-3 py-1 bg-blue-500 text-white rounded"
                  onClick={shortRest}
                >
                  Short Rest
                </button>
                <button
                  className="px-3 py-1 bg-purple-500 text-white rounded"
                  onClick={longRest}
                >
                  Long Rest
                </button>
              </div>
              
              {/* Add Spell */}
              <div className="mb-4">
                <h3 className="font-bold mb-2">Add Spell</h3>
                <div className="flex gap-2 items-end">
                  <div className="flex-grow">
                    <label className="block mb-1 text-sm">Spell Name:</label>
                    <input
                      className="border rounded p-1 w-full"
                      value={newSpell.name}
                      onChange={e => setNewSpell({...newSpell, name: e.target.value})}
                      placeholder="Spell Name"
                    />
                  </div>
                  <div>
                    <label className="block mb-1 text-sm">Level:</label>
                    <select
                      className="border rounded p-1"
                      value={newSpell.level}
                      onChange={e => setNewSpell({...newSpell, level: parseInt(e.target.value)})}
                    >
                      <option value={0}>Cantrip</option>
                      <option value={1}>1st</option>
                      <option value={2}>2nd</option>
                      <option value={3}>3rd</option>
                      <option value={4}>4th</option>
                      <option value={5}>5th</option>
                      <option value={6}>6th</option>
                      <option value={7}>7th</option>
                      <option value={8}>8th</option>
                      <option value={9}>9th</option>
                    </select>
                  </div>
                  {newSpell.level > 0 && (
                    <div className="flex items-center">
                      <input
                        type="checkbox"
                        id="preparedSpell"
                        checked={newSpell.prepared}
                        onChange={e => setNewSpell({...newSpell, prepared: e.target.checked})}
                        className="mr-1"
                      />
                      <label htmlFor="preparedSpell" className="text-sm">Prepared</label>
                    </div>
                  )}
                  <button
                    className="px-3 py-1 bg-green-500 text-white rounded"
                    onClick={addSpell}
                  >
                    Add
                  </button>
                </div>
              </div>
              
              {/* Spell Lists */}
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {/* Cantrips */}
                <div>
                  <h3 className="font-bold mb-2">Cantrips</h3>
                  <div className="bg-white p-2 rounded shadow">
                    {spellSlots[activeCharId].cantrips.length > 0 ? (
                      <ul className="space-y-1">
                        {spellSlots[activeCharId].cantrips.map((cantrip, idx) => (
                          <li key={idx} className="flex justify-between items-center">
                            <span>{cantrip}</span>
                            <button
                              className="text-red-500"
                              onClick={() => removeSpell('cantrip', idx)}
                            >
                              Remove
                            </button>
                          </li>
                        ))}
                      </ul>
                    ) : (
                      <p className="text-gray-500 text-center">No cantrips added yet</p>
                    )}
                  </div>
                </div>
                
                {/* Known/Prepared Spells */}
                <div>
                  <h3 className="font-bold mb-2">Spells</h3>
                  <div className="bg-white p-2 rounded shadow">
                    {spellSlots[activeCharId].knownSpells.length > 0 ? (
                      <div className="space-y-2">
                        {[1, 2, 3, 4, 5, 6, 7, 8, 9].map(level => {
                          const levelSpells = spellSlots[activeCharId].knownSpells.filter(
                            spell => spell.level === level
                          );
                          
                          if (levelSpells.length === 0) return null;
                          
                          return (
                            <div key={level}>
                              <h4 className="font-semibold">Level {level}</h4>
                              <ul className="pl-2 space-y-1">
                                {levelSpells.map((spell, idx) => {
                                  const globalIdx = spellSlots[activeCharId].knownSpells.findIndex(
                                    s => s.name === spell.name && s.level === spell.level
                                  );
                                  
                                  return (
                                    <li key={idx} className="flex justify-between items-center">
                                      <div className="flex items-center">
                                        <input
                                          type="checkbox"
                                          checked={spell.prepared}
                                          onChange={() => togglePrepared(globalIdx)}
                                          className="mr-2"
                                        />
                                        <span className={spell.prepared ? "font-semibold" : ""}>
                                          {spell.name}
                                        </span>
                                      </div>
                                      <button
                                        className="text-red-500"
                                        onClick={() => removeSpell('spell', globalIdx)}
                                      >
                                        Remove
                                      </button>
                                    </li>
                                  );
                                })}
                              </ul>
                            </div>
                          );
                        })}
                      </div>
                    ) : (
                      <p className="text-gray-500 text-center">No spells added yet</p>
                    )}
                  </div>
                </div>
              </div>
            </>
          )}
          
          {!activeCharId && (
            <div className="text-center p-4 text-gray-500">
              Select a character to manage spells
            </div>
          )}
        </div>
      );
    }

    /* ---------------------------
       RestTracker Component 
       - Manages short and long rests
    ---------------------------- */
    function RestTracker({ characters, onHeal }) {
      const [restLog, setRestLog] = React.useState(() => {
        const saved = localStorage.getItem("restLog");
        return saved ? JSON.parse(saved) : [];
      });
      
      const [hitDiceUsed, setHitDiceUsed] = React.useState(() => {
        const saved = localStorage.getItem("hitDiceUsed");
        return saved ? JSON.parse(saved) : {};
      });
      
      React.useEffect(() => {
        localStorage.setItem("restLog", JSON.stringify(restLog));
      }, [restLog]);
      
      React.useEffect(() => {
        localStorage.setItem("hitDiceUsed", JSON.stringify(hitDiceUsed));
      }, [hitDiceUsed]);
      
      // Initialize hit dice for new characters
      React.useEffect(() => {
        const updates = {};
        let hasUpdates = false;
        
        characters.forEach(char => {
          if (!hitDiceUsed[char.id]) {
            updates[char.id] = {
              maxHitDice: 3, // Default level 3
              currentHitDice: 3,
              hitDiceType: 8, // Default d8
              conModifier: 1  // Default +1
            };
            hasUpdates = true;
          }
        });
        
        if (hasUpdates) {
          setHitDiceUsed(prev => ({
            ...prev,
            ...updates
          }));
        }
      }, [characters, hitDiceUsed]);
      
      function getClassHitDie(charClass) {
        const lowerClass = charClass.toLowerCase();
        if (lowerClass.includes("barbarian")) return 12;
        if (lowerClass.includes("fighter") || lowerClass.includes("paladin") || lowerClass.includes("ranger")) return 10;
        if (lowerClass.includes("wizard") || lowerClass.includes("sorcerer")) return 6;
        return 8; // Default (cleric, bard, druid, monk, rogue, warlock)
      }
      
      function updateHitDiceMax(charId, value) {
        const newValue = Math.max(1, parseInt(value) || 1);
        
        setHitDiceUsed(prev => ({
          ...prev,
          [charId]: {
            ...prev[charId],
            maxHitDice: newValue,
            currentHitDice: Math.min(prev[charId].currentHitDice, newValue)
          }
        }));
      }
      
      function updateHitDiceCurrent(charId, value) {
        const newValue = Math.max(0, parseInt(value) || 0);
        const maxValue = hitDiceUsed[charId].maxHitDice;
        
        setHitDiceUsed(prev => ({
          ...prev,
          [charId]: {
            ...prev[charId],
            currentHitDice: Math.min(newValue, maxValue)
          }
        }));
      }
      
      function updateHitDiceType(charId, value) {
        setHitDiceUsed(prev => ({
          ...prev,
          [charId]: {
            ...prev[charId],
            hitDiceType: parseInt(value)
          }
        }));
      }
      
      function updateConModifier(charId, value) {
        setHitDiceUsed(prev => ({
          ...prev,
          [charId]: {
            ...prev[charId],
            conModifier: parseInt(value) || 0
          }
        }));
      }
      
      function rollHitDice(charId) {
        // Check if character has hit dice available
        if (!hitDiceUsed[charId] || hitDiceUsed[charId].currentHitDice <= 0) return;
        
        const char = characters.find(c => c.id === charId);
        if (!char) return;
        
        const diceType = hitDiceUsed[charId].hitDiceType;
        const conMod = hitDiceUsed[charId].conModifier;
        
        // Roll the die
        const roll = Math.floor(Math.random() * diceType) + 1;
        const total = Math.max(1, roll + conMod);
        
        // Heal the character
        onHeal(charId, total);
        
        // Reduce available hit dice
        setHitDiceUsed(prev => ({
          ...prev,
          [charId]: {
            ...prev[charId],
            currentHitDice: prev[charId].currentHitDice - 1
          }
        }));
        
        // Log the rest
        setRestLog(prev => [
          {
            timestamp: new Date().toISOString(),
            type: "hitDice",
            character: char.name,
            roll: roll,
            modifier: conMod,
            total: total
          },
          ...prev
        ]);
      }
      
      function takeShortRest() {
        const timestamp = new Date().toISOString();
        
        setRestLog(prev => [
          {
            timestamp,
            type: "shortRest",
            message: "The party took a short rest"
          },
          ...prev
        ]);
      }
      
      function takeLongRest() {
        const timestamp = new Date().toISOString();
        
        // Fully heal all characters
        characters.forEach(char => {
          onHeal(char.id, char.maxHealth);
        });
        
        // Restore hit dice (up to half of max)
        setHitDiceUsed(prev => {
          const updated = {...prev};
          
          Object.keys(updated).forEach(charId => {
            const missing = updated[charId].maxHitDice - updated[charId].currentHitDice;
            const restore = Math.min(missing, Math.floor(updated[charId].maxHitDice / 2));
            updated[charId].currentHitDice += restore;
          });
          
          return updated;
        });
        
        // Log the rest
        setRestLog(prev => [
          {
            timestamp,
            type: "longRest",
            message: "The party took a long rest. All hit points restored and half hit dice recovered."
          },
          ...prev
        ]);
      }
      
      function clearLog() {
        if (confirm("Are you sure you want to clear the rest log?")) {
          setRestLog([]);
        }
      }
      
      function formatDate(timestamp) {
        const date = new Date(timestamp);
        return date.toLocaleString();
      }
      
      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">Rest & Recovery</h2>
          
          {/* Rest Buttons */}
          <div className="flex gap-2 mb-4">
            <button
              className="px-3 py-1 bg-blue-500 text-white rounded"
              onClick={takeShortRest}
            >
              Take Short Rest
            </button>
            <button
              className="px-3 py-1 bg-purple-500 text-white rounded"
              onClick={takeLongRest}
            >
              Take Long Rest
            </button>
          </div>
          
          {/* Hit Dice Section */}
          <div className="mb-4">
            <h3 className="font-bold mb-2">Hit Dice</h3>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              {characters.map(char => (
                <div key={char.id} className="bg-white p-3 rounded shadow">
                  <h4 className="font-semibold">{char.name}</h4>
                  <div className="grid grid-cols-2 gap-2 mt-2">
                    <div>
                      <label className="block text-sm">Max Hit Dice:</label>
                      <input
                        type="number"
                        min="1"
                        className="border rounded p-1 w-full"
                        value={hitDiceUsed[char.id]?.maxHitDice || 1}
                        onChange={e => updateHitDiceMax(char.id, e.target.value)}
                      />
                    </div>
                    <div>
                      <label className="block text-sm">Current Hit Dice:</label>
                      <input
                        type="number"
                        min="0"
                        className="border rounded p-1 w-full"
                        value={hitDiceUsed[char.id]?.currentHitDice || 0}
                        onChange={e => updateHitDiceCurrent(char.id, e.target.value)}
                      />
                    </div>
                    <div>
                      <label className="block text-sm">Hit Die Type:</label>
                      <select
                        className="border rounded p-1 w-full"
                        value={hitDiceUsed[char.id]?.hitDiceType || getClassHitDie(char.class)}
                        onChange={e => updateHitDiceType(char.id, e.target.value)}>
                        <option value="6">d6</option>
                        <option value="8">d8</option>
                        <option value="10">d10</option>
                        <option value="12">d12</option>
                      </select>
                    </div>
                    <div>
                      <label className="block text-sm">CON Modifier:</label>
                      <input
                        type="number"
                        className="border rounded p-1 w-full"
                        value={hitDiceUsed[char.id]?.conModifier ?? 0}
                        onChange={e => updateConModifier(char.id, e.target.value)}
                      />
                    </div>
                  </div>
                  <button
                    className="w-full px-3 py-1 bg-green-500 text-white rounded mt-2"
                    onClick={() => rollHitDice(char.id)}
                    disabled={!hitDiceUsed[char.id] || hitDiceUsed[char.id].currentHitDice <= 0}
                  >
                    Roll Hit Die
                  </button>
                </div>
              ))}
            </div>
          </div>
          
          {/* Rest Log */}
          <div>
            <div className="flex justify-between items-center mb-2">
              <h3 className="font-bold">Rest Log</h3>
              {restLog.length > 0 && (
                <button
                  className="px-2 py-1 bg-red-500 text-white rounded text-sm"
                  onClick={clearLog}
                >
                  Clear Log
                </button>
              )}
            </div>
            <div className="bg-white p-3 rounded shadow max-h-60 overflow-y-auto">
              {restLog.length > 0 ? (
                <ul className="space-y-2">
                  {restLog.map((entry, idx) => (
                    <li key={idx} className="border-b pb-1">
                      <div className="text-xs text-gray-500">{formatDate(entry.timestamp)}</div>
                      {entry.type === "shortRest" && (
                        <div>{entry.message}</div>
                      )}
                      {entry.type === "longRest" && (
                        <div className="text-purple-600">{entry.message}</div>
                      )}
                      {entry.type === "hitDice" && (
                        <div>
                          <span className="font-semibold">{entry.character}</span> rolled a{" "}
                          <span className="text-blue-600">{entry.roll}</span> on their hit die{" "}
                          {entry.modifier !== 0 && (
                            <span>
                              with a modifier of{" "}
                              <span className="text-green-600">{entry.modifier > 0 ? "+" : ""}{entry.modifier}</span>
                            </span>
                          )}
                          , recovering{" "}
                          <span className="text-red-600">{entry.total} HP</span>.
                        </div>
                      )}
                    </li>
                  ))}
                </ul>
              ) : (
                <p className="text-center text-gray-500 p-4">No rest activity logged yet</p>
              )}
            </div>
          </div>
        </div>
      );
    }

    /* ---------------------------
       ConditionReference Component
       - Quick reference for all conditions in 5e
    ---------------------------- */
    function ConditionReference() {
      const [expanded, setExpanded] = React.useState(false);
      
      const conditions = [
        {
          name: "Blinded",
          description: "• A blinded creature can't see and automatically fails any ability check that requires sight.\n• Attack rolls against the creature have advantage, and the creature's attack rolls have disadvantage."
        },
        {
          name: "Charmed",
          description: "• A charmed creature can't attack the charmer or target the charmer with harmful abilities or magical effects.\n• The charmer has advantage on any ability check to interact socially with the creature."
        },
        {
          name: "Deafened",
          description: "• A deafened creature can't hear and automatically fails any ability check that requires hearing."
        },
        {
          name: "Frightened",
          description: "• A frightened creature has disadvantage on ability checks and attack rolls while the source of its fear is within line of sight.\n• The creature can't willingly move closer to the source of its fear."
        },
        {
          name: "Grappled",
          description: "• A grappled creature's speed becomes 0, and it can't benefit from any bonus to its speed.\n• The condition ends if the grappler is incapacitated.\n• The condition also ends if an effect removes the grappled creature from the reach of the grappler or grappling effect."
        },
        {
          name: "Incapacitated",
          description: "• An incapacitated creature can't take actions or reactions."
        },
        {
          name: "Invisible",
          description: "• An invisible creature is impossible to see without the aid of magic or a special sense. For the purpose of hiding, the creature is heavily obscured. The creature's location can be detected by any noise it makes or any tracks it leaves.\n• Attack rolls against the creature have disadvantage, and the creature's attack rolls have advantage."
        },
        {
          name: "Paralyzed",
          description: "• A paralyzed creature is incapacitated and can't move or speak.\n• The creature automatically fails Strength and Dexterity saving throws.\n• Attack rolls against the creature have advantage.\n• Any attack that hits the creature is a critical hit if the attacker is within 5 feet of the creature."
        },
        {
          name: "Petrified",
          description: "• A petrified creature is transformed, along with any nonmagical object it is wearing or carrying, into a solid inanimate substance (usually stone). Its weight increases by a factor of ten, and it ceases aging.\n• The creature is incapacitated, can't move or speak, and is unaware of its surroundings.\n• Attack rolls against the creature have advantage.\n• The creature automatically fails Strength and Dexterity saving throws.\n• The creature has resistance to all damage.\n• The creature is immune to poison and disease, although a poison or disease already in its system is suspended, not neutralized."
        },
        {
          name: "Poisoned",
          description: "• A poisoned creature has disadvantage on attack rolls and ability checks."
        },
        {
          name: "Prone",
          description: "• A prone creature's only movement option is to crawl, unless it stands up and thereby ends the condition.\n• The creature has disadvantage on attack rolls.\n• An attack roll against the creature has advantage if the attacker is within 5 feet of the creature. Otherwise, the attack roll has disadvantage."
        },
        {
          name: "Restrained",
          description: "• A restrained creature's speed becomes 0, and it can't benefit from any bonus to its speed.\n• Attack rolls against the creature have advantage, and the creature's attack rolls have disadvantage.\n• The creature has disadvantage on Dexterity saving throws."
        },
        {
          name: "Stunned",
          description: "• A stunned creature is incapacitated, can't move, and can speak only falteringly.\n• The creature automatically fails Strength and Dexterity saving throws.\n• Attack rolls against the creature have advantage."
        },
        {
          name: "Unconscious",
          description: "• An unconscious creature is incapacitated, can't move or speak, and is unaware of its surroundings.\n• The creature drops whatever it's holding and falls prone.\n• The creature automatically fails Strength and Dexterity saving throws.\n• Attack rolls against the creature have advantage.\n• Any attack that hits the creature is a critical hit if the attacker is within 5 feet of the creature."
        },
        {
          name: "Exhaustion",
          description: "Exhaustion is measured in six levels:\n1. Disadvantage on ability checks\n2. Speed halved\n3. Disadvantage on attack rolls and saving throws\n4. Hit point maximum halved\n5. Speed reduced to 0\n6. Death\n\nA long rest reduces a creature's exhaustion level by 1, provided that the creature has also ingested some food and drink."
        }
      ];
      
      function toggleExpanded() {
        setExpanded(!expanded);
      }
      
      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <div className="flex justify-between items-center mb-2">
            <h2 className="text-xl font-bold">Condition Reference</h2>
            <button
              onClick={toggleExpanded}
              className="px-2 py-1 bg-blue-500 text-white rounded"
            >
              {expanded ? "Collapse" : "Expand All"}
            </button>
          </div>
          
          <div className="space-y-2">
            {conditions.map((condition, index) => (
              <details 
                key={index} 
                className="bg-white p-3 rounded shadow"
                open={expanded}
              >
                <summary className="font-bold cursor-pointer">
                  {condition.name}
                </summary>
                <div className="mt-2 whitespace-pre-line text-sm">
                  {condition.description}
                </div>
              </details>
            ))}
          </div>
        </div>
      );
    }

    /* ---------------------------
       CurrencyTracker Component
       - Tracks party gold, silver, copper
    ---------------------------- */
    function CurrencyTracker() {
      const [partyCurrency, setPartyCurrency] = React.useState(() => {
        const saved = localStorage.getItem("partyCurrency");
        return saved ? JSON.parse(saved) : {
          copper: 0,
          silver: 0,
          electrum: 0,
          gold: 100,
          platinum: 0
        };
      });
      
      const [individualCurrency, setIndividualCurrency] = React.useState(() => {
        const saved = localStorage.getItem("individualCurrency");
        return saved ? JSON.parse(saved) : {};
      });
      
      const [characters, setCharacters] = React.useState(() => {
        const saved = localStorage.getItem("characters");
        return saved ? JSON.parse(saved) : [];
      });
      
      const [transactionAmount, setTransactionAmount] = React.useState("");
      const [transactionType, setTransactionType] = React.useState("gold");
      const [transactionCharacter, setTransactionCharacter] = React.useState("party");
      const [transactionLog, setTransactionLog] = React.useState(() => {
        const saved = localStorage.getItem("transactionLog");
        return saved ? JSON.parse(saved) : [];
      });
      
      React.useEffect(() => {
        localStorage.setItem("partyCurrency", JSON.stringify(partyCurrency));
      }, [partyCurrency]);
      
      React.useEffect(() => {
        localStorage.setItem("individualCurrency", JSON.stringify(individualCurrency));
      }, [individualCurrency]);
      
      React.useEffect(() => {
        localStorage.setItem("transactionLog", JSON.stringify(transactionLog));
      }, [transactionLog]);
      
      // Initialize any new characters with currency
      React.useEffect(() => {
        const charsSaved = localStorage.getItem("characters");
        if (charsSaved) {
          const chars = JSON.parse(charsSaved);
          let hasChanges = false;
          const newIndividual = {...individualCurrency};
          
          chars.forEach(char => {
            if (!newIndividual[char.id]) {
              newIndividual[char.id] = {
                name: char.name,
                copper: 0,
                silver: 0,
                electrum: 0,
                gold: 0,
                platinum: 0
              };
              hasChanges = true;
            }
          });
          
          if (hasChanges) {
            setIndividualCurrency(newIndividual);
          }
          
          setCharacters(chars);
        }
      }, [individualCurrency]);
      
      function addCurrency() {
        const amount = parseInt(transactionAmount) || 0;
        if (amount === 0) return;
        
        const timestamp = new Date().toISOString();
        
        if (transactionCharacter === "party") {
          // Add to party pool
          setPartyCurrency(prev => ({
            ...prev,
            [transactionType]: prev[transactionType] + amount
          }));
          
          // Log transaction
          setTransactionLog(prev => [
            {
              timestamp,
              character: "Party",
              type: transactionType,
              amount: amount,
              isAddition: true
            },
            ...prev
          ]);
        } else {
          // Add to individual
          setIndividualCurrency(prev => ({
            ...prev,
            [transactionCharacter]: {
              ...prev[transactionCharacter],
              [transactionType]: prev[transactionCharacter][transactionType] + amount
            }
          }));
          
          // Log transaction
          setTransactionLog(prev => [
            {
              timestamp,
              character: individualCurrency[transactionCharacter].name,
              type: transactionType,
              amount: amount,
              isAddition: true
            },
            ...prev
          ]);
        }
        
        setTransactionAmount("");
      }
      
      function subtractCurrency() {
        const amount = parseInt(transactionAmount) || 0;
        if (amount === 0) return;
        
        const timestamp = new Date().toISOString();
        
        if (transactionCharacter === "party") {
          // Subtract from party pool
          setPartyCurrency(prev => ({
            ...prev,
            [transactionType]: Math.max(0, prev[transactionType] - amount)
          }));
          
          // Log transaction
          setTransactionLog(prev => [
            {
              timestamp,
              character: "Party",
              type: transactionType,
              amount: amount,
              isAddition: false
            },
            ...prev
          ]);
        } else {
          // Subtract from individual
          setIndividualCurrency(prev => ({
            ...prev,
            [transactionCharacter]: {
              ...prev[transactionCharacter],
              [transactionType]: Math.max(0, prev[transactionCharacter][transactionType] - amount)
            }
          }));
          
          // Log transaction
          setTransactionLog(prev => [
            {
              timestamp,
              character: individualCurrency[transactionCharacter].name,
              type: transactionType,
              amount: amount,
              isAddition: false
            },
            ...prev
          ]);
        }
        
        setTransactionAmount("");
      }
      
      function convertCurrency() {
        if (transactionCharacter === "party") {
          // Automatically convert currency for party
          let cp = partyCurrency.copper;
          let sp = partyCurrency.silver;
          let ep = partyCurrency.electrum;
          let gp = partyCurrency.gold;
          let pp = partyCurrency.platinum;
          
          // Convert cp to sp
          const cpToSp = Math.floor(cp / 10);
          cp %= 10;
          sp += cpToSp;
          
          // Convert sp to gp
          const spToGp = Math.floor(sp / 10);
          sp %= 10;
          gp += spToGp;
          
          // Convert ep to gp
          const epToGp = Math.floor(ep / 2);
          ep %= 2;
          gp += epToGp;
          
          // Convert gp to pp
          const gpToPp = Math.floor(gp / 10);
          gp %= 10;
          pp += gpToPp;
          
          setPartyCurrency({
            copper: cp,
            silver: sp,
            electrum: ep,
            gold: gp,
            platinum: pp
          });
          
          // Log conversion
          if (cpToSp > 0 || spToGp > 0 || epToGp > 0 || gpToPp > 0) {
            setTransactionLog(prev => [
              {
                timestamp: new Date().toISOString(),
                character: "Party",
                type: "conversion",
                details: "Converted currency to higher denominations"
              },
              ...prev
            ]);
          }
        } else {
          // Individual character conversion
          const char = individualCurrency[transactionCharacter];
          if (!char) return;
          
          let cp = char.copper;
          let sp = char.silver;
          let ep = char.electrum;
          let gp = char.gold;
          let pp = char.platinum;
          
          // Convert cp to sp
          const cpToSp = Math.floor(cp / 10);
          cp %= 10;
          sp += cpToSp;
          
          // Convert sp to gp
          const spToGp = Math.floor(sp / 10);
          sp %= 10;
          gp += spToGp;
          
          // Convert ep to gp
          const epToGp = Math.floor(ep / 2);
          ep %= 2;
          gp += epToGp;
          
          // Convert gp to pp
          const gpToPp = Math.floor(gp / 10);
          gp %= 10;
          pp += gpToPp;
          
          setIndividualCurrency(prev => ({
            ...prev,
            [transactionCharacter]: {
              ...prev[transactionCharacter],
              copper: cp,
              silver: sp,
              electrum: ep,
              gold: gp,
              platinum: pp
            }
          }));
          
          // Log conversion
          if (cpToSp > 0 || spToGp > 0 || epToGp > 0 || gpToPp > 0) {
            setTransactionLog(prev => [
              {
                timestamp: new Date().toISOString(),
                character: char.name,
                type: "conversion",
                details: "Converted currency to higher denominations"
              },
              ...prev
            ]);
          }
        }
      }
      
      function distributeCurrency() {
        // Get the number of characters
        const numChars = Object.keys(individualCurrency).length;
        if (numChars === 0) return;
        
        // Calculate even shares
        const sharePP = Math.floor(partyCurrency.platinum / numChars);
        const shareGP = Math.floor(partyCurrency.gold / numChars);
        const shareEP = Math.floor(partyCurrency.electrum / numChars);
        const shareSP = Math.floor(partyCurrency.silver / numChars);
        const shareCP = Math.floor(partyCurrency.copper / numChars);
        
        // Calculate remainder
        const remainderPP = partyCurrency.platinum % numChars;
        const remainderGP = partyCurrency.gold % numChars;
        const remainderEP = partyCurrency.electrum % numChars;
        const remainderSP = partyCurrency.silver % numChars;
        const remainderCP = partyCurrency.copper % numChars;
        
        // Update individual currency
        setIndividualCurrency(prev => {
          const updated = {...prev};
          
          Object.keys(updated).forEach(charId => {
            updated[charId] = {
              ...updated[charId],
              platinum: updated[charId].platinum + sharePP,
              gold: updated[charId].gold + shareGP,
              electrum: updated[charId].electrum + shareEP,
              silver: updated[charId].silver + shareSP,
              copper: updated[charId].copper + shareCP
            };
          });
          
          return updated;
        });
        
        // Update party currency
        setPartyCurrency({
          platinum: remainderPP,
          gold: remainderGP,
          electrum: remainderEP,
          silver: remainderSP,
          copper: remainderCP
        });
        
        // Log distribution
        setTransactionLog(prev => [
          {
            timestamp: new Date().toISOString(),
            character: "Party",
            type: "distribution",
            details: `Distributed currency evenly among ${numChars} characters`
          },
          ...prev
        ]);
      }
      
      function clearLog() {
        if (confirm("Are you sure you want to clear the transaction log?")) {
          setTransactionLog([]);
        }
      }
      
      function formatDate(timestamp) {
        const date = new Date(timestamp);
        return date.toLocaleString();
      }
      
      function formatCurrencyType(type) {
        const types = {
          copper: "CP",
          silver: "SP",
          electrum: "EP",
          gold: "GP",
          platinum: "PP"
        };
        
        return types[type] || type;
      }
      
      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">Currency Tracker</h2>
          
          {/* Transaction Controls */}
          <div className="bg-white p-3 rounded shadow mb-4">
            <div className="flex flex-wrap gap-2 items-end">
              <div>
                <label className="block text-sm mb-1">Amount:</label>
                <input
                  type="number"
                  min="0"
                  className="border rounded p-1 w-24"
                  value={transactionAmount}
                  onChange={e => setTransactionAmount(e.target.value)}
                />
              </div>
              <div>
                <label className="block text-sm mb-1">Currency:</label>
                <select
                  className="border rounded p-1"
                  value={transactionType}
                  onChange={e => setTransactionType(e.target.value)}
                >
                  <option value="copper">Copper (CP)</option>
                  <option value="silver">Silver (SP)</option>
                  <option value="electrum">Electrum (EP)</option>
                  <option value="gold">Gold (GP)</option>
                  <option value="platinum">Platinum (PP)</option>
                </select>
              </div>
              <div>
                <label className="block text-sm mb-1">Character:</label>
                <select
                  className="border rounded p-1"
                  value={transactionCharacter}
                  onChange={e => setTransactionCharacter(e.target.value)}
                >
                  <option value="party">Party Fund</option>
                  {Object.keys(individualCurrency).map(charId => (
                    <option key={charId} value={charId}>
                      {individualCurrency[charId].name}
                    </option>
                  ))}
                </select>
              </div>
              <button
                className="px-3 py-1 bg-green-500 text-white rounded"
                onClick={addCurrency}
              >
                Add
              </button>
              <button
                className="px-3 py-1 bg-red-500 text-white rounded"
                onClick={subtractCurrency}
              >
                Subtract
              </button>
            </div>
            
            <div className="flex gap-2 mt-4">
              <button
                className="px-3 py-1 bg-blue-500 text-white rounded"
                onClick={convertCurrency}
              >
                Convert Up
              </button>
              <button
                className="px-3 py-1 bg-purple-500 text-white rounded"
                onClick={distributeCurrency}
              >
                Distribute Evenly
              </button>
            </div>
          </div>
          
          {/* Currency Display */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
            {/* Party Currency */}
            <div className="bg-white p-3 rounded shadow">
              <h3 className="font-bold mb-2">Party Fund</h3>
              <div className="grid grid-cols-5 gap-2">
                <div className="text-center">
                  <div className="bg-yellow-100 p-1 rounded">PP</div>
                  <div className="font-semibold mt-1">{partyCurrency.platinum}</div>
                </div>
                <div className="text-center">
                  <div className="bg-yellow-100 p-1 rounded">GP</div>
                  <div className="font-semibold mt-1">{partyCurrency.gold}</div>
                </div>
                <div className="text-center">
                  <div className="bg-yellow-100 p-1 rounded">EP</div>
                  <div className="font-semibold mt-1">{partyCurrency.electrum}</div>
                </div>
                <div className="text-center">
                  <div className="bg-yellow-100 p-1 rounded">SP</div>
                  <div className="font-semibold mt-1">{partyCurrency.silver}</div>
                </div>
                <div className="text-center">
                  <div className="bg-yellow-100 p-1 rounded">CP</div>
                  <div className="font-semibold mt-1">{partyCurrency.copper}</div>
                </div>
              </div>
              <div className="mt-2 text-sm text-gray-600">
                Total (in GP): {partyCurrency.platinum * 10 + partyCurrency.gold + partyCurrency.electrum * 0.5 + partyCurrency.silver * 0.1 + partyCurrency.copper * 0.01}
              </div>
            </div>
            
            {/* Individual Currency */}
            <div className="bg-white p-3 rounded shadow">
              <h3 className="font-bold mb-2">Individual Funds</h3>
              <div className="space-y-2 max-h-40 overflow-y-auto">
                {Object.keys(individualCurrency).map(charId => (
                  <div key={charId} className="border-b pb-1">
                    <div className="font-semibold">{individualCurrency[charId].name}</div>
                    <div className="flex gap-2 text-sm">
                      <div>PP: {individualCurrency[charId].platinum}</div>
                      <div>GP: {individualCurrency[charId].gold}</div>
                      <div>EP: {individualCurrency[charId].electrum}</div>
                      <div>SP: {individualCurrency[charId].silver}</div>
                      <div>CP: {individualCurrency[charId].copper}</div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          </div>
          
          {/* Transaction Log */}
          <div>
            <div className="flex justify-between items-center mb-2">
              <h3 className="font-bold">Transaction Log</h3>
              {transactionLog.length > 0 && (
                <button
                  className="px-2 py-1 bg-red-500 text-white rounded text-sm"
                  onClick={clearLog}
                >
                  Clear Log
                </button>
              )}
            </div>
            <div className="bg-white p-3 rounded shadow max-h-60 overflow-y-auto">
              {transactionLog.length > 0 ? (
                <ul className="space-y-2">
                  {transactionLog.map((entry, idx) => (
                    <li key={idx} className="border-b pb-1">
                      <div className="text-xs text-gray-500">{formatDate(entry.timestamp)}</div>
                      {entry.type === "conversion" ? (
                        <div>{entry.character}: {entry.details}</div>
                      ) : entry.type === "distribution" ? (
                        <div className="text-purple-600">{entry.details}</div>
                      ) : (
                        <div>
                          <span className="font-semibold">{entry.character}</span>{" "}
                          {entry.isAddition ? "received" : "spent"}{" "}
                          <span className={entry.isAddition ? "text-green-600" : "text-red-600"}>
                            {entry.amount} {formatCurrencyType(entry.type)}
                          </span>
                        </div>
                      )}
                    </li>
                  ))}
                </ul>
              ) : (
                <p className="text-center text-gray-500 p-4">No transactions logged yet</p>
              )}
            </div>
          </div>
        </div>
      );
    }

    /* ---------------------------
       WeatherTimeTracker Component
       - Tracks in-game time and weather
    ---------------------------- */
    function WeatherTimeTracker() {
      const [gameTime, setGameTime] = React.useState(() => {
        const saved = localStorage.getItem("gameTime");
        return saved ? JSON.parse(saved) : {
          year: 1496,
          month: 4,
          day: 15,
          hour: 8,
          minute: 0,
          totalMinutes: 0
        };
      });
      
      const [weather, setWeather] = React.useState(() => {
        const saved = localStorage.getItem("currentWeather");
        return saved ? JSON.parse(saved) : {
          temperature: "Mild",
          condition: "Clear",
          wind: "Light Breeze",
          precipitation: "None",
          customNotes: ""
        };
      });
      
      const [eventLog, setEventLog] = React.useState(() => {
        const saved = localStorage.getItem("timeWeatherLog");
        return saved ? JSON.parse(saved) : [];
      });
      
      const [addMinutes, setAddMinutes] = React.useState(30);
      const [addHours, setAddHours] = React.useState(1);
      const [addDays, setAddDays] = React.useState(1);
      
      React.useEffect(() => {
        localStorage.setItem("gameTime", JSON.stringify(gameTime));
      }, [gameTime]);
      
      React.useEffect(() => {
        localStorage.setItem("currentWeather", JSON.stringify(weather));
      }, [weather]);
      
      React.useEffect(() => {
        localStorage.setItem("timeWeatherLog", JSON.stringify(eventLog));
      }, [eventLog]);
      
      const monthNames = [
        "Hammer",
        "Alturiak",
        "Ches",
        "Tarsakh",
        "Mirtul",
        "Kythorn",
        "Flamerule",
        "Eleasis",
        "Eleint",
        "Marpenoth",
        "Uktar",
        "Nightal"
      ];
      
      const temperatures = [
        "Freezing",
        "Cold",
        "Cool",
        "Mild",
        "Warm",
        "Hot",
        "Scorching"
      ];
      
      const conditions = [
        "Clear",
        "Partly Cloudy",
        "Cloudy",
        "Overcast",
        "Foggy",
        "Light Rain",
        "Heavy Rain",
        "Thunderstorm",
        "Light Snow",
        "Heavy Snow",
        "Hail",
        "Magical Anomaly"
      ];
      
      const winds = [
        "None",
        "Light Breeze",
        "Moderate Wind",
        "Strong Wind",
        "Gale",
        "Storm"
      ];
      
      const precipitations = [
        "None",
        "Drizzle",
        "Light Rain",
        "Heavy Rain",
        "Light Snow",
        "Heavy Snow",
        "Sleet",
        "Hail"
      ];
      
      function advanceTime(minutes) {
        const timestamp = new Date().toISOString();
        
        // Calculate new time
        const totalMinutes = gameTime.totalMinutes + minutes;
        
        let newMinute = (gameTime.minute + minutes) % 60;
        let hoursToAdd = Math.floor((gameTime.minute + minutes) / 60);
        
        let newHour = (gameTime.hour + hoursToAdd) % 24;
        let daysToAdd = Math.floor((gameTime.hour + hoursToAdd) / 24);
        
        let newDay = gameTime.day + daysToAdd;
        let newMonth = gameTime.month;
        let newYear = gameTime.year;
        
        // Check if we need to advance months
        const daysInMonth = 30; // Simplified D&D calendar
        while (newDay > daysInMonth) {
          newDay -= daysInMonth;
          newMonth++;
          
          if (newMonth > 12) {
            newMonth = 1;
            newYear++;
          }
        }
        
        setGameTime({
          year: newYear,
          month: newMonth,
          day: newDay,
          hour: newHour,
          minute: newMinute,
          totalMinutes: totalMinutes
        });
        
        // Log time advancement
        setEventLog(prev => [
          {
            timestamp,
            type: "timeAdvance",
            minutes: minutes,
            newTime: `Year ${newYear}, ${monthNames[newMonth-1]} ${newDay}, ${newHour.toString().padStart(2, '0')}:${newMinute.toString().padStart(2, '0')}`
          },
          ...prev
        ]);
      }
      
      function setSpecificTime(year, month, day, hour, minute) {
        const timestamp = new Date().toISOString();
        
        // Calculate total minutes (rough approximation)
        const totalMinutes = ((year - 1) * 12 * 30 * 24 * 60) + 
                             ((month - 1) * 30 * 24 * 60) + 
                             ((day - 1) * 24 * 60) + 
                             (hour * 60) + 
                             minute;
        
        setGameTime({
          year,
          month,
          day,
          hour,
          minute,
          totalMinutes
        });
        
        // Log time setting
        setEventLog(prev => [
          {
            timestamp,
            type: "timeSet",
            newTime: `Year ${year}, ${monthNames[month-1]} ${day}, ${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`
          },
          ...prev
        ]);
      }
      
      function updateWeather(changes) {
        const timestamp = new Date().toISOString();
        
        const updatedWeather = {
          ...weather,
          ...changes
        };
        
        setWeather(updatedWeather);
        
        // Log weather change
        setEventLog(prev => [
          {
            timestamp,
            type: "weatherChange",
            newWeather: `${updatedWeather.temperature}, ${updatedWeather.condition}, ${updatedWeather.wind} wind, ${updatedWeather.precipitation} precipitation`
          },
          ...prev
        ]);
      }
      
      function randomizeWeather() {
        const timestamp = new Date().toISOString();
        
        const newWeather = {
          temperature: temperatures[Math.floor(Math.random() * temperatures.length)],
          condition: conditions[Math.floor(Math.random() * conditions.length)],
          wind: winds[Math.floor(Math.random() * winds.length)],
          precipitation: precipitations[Math.floor(Math.random() * precipitations.length)],
          customNotes: weather.customNotes
        };
        
        // Make weather consistent (if it's Clear, don't have Heavy Rain precipitation)
        if (newWeather.condition === "Clear" || newWeather.condition === "Partly Cloudy") {
          newWeather.precipitation = "None";
        }
        
        if (newWeather.condition.includes("Rain") || newWeather.condition === "Thunderstorm") {
          newWeather.precipitation = precipitations.filter(p => p.includes("Rain") || p === "Drizzle")[Math.floor(Math.random() * 3)];
        }
        
        if (newWeather.condition.includes("Snow")) {
          newWeather.precipitation = precipitations.filter(p => p.includes("Snow"))[Math.floor(Math.random() * 2)];
          if (newWeather.temperature === "Warm" || newWeather.temperature === "Hot" || newWeather.temperature === "Scorching") {
            newWeather.temperature = "Cold";
          }
        }
        
        setWeather(newWeather);
        
        // Log weather randomization
        setEventLog(prev => [
          {
            timestamp,
            type: "weatherRandomize",
            newWeather: `${newWeather.temperature}, ${newWeather.condition}, ${newWeather.wind} wind, ${newWeather.precipitation} precipitation`
          },
          ...prev
        ]);
      }
      
      function clearLog() {
        if (confirm("Are you sure you want to clear the event log?")) {
          setEventLog([]);
        }
      }
      
      function formatDate(timestamp) {
        const date = new Date(timestamp);
        return date.toLocaleString();
      }
      
      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">Time & Weather Tracker</h2>
          
          {/* Current Time Display */}
          <div className="mb-4 bg-white p-3 rounded shadow">
            <h3 className="font-bold mb-2">Current Time</h3>
            <div className="text-lg text-center">
              Year {gameTime.year}, {monthNames[gameTime.month-1]} {gameTime.day}{gameTime.day === 1 ? 'st' : gameTime.day === 2 ? 'nd' : gameTime.day === 3 ? 'rd' : 'th'}
            </div>
            <div className="text-3xl text-center font-bold my-2">
              {gameTime.hour.toString().padStart(2, '0')}:{gameTime.minute.toString().padStart(2, '0')}
            </div>
            
            {/* Time Controls */}
            <div className="grid grid-cols-3 gap-2 mt-4">
              <div>
                <label className="block text-sm mb-1">Add Minutes:</label>
                <div className="flex gap-1">
                  <input
                    type="number"
                    className="border rounded p-1 w-16"
                    value={addMinutes}
                    onChange={e => setAddMinutes(parseInt(e.target.value) || 0)}
                  />
                  <button
                    className="px-2 py-1 bg-blue-500 text-white rounded"
                    onClick={() => advanceTime(addMinutes)}
                  >
                    Add
                  </button>
                </div>
              </div>
              <div>
                <label className="block text-sm mb-1">Add Hours:</label>
                <div className="flex gap-1">
                  <input
                    type="number"
                    className="border rounded p-1 w-16"
                    value={addHours}
                    onChange={e => setAddHours(parseInt(e.target.value) || 0)}
                  />
                  <button
                    className="px-2 py-1 bg-blue-500 text-white rounded"
                    onClick={() => advanceTime(addHours * 60)}
                  >
                    Add
                  </button>
                </div>
              </div>
              <div>
                <label className="block text-sm mb-1">Add Days:</label>
                <div className="flex gap-1">
                  <input
                    type="number"
                    className="border rounded p-1 w-16"
                    value={addDays}
                    onChange={e => setAddDays(parseInt(e.target.value) || 0)}
                  />
                  <button
                    className="px-2 py-1 bg-blue-500 text-white rounded"
                    onClick={() => advanceTime(addDays * 24 * 60)}
                  >
                    Add
                  </button>
                </div>
              </div>
            </div>
            
            {/* Set Specific Time */}
            <div className="mt-4">
              <h4 className="font-semibold mb-1">Set Specific Time:</h4>
              <div className="flex flex-wrap gap-2">
                <input
                  type="number"
                  placeholder="Year"
                  className="border rounded p-1 w-16"
                  defaultValue={gameTime.year}
                  min="1"
                  onBlur={e => {
                    const val = parseInt(e.target.value) || 1;
                    setSpecificTime(
                      val,
                      gameTime.month,
                      gameTime.day,
                      gameTime.hour,
                      gameTime.minute
                    );
                  }}
                />
                <select
                  className="border rounded p-1"
                  defaultValue={gameTime.month}
                  onChange={e => {
                    setSpecificTime(
                      gameTime.year,
                      parseInt(e.target.value),
                      gameTime.day,
                      gameTime.hour,
                      gameTime.minute
                    );
                  }}
                >
                  {monthNames.map((month, idx) => (
                    <option key={idx} value={idx + 1}>{month}</option>
                  ))}
                </select>
                <input
                  type="number"
                  placeholder="Day"
                  className="border rounded p-1 w-16"
                  defaultValue={gameTime.day}
                  min="1"
                  max="30"
                  onBlur={e => {
                    const val = Math.min(30, Math.max(1, parseInt(e.target.value) || 1));
                    setSpecificTime(
                      gameTime.year,
                      gameTime.month,
                      val,
                      gameTime.hour,
                      gameTime.minute
                    );
                  }}
                />
                <input
                  type="number"
                  placeholder="Hour"
                  className="border rounded p-1 w-16"
                  defaultValue={gameTime.hour}
                  min="0"
                  max="23"
                  onBlur={e => {
                    const val = Math.min(23, Math.max(0, parseInt(e.target.value) || 0));
                    setSpecificTime(
                      gameTime.year,
                      gameTime.month,
                      gameTime.day,
                      val,
                      gameTime.minute
                    );
                  }}
                />
                <input
                  type="number"
                  placeholder="Minute"
                  className="border rounded p-1 w-16"
                  defaultValue={gameTime.minute}
                  min="0"
                  max="59"
                  onBlur={e => {
                    const val = Math.min(59, Math.max(0, parseInt(e.target.value) || 0));
                    setSpecificTime(
                      gameTime.year,
                      gameTime.month,
                      gameTime.day,
                      gameTime.hour,
                      val
                    );
                  }}
                />
              </div>
            </div>
          </div>
          
          {/* Current Weather Display */}
          <div className="mb-4 bg-white p-3 rounded shadow">
            <div className="flex justify-between items-center mb-2">
              <h3 className="font-bold">Current Weather</h3>
              <button
                className="px-2 py-1 bg-purple-500 text-white rounded text-sm"
                onClick={randomizeWeather}
              >
                Randomize
              </button>
            </div>
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label className="block text-sm mb-1">Temperature:</label>
                <select
                  className="border rounded p-1 w-full"
                  value={weather.temperature}
                  onChange={e => updateWeather({ temperature: e.target.value })}
                >
                  {temperatures.map((temp, idx) => (
                    <option key={idx} value={temp}>{temp}</option>
                  ))}
                </select>
              </div>
              <div>
                <label className="block text-sm mb-1">Condition:</label>
                <select
                  className="border rounded p-1 w-full"
                  value={weather.condition}
                  onChange={e => updateWeather({ condition: e.target.value })}
                >
                  {conditions.map((cond, idx) => (
                    <option key={idx} value={cond}>{cond}</option>
                  ))}
                </select>
              </div>
              <div>
                <label className="block text-sm mb-1">Wind:</label>
                <select
                  className="border rounded p-1 w-full"
                  value={weather.wind}
                  onChange={e => updateWeather({ wind: e.target.value })}
                >
                  {winds.map((wind, idx) => (
                    <option key={idx} value={wind}>{wind}</option>
                  ))}
                </select>
              </div>
              <div>
                <label className="block text-sm mb-1">Precipitation:</label>
                <select
                  className="border rounded p-1 w-full"
                  value={weather.precipitation}
                  onChange={e => updateWeather({ precipitation: e.target.value })}
                >
                  {precipitations.map((precip, idx) => (
                    <option key={idx} value={precip}>{precip}</option>
                  ))}
                </select>
              </div>
            </div>
            
            <div className="mt-4">
              <label className="block text-sm mb-1">Custom Notes:</label>
              <textarea
                className="border rounded p-1 w-full"
                value={weather.customNotes}
                onChange={e => updateWeather({ customNotes: e.target.value })}
                rows="2"
              ></textarea>
            </div>
            
            <div className="mt-4 p-2 bg-gray-100 rounded">
              <p className="text-center">
                <span className="font-semibold">Current Weather:</span> {weather.temperature}, {weather.condition}, {weather.wind} wind
                {weather.precipitation !== "None" && `, with ${weather.precipitation}`}
                {weather.customNotes && ` — ${weather.customNotes}`}
              </p>
            </div>
          </div>
          
          {/* Event Log */}
          <div>
            <div className="flex justify-between items-center mb-2">
              <h3 className="font-bold">Event Log</h3>
              {eventLog.length > 0 && (
                <button
                  className="px-2 py-1 bg-red-500 text-white rounded text-sm"
                  onClick={clearLog}
                >
                  Clear Log
                </button>
              )}
            </div>
            <div className="bg-white p-3 rounded shadow max-h-60 overflow-y-auto">
              {eventLog.length > 0 ? (
                <ul className="space-y-2">
                  {eventLog.map((entry, idx) => (
                    <li key={idx} className="border-b pb-1">
                      <div className="text-xs text-gray-500">{formatDate(entry.timestamp)}</div>
                      {entry.type === "timeAdvance" && (
                        <div>
                          Advanced time by{" "}
                          {entry.minutes >= 1440 
                            ? `${Math.floor(entry.minutes / 1440)} days` 
                            : entry.minutes >= 60 
                              ? `${Math.floor(entry.minutes / 60)} hours` 
                              : `${entry.minutes} minutes`
                          }
                          .
                          <div className="text-blue-600">New time: {entry.newTime}</div>
                        </div>
                      )}
                      {entry.type === "timeSet" && (
                        <div>
                          <span>Set time to: </span>
                          <span className="text-blue-600">{entry.newTime}</span>
                        </div>
                      )}
                      {entry.type === "weatherChange" && (
                        <div>
                          <span>Weather changed to: </span>
                          <span className="text-green-600">{entry.newWeather}</span>
                        </div>
                      )}
                      {entry.type === "weatherRandomize" && (
                        <div>
                          <span>Weather randomized to: </span>
                          <span className="text-purple-600">{entry.newWeather}</span>
                        </div>
                      )}
                    </li>
                  ))}
                </ul>
              ) : (
                <p className="text-center text-gray-500 p-4">No events logged yet</p>
              )}
            </div>
          </div>
        </div>
      );
    }

    /* ---------------------------
       CombatLog Component
       - Tracks combat actions and results
    ---------------------------- */
    function CombatLog() {
      const [combatLog, setCombatLog] = React.useState(() => {
        const saved = localStorage.getItem("combatLog");
        return saved ? JSON.parse(saved) : [];
      });
      
      const [currentCombat, setCurrentCombat] = React.useState(() => {
        const saved = localStorage.getItem("currentCombat");
        return saved ? JSON.parse(saved) : null;
      });
      
      const [newAction, setNewAction] = React.useState({
        actorName: "",
        actionType: "attack",
        targetName: "",
        description: "",
        rollResult: "",
        damage: "",
        isSuccess: true
      });
      
      React.useEffect(() => {
        localStorage.setItem("combatLog", JSON.stringify(combatLog));
      }, [combatLog]);
      
      React.useEffect(() => {
        localStorage.setItem("currentCombat", JSON.stringify(currentCombat));
      }, [currentCombat]);
      
      function startNewCombat() {
        const timestamp = new Date().toISOString();
        
        // First check if there's an active combat
        if (currentCombat) {
          if (!confirm("There's already an active combat. Start a new one?")) {
            return;
          }
          // End the current combat
          endCombat();
        }
        
        const newCombatId = Date.now();
        
        setCurrentCombat({
          id: newCombatId,
          startTime: timestamp,
          name: `Combat #${combatLog.filter(c => c.type === "combat").length + 1}`,
          round: 1,
          actions: []
        });
        
        // Add to log
        setCombatLog(prev => [
          {
            timestamp,
            type: "combat",
            id: newCombatId,
            action: "start",
            name: `Combat #${prev.filter(c => c.type === "combat").length + 1}`
          },
          ...prev
        ]);
      }
      
      function endCombat() {
        if (!currentCombat) return;
        
        const timestamp = new Date().toISOString();
        
        // Add end combat entry
        setCombatLog(prev => [
          {
            timestamp,
            type: "combat",
            id: currentCombat.id,
            action: "end",
            name: currentCombat.name,
            rounds: currentCombat.round,
            actions: currentCombat.actions.length
          },
          ...prev
        ]);
        
        setCurrentCombat(null);
      }
      
      function advanceRound() {
        if (!currentCombat) return;
        
        const timestamp = new Date().toISOString();
        
        setCurrentCombat(prev => ({
          ...prev,
          round: prev.round + 1
        }));
        
        // Add to log
        setCombatLog(prev => [
          {
            timestamp,
            type: "round",
            combatId: currentCombat.id,
            round: currentCombat.round + 1
          },
          ...prev
        ]);
      }
      
      function logAction() {
        if (!currentCombat || !newAction.actorName.trim()) return;
        
        const timestamp = new Date().toISOString();
        
        // Create the action
        const action = {
          timestamp,
          id: Date.now(),
          actorName: newAction.actorName.trim(),
          actionType: newAction.actionType,
          targetName: newAction.targetName.trim(),
          description: newAction.description.trim(),
          rollResult: newAction.rollResult.trim(),
          damage: newAction.damage.trim(),
          isSuccess: newAction.isSuccess,
          round: currentCombat.round
        };
        
        // Add to current combat
        setCurrentCombat(prev => ({
          ...prev,
          actions: [...prev.actions, action]
        }));
        
        // Add to log
        setCombatLog(prev => [
          {
            timestamp,
            type: "action",
            combatId: currentCombat.id,
            round: currentCombat.round,
            action: action
          },
          ...prev
        ]);
        
        // Reset form except for actor
        setNewAction({
          actorName: newAction.actorName, // Keep the actor name
          actionType: "attack",
          targetName: "",
          description: "",
          rollResult: "",
          damage: "",
          isSuccess: true
        });
      }
      
      function getActionColor(type) {
        switch (type) {
          case "attack": return "text-red-600";
          case "spell": return "text-purple-600";
          case "ability": return "text-blue-600";
          case "item": return "text-yellow-600";
          case "movement": return "text-green-600";
          case "other": return "text-gray-600";
          default: return "text-black";
        }
      }
      
      function getActionIcon(type) {
        switch (type) {
          case "attack": return "⚔️";
          case "spell": return "✨";
          case "ability": return "🔥";
          case "item": return "🧪";
          case "movement": return "👣";
          case "other": return "📝";
          default: return "➡️";
        }
      }
      
      function clearLog() {
        if (confirm("Are you sure you want to clear the combat log?")) {
          setCombatLog([]);
        }
      }
      
      function formatDate(timestamp) {
        const date = new Date(timestamp);
        return date.toLocaleString();
      }
      
      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">Combat Log</h2>
          
          {/* Combat Controls */}
          <div className="bg-white p-3 rounded shadow mb-4">
            <div className="flex gap-2 mb-2">
              {!currentCombat ? (
                <button
                  className="px-3 py-1 bg-red-500 text-white rounded"
                  onClick={startNewCombat}
                >
                  Start New Combat
                </button>
              ) : (
                <>
                  <button
                    className="px-3 py-1 bg-blue-500 text-white rounded"
                    onClick={advanceRound}
                  >
                    Next Round ({currentCombat.round + 1})
                  </button>
                  <button
                    className="px-3 py-1 bg-gray-500 text-white rounded"
                    onClick={endCombat}
                  >
                    End Combat
                  </button>
                  <div className="ml-2 flex items-center">
                    <span className="font-semibold">{currentCombat.name}</span>
                    <span className="ml-2">Round: {currentCombat.round}</span>
                  </div>
                </>
              )}
            </div>
            
            {currentCombat && (
              <div className="space-y-2">
                <h3 className="font-semibold">Log Action</h3>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
                  <div>
                    <label className="block text-sm mb-1">Actor:</label>
                    <input
                      className="border rounded p-1 w-full"
                      value={newAction.actorName}
                      onChange={e => setNewAction({...newAction, actorName: e.target.value})}
                      placeholder="Who performed the action?"
                    />
                  </div>
                  <div>
                    <label className="block text-sm mb-1">Target:</label>
                    <input
                      className="border rounded p-1 w-full"
                      value={newAction.targetName}
                      onChange={e => setNewAction({...newAction, targetName: e.target.value})}
                      placeholder="Who was targeted? (if any)"
                    />
                  </div>
                  <div>
                    <label className="block text-sm mb-1">Action Type:</label>
                    <select
                      className="border rounded p-1 w-full"
                      value={newAction.actionType}
                      onChange={e => setNewAction({...newAction, actionType: e.target.value})}
                    >
                      <option value="attack">Attack</option>
                      <option value="spell">Spell Cast</option>
                      <option value="ability">Special Ability</option>
                      <option value="item">Use Item</option>
                      <option value="movement">Movement/Position</option>
                      <option value="other">Other</option>
                    </select>
                  </div>
                  <div>
                    <label className="block text-sm mb-1">Result:</label>
                    <div className="flex gap-2">
                      <input
                        className="border rounded p-1 w-full"
                        value={newAction.rollResult}
                        onChange={e => setNewAction({...newAction, rollResult: e.target.value})}
                        placeholder="Roll result (e.g., 18)"
                      />
                      <select
                        className="border rounded p-1"
                        value={newAction.isSuccess ? "hit" : "miss"}
                        onChange={e => setNewAction({...newAction, isSuccess: e.target.value === "hit"})}
                      >
                        <option value="hit">Hit</option>
                        <option value="miss">Miss</option>
                      </select>
                    </div>
                  </div>
                  <div>
                    <label className="block text-sm mb-1">Damage/Effect:</label>
                    <input
                      className="border rounded p-1 w-full"
                      value={newAction.damage}
                      onChange={e => setNewAction({...newAction, damage: e.target.value})}
                      placeholder="Damage or effect (e.g., 12 fire)"
                    />
                  </div>
                  <div>
                    <label className="block text-sm mb-1">Description:</label>
                    <input
                      className="border rounded p-1 w-full"
                      value={newAction.description}
                      onChange={e => setNewAction({...newAction, description: e.target.value})}
                      placeholder="Brief description of what happened"
                    />
                  </div>
                </div>
                <button
                  className="w-full px-3 py-1 bg-green-500 text-white rounded mt-1"
                  onClick={logAction}
                  disabled={!newAction.actorName.trim()}
                >
                  Log Action
                </button>
              </div>
            )}
          </div>
          
          {/* Combat Log Display */}
          <div>
            <div className="flex justify-between items-center mb-2">
              <h3 className="font-bold">Combat Log</h3>
              {combatLog.length > 0 && (
                <button
                  className="px-2 py-1 bg-red-500 text-white rounded text-sm"
                  onClick={clearLog}
                >
                  Clear Log
                </button>
              )}
            </div>
            <div className="bg-white p-3 rounded shadow max-h-96 overflow-y-auto">
              {combatLog.length > 0 ? (
                <ul className="space-y-2">
                  {combatLog.map((entry, idx) => (
                    <li key={idx} className="border-b pb-1">
                      <div className="text-xs text-gray-500">{formatDate(entry.timestamp)}</div>
                      
                      {entry.type === "combat" && entry.action === "start" && (
                        <div className="font-semibold text-blue-600">
                          ⚔️ Started new combat: {entry.name}
                        </div>
                      )}
                      
                      {entry.type === "combat" && entry.action === "end" && (
                        <div className="font-semibold text-purple-600">
                          🏁 Ended combat: {entry.name} - {entry.rounds} rounds, {entry.actions} actions
                        </div>
                      )}
                      
                      {entry.type === "round" && (
                        <div className="font-semibold text-green-600">
                          🔄 Starting Round {entry.round}
                        </div>
                      )}
                      
                      {entry.type === "action" && (
                        <div>
                          <div className="flex flex-wrap items-center gap-1">
                            <span className="font-semibold">{entry.action.actorName}</span>
                            <span className={getActionColor(entry.action.actionType)}>
                              {getActionIcon(entry.action.actionType)} {entry.action.actionType}
                            </span>
                            {entry.action.targetName && (
                              <>
                                <span>→</span>
                                <span className="font-semibold">{entry.action.targetName}</span>
                              </>
                            )}
                            {entry.action.rollResult && (
                              <span className={entry.action.isSuccess ? "text-green-600" : "text-red-600"}>
                                [{entry.action.rollResult} - {entry.action.isSuccess ? "Hit" : "Miss"}]
                              </span>
                            )}
                            {entry.action.damage && (
                              <span className="text-orange-600">
                                {entry.action.damage}
                              </span>
                            )}
                          </div>
                          {entry.action.description && (
                            <div className="text-sm text-gray-600 ml-4">
                              {entry.action.description}
                            </div>
                          )}
                        </div>
                      )}
                    </li>
                  ))}
                </ul>
              ) : (
                <p className="text-center text-gray-500 p-4">No combat actions logged yet</p>
              )}
            </div>
          </div>
        </div>
      );
    }

    /* ---------------------------
       NotepadComponent 
       - For tracking campaign notes
    ---------------------------- */
    function NotepadComponent() {
      const [notes, setNotes] = React.useState(() => {
        const saved = localStorage.getItem("campaignNotes");
        return saved ? JSON.parse(saved) : [];
      });
      
      const [activeNoteId, setActiveNoteId] = React.useState(() => {
        const saved = localStorage.getItem("activeNoteId");
        return saved || null;
      });
      
      const [noteContent, setNoteContent] = React.useState("");
      const [noteTitle, setNoteTitle] = React.useState("");
      const [editMode, setEditMode] = React.useState(false);
      const [searchQuery, setSearchQuery] = React.useState("");
      
      React.useEffect(() => {
        localStorage.setItem("campaignNotes", JSON.stringify(notes));
      }, [notes]);
      
      React.useEffect(() => {
        localStorage.setItem("activeNoteId", activeNoteId);
      }, [activeNoteId]);
      
      // Set active note content when activeNoteId changes
      React.useEffect(() => {
        if (activeNoteId) {
          const note = notes.find(n => n.id === activeNoteId);
          if (note) {
            setNoteTitle(note.title);
            setNoteContent(note.content);
          }
        } else {
          setNoteTitle("");
          setNoteContent("");
        }
      }, [activeNoteId, notes]);
      
      function createNewNote() {
        const newId = Date.now().toString();
        const newNote = {
          id: newId,
          title: "New Note",
          content: "",
          created: new Date().toISOString(),
          updated: new Date().toISOString(),
          tags: []
        };
        
        setNotes(prev => [newNote, ...prev]);
        setActiveNoteId(newId);
        setNoteTitle("New Note");
        setNoteContent("");
        setEditMode(true);
      }
      
      function saveNote() {
        if (!activeNoteId) return;
        
        setNotes(prev => prev.map(note => 
          note.id === activeNoteId 
            ? { 
                ...note, 
                title: noteTitle.trim() || "Untitled Note", 
                content: noteContent,
                updated: new Date().toISOString()
              } 
            : note
        ));
        
        setEditMode(false);
      }
      
      function deleteNote() {
        if (!activeNoteId) return;
        
        if (confirm(`Are you sure you want to delete "${notes.find(n => n.id === activeNoteId)?.title}"?`)) {
          setNotes(prev => prev.filter(note => note.id !== activeNoteId));
          setActiveNoteId(null);
          setNoteTitle("");
          setNoteContent("");
          setEditMode(false);
        }
      }
      
      function getFilteredNotes() {
        if (!searchQuery.trim()) return notes;
        
        const query = searchQuery.toLowerCase();
        return notes.filter(note => 
          note.title.toLowerCase().includes(query) || 
          note.content.toLowerCase().includes(query)
        );
      }
      
      const filteredNotes = getFilteredNotes();
      const activeNote = notes.find(n => n.id === activeNoteId);
      
      function formatDate(isoString) {
        const date = new Date(isoString);
        return date.toLocaleString();
      }
      
      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">Campaign Notes</h2>
          
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 h-96">
            {/* Note List */}
            <div className="bg-white rounded shadow md:col-span-1 flex flex-col">
              <div className="p-2 border-b">
                <div className="flex gap-2 mb-2">
                  <button
                    className="px-3 py-1 bg-green-500 text-white rounded flex-grow"
                    onClick={createNewNote}
                  >
                    New Note
                  </button>
                  <button
                    className="px-3 py-1 bg-red-500 text-white rounded"
                    onClick={deleteNote}
                    disabled={!activeNoteId}
                  >
                    Delete
                  </button>
                </div>
                <input
                  className="border rounded p-1 w-full"
                  placeholder="Search notes..."
                  value={searchQuery}
                  onChange={e => setSearchQuery(e.target.value)}
                />
              </div>
              <div className="overflow-y-auto flex-grow">
                <ul className="divide-y">
                  {filteredNotes.map(note => (
                    <li 
                      key={note.id}
                      className={`p-2 cursor-pointer hover:bg-gray-100 ${
                        note.id === activeNoteId ? "bg-blue-50 border-l-4 border-blue-500" : ""
                      }`}
                      onClick={() => {
                        if (editMode && activeNoteId && !confirm("Discard unsaved changes?")) {
                          return;
                        }
                        setActiveNoteId(note.id);
                        setEditMode(false);
                      }}
                    >
                      <div className="font-semibold truncate">{note.title}</div>
                      <div className="text-xs text-gray-500">
                        Updated: {formatDate(note.updated)}
                      </div>
                      <div className="text-xs text-gray-600 truncate">
                        {note.content.substring(0, 60)}{note.content.length > 60 ? "..." : ""}
                      </div>
                    </li>
                  ))}
                  {filteredNotes.length === 0 && (
                    <li className="p-4 text-center text-gray-500">
                      {searchQuery ? "No matching notes found" : "No notes yet"}
                    </li>
                  )}
                </ul>
              </div>
            </div>
            
            {/* Note Content */}
            <div className="bg-white rounded shadow md:col-span-2 flex flex-col">
              {activeNoteId ? (
                <>
                  <div className="p-2 border-b flex justify-between items-center">
                    {editMode ? (
                      <input
                        className="border rounded p-1 flex-grow"
                        value={noteTitle}
                        onChange={e => setNoteTitle(e.target.value)}
                        placeholder="Note title"
                      />
                    ) : (
                      <h3 className="font-bold">{activeNote?.title}</h3>
                    )}
                    <div className="flex gap-2">
                      {editMode ? (
                        <button
                          className="px-3 py-1 bg-green-500 text-white rounded"
                          onClick={saveNote}
                        >
                          Save
                        </button>
                      ) : (
                        <button
                          className="px-3 py-1 bg-blue-500 text-white rounded"
                          onClick={() => setEditMode(true)}
                        >
                          Edit
                        </button>
                      )}
                    </div>
                  </div>
                  <div className="p-2 text-xs text-gray-500">
                    Last updated: {formatDate(activeNote?.updated)}
                  </div>
                  <div className="flex-grow p-2 overflow-y-auto">
                    {editMode ? (
                      <textarea
                        className="border rounded p-2 w-full h-full resize-none"
                        value={noteContent}
                        onChange={e => setNoteContent(e.target.value)}
                        placeholder="Write your note here..."
                      ></textarea>
                    ) : (
                      <div className="whitespace-pre-wrap">
                        {activeNote?.content || <span className="text-gray-500">Empty note</span>}
                      </div>
                    )}
                  </div>
                </>
              ) : (
                <div className="flex items-center justify-center h-full text-gray-500">
                  Select a note or create a new one
                </div>
              )}
            </div>
          </div>
        </div>
      );
    }

    /* ---------------------------
       XpTracker Component
       - Tracks experience points and levels
    ---------------------------- */
    function XpTracker({ characters, onUpdateChar }) {
      const [xpByChar, setXpByChar] = React.useState(() => {
        const saved = localStorage.getItem("characterXp");
        return saved ? JSON.parse(saved) : {};
      });
      
      const [xpToAdd, setXpToAdd] = React.useState("");
      const [selectedChars, setSelectedChars] = React.useState([]);
      const [xpLog, setXpLog] = React.useState(() => {
        const saved = localStorage.getItem("xpLog");
        return saved ? JSON.parse(saved) : [];
      });
      
      // XP thresholds for each level (0-indexed, so level 1 is index 0)
      const levelThresholds = [
        0, 300, 900, 2700, 6500, 14000, 23000, 34000, 48000, 64000,
        85000, 100000, 120000, 140000, 165000, 195000, 225000, 265000, 305000, 355000
      ];
      
      React.useEffect(() => {
        localStorage.setItem("characterXp", JSON.stringify(xpByChar));
      }, [xpByChar]);
      
      React.useEffect(() => {
        localStorage.setItem("xpLog", JSON.stringify(xpLog));
      }, [xpLog]);
      
      // Initialize XP for new characters
      React.useEffect(() => {
        const updates = {};
        let hasUpdates = false;
        
        characters.forEach(char => {
          if (!xpByChar[char.id]) {
            updates[char.id] = {
              xp: 0,
              level: 1,
              name: char.name
            };
            hasUpdates = true;
          } else if (xpByChar[char.id].name !== char.name) {
            // Update name if it changed
            updates[char.id] = {
              ...xpByChar[char.id],
              name: char.name
            };
            hasUpdates = true;
          }
        });
        
        if (hasUpdates) {
          setXpByChar(prev => ({
            ...prev,
            ...updates
          }));
        }
      }, [characters, xpByChar]);
      
      function toggleCharSelection(charId) {
        setSelectedChars(prev => 
          prev.includes(charId)
            ? prev.filter(id => id !== charId)
            : [...prev, charId]
        );
      }
      
      function selectAllChars() {
        setSelectedChars(characters.map(char => char.id));
      }
      
      function deselectAllChars() {
        setSelectedChars([]);
      }
      
      function addXpToSelected() {
        const xp = parseInt(xpToAdd) || 0;
        if (xp <= 0 || selectedChars.length === 0) return;
        
        const timestamp = new Date().toISOString();
        
        // Update XP for selected characters
        setXpByChar(prev => {
          const updated = {...prev};
          
          selectedChars.forEach(charId => {
            if (!updated[charId]) return;
            
            const newXp = updated[charId].xp + xp;
            let newLevel = updated[charId].level;
            
            // Check for level up
            while (newLevel < 20 && newXp >= levelThresholds[newLevel]) {
              newLevel++;
            }
            
            updated[charId] = {
              ...updated[charId],
              xp: newXp,
              level: newLevel
            };
          });
          
          return updated;
        });
        
        // Log the XP gain
        setXpLog(prev => [
          {
            timestamp,
            xp,
            characters: selectedChars.map(id => ({
              id,
              name: xpByChar[id]?.name || "Unknown"
            })),
            note: ""
          },
          ...prev
        ]);
        
        // Reset input
        setXpToAdd("");
      }
      
      function getLevelProgressPercent(charId) {
        const char = xpByChar[charId];
        if (!char) return 0;
        
        // If max level
        if (char.level >= 20) return 100;
        
        const currentLevelXp = levelThresholds[char.level - 1];
        const nextLevelXp = levelThresholds[char.level];
        const xpIntoLevel = char.xp - currentLevelXp;
        const xpRequiredForNextLevel = nextLevelXp - currentLevelXp;
        
        return Math.min(100, (xpIntoLevel / xpRequiredForNextLevel) * 100);
      }
      
      function clearLog() {
        if (confirm("Are you sure you want to clear the XP log?")) {
          setXpLog([]);
        }
      }
      
      function formatDate(timestamp) {
        const date = new Date(timestamp);
        return date.toLocaleString();
      }
      
      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">XP Tracker</h2>
          
          {/* XP Controls */}
          <div className="bg-white p-3 rounded shadow mb-4">
            <div className="flex flex-wrap gap-2 items-end mb-4">
              <div>
                <label className="block text-sm mb-1">XP to Add:</label>
                <input
                  type="number"
                  className="border rounded p-1 w-24"
                  value={xpToAdd}
                  onChange={e => setXpToAdd(e.target.value)}
                  min="0"
                />
              </div>
              <button
                className="px-3 py-1 bg-green-500 text-white rounded"
                onClick={addXpToSelected}
                disabled={!xpToAdd || selectedChars.length === 0}
              >
                Add XP to Selected
              </button>
              <button
                className="px-3 py-1 bg-blue-500 text-white rounded"
                onClick={selectAllChars}
              >
                Select All
              </button>
              <button
                className="px-3 py-1 bg-gray-500 text-white rounded"
                onClick={deselectAllChars}
              >
                Deselect All
              </button>
            </div>
            
            {/* Character XP List */}
            <div className="space-y-2">
              {characters.map(char => {
                const charXp = xpByChar[char.id] || { xp: 0, level: 1 };
                const progressPercent = getLevelProgressPercent(char.id);
                
                return (
                  <div 
                    key={char.id} 
                    className={`p-2 border rounded flex flex-col ${
                      selectedChars.includes(char.id) ? "border-blue-500 bg-blue-50" : ""
                    }`}
                    onClick={() => toggleCharSelection(char.id)}
                  >
                    <div className="flex justify-between items-center">
                      <div className="font-semibold">{char.name}</div>
                      <div className="flex items-center gap-2">
                        <span className="text-sm bg-purple-100 px-2 py-1 rounded-full">
                          Level {charXp.level}
                        </span>
                        <span className="text-sm bg-green-100 px-2 py-1 rounded-full">
                          {charXp.xp.toLocaleString()} XP
                        </span>
                      </div>
                    </div>
                    {/* Level Progress Bar */}
                    {charXp.level < 20 && (
                      <div className="mt-1">
                        <div className="w-full bg-gray-200 rounded-full h-2">
                          <div
                            className="bg-blue-500 rounded-full h-2"
                            style={{ width: `${progressPercent}%` }}
                          ></div>
                        </div>
                        <div className="flex justify-between text-xs text-gray-500 mt-1">
                          <span>Level {charXp.level}</span>
                          {charXp.level < 20 && (
                            <span>
                              {charXp.xp.toLocaleString()} / {levelThresholds[charXp.level].toLocaleString()} XP
                            </span>
                          )}
                          <span>Level {charXp.level + 1}</span>
                        </div>
                      </div>
                    )}
                  </div>
                );
              })}
            </div>
          </div>
          
          {/* XP Log */}
          <div>
            <div className="flex justify-between items-center mb-2">
              <h3 className="font-bold">XP Log</h3>
              {xpLog.length > 0 && (
                <button
                  className="px-2 py-1 bg-red-500 text-white rounded text-sm"
                  onClick={clearLog}
                >
                  Clear Log
                </button>
              )}
            </div>
            <div className="bg-white p-3 rounded shadow max-h-60 overflow-y-auto">
              {xpLog.length > 0 ? (
                <ul className="space-y-2">
                  {xpLog.map((entry, idx) => (
                    <li key={idx} className="border-b pb-1">
                      <div className="text-xs text-gray-500">{formatDate(entry.timestamp)}</div>
                      <div>
                        <span className="text-green-600 font-semibold">
                          +{entry.xp.toLocaleString()} XP
                        </span>
                        <span> awarded to </span>
                        <span className="text-blue-600">
                          {entry.characters.map(c => c.name).join(", ")}
                        </span>
                      </div>
                      {entry.note && <div className="text-sm text-gray-600">{entry.note}</div>}
                    </li>
                  ))}
                </ul>
              ) : (
                <p className="text-center text-gray-500 p-4">No XP awards logged yet</p>
              )}
            </div>
          </div>
        </div>
      );
    }

    /* ---------------------------
       SpellLookup Component
       - Quick reference for spells
    ---------------------------- */
    function SpellLookup() {
      const [searchTerm, setSearchTerm] = React.useState("");
      const [spellCache, setSpellCache] = React.useState(() => {
        const saved = localStorage.getItem("cachedSpells");
        return saved ? JSON.parse(saved) : {};
      });
      const [favorites, setFavorites] = React.useState(() => {
        const saved = localStorage.getItem("favoriteSpells");
        return saved ? JSON.parse(saved) : [];
      });
      
      React.useEffect(() => {
        localStorage.setItem("cachedSpells", JSON.stringify(spellCache));
      }, [spellCache]);
      
      React.useEffect(() => {
        localStorage.setItem("favoriteSpells", JSON.stringify(favorites));
      }, [favorites]);
      
      function toggleFavorite(spellName) {
        setFavorites(prev => 
          prev.includes(spellName)
            ? prev.filter(name => name !== spellName)
            : [...prev, spellName]
        );
      }
      
      // This component would typically connect to a spell API or database
      // For this demo, we'll use a simplified approach with a few example spells
      const exampleSpells = {
        "Fireball": {
          name: "Fireball",
          level: 3,
          school: "Evocation",
          castingTime: "1 action",
          range: "150 feet",
          components: "V, S, M (a tiny ball of bat guano and sulfur)",
          duration: "Instantaneous",
          description: "A bright streak flashes from your pointing finger to a point you choose within range and then blossoms with a low roar into an explosion of flame. Each creature in a 20-foot-radius sphere centered on that point must make a Dexterity saving throw. A target takes 8d6 fire damage on a failed save, or half as much damage on a successful one. The fire spreads around corners. It ignites flammable objects in the area that aren't being worn or carried.",
          higherLevels: "When you cast this spell using a spell slot of 4th level or higher, the damage increases by 1d6 for each slot level above 3rd."
        },
        "Cure Wounds": {
          name: "Cure Wounds",
          level: 1,
          school: "Evocation",
          castingTime: "1 action",
          range: "Touch",
          components: "V, S",
          duration: "Instantaneous",
          description: "A creature you touch regains a number of hit points equal to 1d8 + your spellcasting ability modifier. This spell has no effect on undead or constructs.",
          higherLevels: "When you cast this spell using a spell slot of 2nd level or higher, the healing increases by 1d8 for each slot level above 1st."
        },
        "Magic Missile": {
          name: "Magic Missile",
          level: 1,
          school: "Evocation",
          castingTime: "1 action",
          range: "120 feet",
          components: "V, S",
          duration: "Instantaneous",
          description: "You create three glowing darts of magical force. Each dart hits a creature of your choice that you can see within range. A dart deals 1d4 + 1 force damage to its target. The darts all strike simultaneously, and you can direct them to hit one creature or several.",
          higherLevels: "When you cast this spell using a spell slot of 2nd level or higher, the spell creates one more dart for each slot level above 1st."
        },
        "Mage Hand": {
          name: "Mage Hand",
          level: 0,
          school: "Conjuration",
          castingTime: "1 action",
          range: "30 feet",
          components: "V, S",
          duration: "1 minute",
          description: "A spectral, floating hand appears at a point you choose within range. The hand lasts for the duration or until you dismiss it as an action. The hand vanishes if it is ever more than 30 feet away from you or if you cast this spell again. You can use your action to control the hand. You can use the hand to manipulate an object, open an unlocked door or container, stow or retrieve an item from an open container, or pour the contents out of a vial. You can move the hand up to 30 feet each time you use it. The hand can't attack, activate magic items, or carry more than 10 pounds.",
          higherLevels: ""
        },
        "Hold Person": {
          name: "Hold Person",
          level: 2,
          school: "Enchantment",
          castingTime: "1 action",
          range: "60 feet",
          components: "V, S, M (a small, straight piece of iron)",
          duration: "Concentration, up to 1 minute",
          description: "Choose a humanoid that you can see within range. The target must succeed on a Wisdom saving throw or be paralyzed for the duration. At the end of each of its turns, the target can make another Wisdom saving throw. On a success, the spell ends on the target.",
          higherLevels: "When you cast this spell using a spell slot of 3rd level or higher, you can target one additional humanoid for each slot level above 2nd. The humanoids must be within 30 feet of each other when you target them."
        }
      };
      
      const filteredSpellNames = Object.keys(exampleSpells).filter(
        name => name.toLowerCase().includes(searchTerm.toLowerCase())
      );
      
      return (
        <div className="bg-gray-100 p-4 rounded-lg">
          <h2 className="text-xl font-bold mb-2">Spell Lookup</h2>
          
          <div className="bg-white p-3 rounded shadow mb-4">
            <div className="flex gap-2 mb-4">
              <input
                className="border rounded p-2 flex-grow"
                placeholder="Search for a spell..."
                value={searchTerm}
                onChange={e => setSearchTerm(e.target.value)}
              />
            </div>
            
            {/* Favorites Section */}
            {favorites.length > 0 && (
              <div className="mb-4">
                <h3 className="font-semibold mb-2">Favorites</h3>
                <div className="flex flex-wrap gap-2">
                  {favorites.map(spellName => (
                    <button
                      key={spellName}
                      className="px-2 py-1 bg-yellow-100 border border-yellow-300 rounded text-sm"
                      onClick={() => setSearchTerm(spellName)}
                    >
                      {spellName}
                    </button>
                  ))}
                </div>
              </div>
            )}
            
            {/* Search Results */}
            <div className="space-y-4">
              {filteredSpellNames.length > 0 ? (
                filteredSpellNames.map(spellName => {
                  const spell = exampleSpells[spellName];
                  
                  return (
                    <div key={spellName} className="border rounded p-3">
                      <div className="flex justify-between items-start">
                        <div>
                          <h4 className="font-bold">{spell.name}</h4>
                          <div className="text-sm">
                            <span className={`italic ${spell.level === 0 ? 'text-gray-600' : 'text-blue-600'}`}>
                              {spell.level === 0 ? 'Cantrip' : `Level ${spell.level}`}
                            </span>
                            <span> • </span>
                            <span className="text-purple-600">{spell.school}</span>
                          </div>
                        </div>
                        <button
                          className="text-yellow-500 hover:text-yellow-600"
                          onClick={() => toggleFavorite(spellName)}
                        >
                          {favorites.includes(spellName) ? "★" : "☆"}
                        </button>
                      </div>
                      
                      <div className="mt-2 grid grid-cols-2 gap-2 text-sm">
                        <div>
                          <span className="font-semibold">Casting Time:</span> {spell.castingTime}
                        </div>
                        <div>
                          <span className="font-semibold">Range:</span> {spell.range}
                        </div>
                        <div>
                          <span className="font-semibold">Components:</span> {spell.components}
                        </div>
                        <div>
                          <span className="font-semibold">Duration:</span> {spell.duration}
                        </div>
                      </div>
                      
                      <div className="mt-2 text-sm">
                        <p>{spell.description}</p>
                        {spell.higherLevels && (
                          <p className="mt-1"><span className="font-semibold">At Higher Levels:</span> {spell.higherLevels}</p>
                        )}
                      </div>
                    </div>
                  );
                })
              ) : (
                <div className="text-center text-gray-500 p-4">
                  {searchTerm ? "No spells found matching your search" : "Search for a spell by name"}
                </div>
              )}
            </div>
          </div>
        </div>
      );
    }

    /* ---------------------------
       Main DnDTracker
       - Includes all sections with new copy button and monster list
    ---------------------------- */
    function DnDTracker() {
      const [characters, setCharacters] = React.useState(() => {
        const saved = localStorage.getItem("characters");
        return saved
          ? JSON.parse(saved)
          : [
              {
                id: 1,
                name: "Jory",
                class: "Cleric",
                health: 100,
                maxHealth: 100,
                status: [],
                effects: [],
                inventory: ["Mace", "Shield"],
                specialAbilities:specialAbilities: ["Turn Undead"],
                spellsMagic: ["Cure Wounds"],
                image: null,
              },
            ];
      });

      const [enemies, setEnemies] = React.useState(() => {
        const saved = localStorage.getItem("enemies");
        return saved ? JSON.parse(saved) : [];
      });

      const [statRows, setStatRows] = React.useState(() => {
        const saved = localStorage.getItem("statRows");
        return saved
          ? JSON.parse(saved)
          : [{ id: 1, label: "Character #1", str: 10, dex: 10, con: 10, int: 10, wis: 10, cha: 10 }];
      });

      const [mapImage, setMapImage] = React.useState(() => localStorage.getItem("mapImage") || null);
      const [dotPositions, setDotPositions] = React.useState(() => {
        const saved = localStorage.getItem("dotPositions");
        return saved ? JSON.parse(saved) : [];
      });
      
      // New state for expanded features
      const [activeTab, setActiveTab] = React.useState(() => {
        const saved = localStorage.getItem("activeTab");
        return saved || "party";
      });

      React.useEffect(() => {
        localStorage.setItem("characters", JSON.stringify(characters));
      }, [characters]);

      React.useEffect(() => {
        localStorage.setItem("enemies", JSON.stringify(enemies));
      }, [enemies]);

      React.useEffect(() => {
        localStorage.setItem("statRows", JSON.stringify(statRows));
      }, [statRows]);

      React.useEffect(() => {
        localStorage.setItem("mapImage", mapImage);
        localStorage.setItem("dotPositions", JSON.stringify(dotPositions));
      }, [mapImage, dotPositions]);
      
      React.useEffect(() => {
        localStorage.setItem("activeTab", activeTab);
      }, [activeTab]);

      function addCharacter() {
        const newId = Date.now();
        setCharacters((prev) => [
          ...prev,
          {
            id: newId,
            name: "New Character",
            class: "Unassigned",
            health: 50,
            maxHealth: 50,
            status: [],
            effects: [],
            inventory: [],
            specialAbilities: [],
            spellsMagic: [],
            image: null,
          },
        ]);
      }

      function removeCharacter(charId) {
        setCharacters((prev) => prev.filter((c) => c.id !== charId));
      }

      function updateCharacter(updated) {
        setCharacters((prev) => prev.map((c) => (c.id === updated.id ? updated : c)));
      }

      function healCharacter(charId, amount) {
        setCharacters((prev) =>
          prev.map((c) => (c.id === charId ? { ...c, health: Math.min(c.maxHealth, c.health + amount) } : c))
        );
      }

      function damageCharacter(charId, amount) {
        setCharacters((prev) =>
          prev.map((c) => (c.id === charId ? { ...c, health: Math.max(0, c.health - amount) } : c))
        );
      }

      function removeStatus(charId, idx) {
        setCharacters((prev) =>
          prev.map((c) => {
            if (c.id === charId) {
              const updated = [...c.status];
              updated.splice(idx, 1);
              return { ...c, status: updated };
            }
            return c;
          })
        );
      }

      function removeEffect(charId, idx) {
        setCharacters((prev) =>
          prev.map((c) => {
            if (c.id === charId) {
              const updated = [...c.effects];
              updated.splice(idx, 1);
              return { ...c, effects: updated };
            }
            return c;
          })
        );
      }

      function removeItem(charId, idx) {
        setCharacters((prev) =>
          prev.map((c) => {
            if (c.id === charId) {
              const updated = [...c.inventory];
              updated.splice(idx, 1);
              return { ...c, inventory: updated };
            }
            return c;
          })
        );
      }

      function removeAbility(charId, idx) {
        setCharacters((prev) =>
          prev.map((c) => {
            if (c.id === charId) {
              const updated = [...c.specialAbilities];
              updated.splice(idx, 1);
              return { ...c, specialAbilities: updated };
            }
            return c;
          })
        );
      }

      function removeSpell(charId, idx) {
        setCharacters((prev) =>
          prev.map((c) => {
            if (c.id === charId) {
              const updated = [...c.spellsMagic];
              updated.splice(idx, 1);
              return { ...c, spellsMagic: updated };
            }
            return c;
          })
        );
      }

      function addEnemy() {
        setEnemies((prev) => [
          ...prev,
          {
            id: Date.now(),
            name: `Enemy ${prev.length + 1}`,
            health: 50,
            maxHealth: 50,
          },
        ]);
      }

      function removeEnemy(enemyId) {
        setEnemies((prev) => prev.filter((e) => e.id !== enemyId));
      }

      function healEnemy(enemyId, amount) {
        setEnemies((prev) =>
          prev.map((e) => (e.id === enemyId ? { ...e, health: Math.min(e.maxHealth, e.health + amount) } : e))
        );
      }

      function damageEnemy(enemyId, amount) {
        setEnemies((prev) =>
          prev.map((e) => (e.id === enemyId ? { ...e, health: Math.max(0, e.health - amount) } : e))
        );
      }

      function updateEnemy(updated) {
        setEnemies((prev) => prev.map((e) => (e.id === updated.id ? updated : e)));
      }

      return (
        <div className="container mx-auto p-4">
          <div className="mb-4">
            <CopyButton characters={characters} enemies={enemies} />
          </div>
          
          {/* Navigation Tabs */}
          <div className="flex flex-wrap gap-2 mb-4">
            <button
              className={`px-3 py-1 rounded ${activeTab === 'party' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
              onClick={() => setActiveTab('party')}
            >
              Party Status
            </button>
            <button
              className={`px-3 py-1 rounded ${activeTab === 'stats' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
              onClick={() => setActiveTab('stats')}
            >
              Stats
            </button>
            <button
              className={`px-3 py-1 rounded ${activeTab === 'combat' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
              onClick={() => setActiveTab('combat')}
            >
              Combat Tools
            </button>
            <button
              className={`px-3 py-1 rounded ${activeTab === 'rests' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
              onClick={() => setActiveTab('rests')}
            >
              Rest & Recovery
            </button>
            <button
              className={`px-3 py-1 rounded ${activeTab === 'magic' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
              onClick={() => setActiveTab('magic')}
            >
              Magic & Spells
            </button>
            <button
              className={`px-3 py-1 rounded ${activeTab === 'progression' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
              onClick={() => setActiveTab('progression')}
            >
              XP & Levels
            </button>
            <button
              className={`px-3 py-1 rounded ${activeTab === 'world' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
              onClick={() => setActiveTab('world')}
            >
              World & Campaign
            </button>
            <button
              className={`px-3 py-1 rounded ${activeTab === 'references' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
              onClick={() => setActiveTab('references')}
            >
              References
            </button>
          </div>

          <div className="grid gap-4">
            {/* Party Status Tab */}
            {activeTab === 'party' && (
              <>
                {/* Party Status */}
                <div className="bg-gray-100 p-4 rounded-lg">
                  <div className="flex justify-between items-center mb-4">
                    <h2 className="text-xl font-bold">Party Status</h2>
                    <button
                      className="px-3 py-1 bg-green-500 text-white rounded"
                      onClick={addCharacter}
                    >
                      Add Character
                    </button>
                  </div>
                  <div className="grid gap-4">
                    {characters.map((char) => (
                      <CharacterCard
                        key={char.id}
                        char={char}
                        onRemoveChar={removeCharacter}
                        onUpdateChar={updateCharacter}
                        onHeal={healCharacter}
                        onDamage={damageCharacter}
                        onRemoveStatus={removeStatus}
                        onRemoveEffect={removeEffect}
                        onRemoveItem={removeItem}
                        onRemoveAbility={removeAbility}
                        onRemoveSpell={removeSpell}
                      />
                    ))}
                  </div>
                </div>

                {/* Party Images Section */}
                <PartyImages characters={characters} />
                
                {/* Currency Tracker */}
                <CurrencyTracker />
              </>
            )}
            
            {/* Stats Tab */}
            {activeTab === 'stats' && (
              <>
                {/* Stats Section */}
                <StatsSection statRows={statRows} setStatRows={setStatRows} />
                
                {/* Rest Tracker with Hit Dice */}
                <RestTracker 
                  characters={characters}
                  onHeal={healCharacter}
                />
              </>
            )}
            
            {/* Combat Tools Tab */}
            {activeTab === 'combat' && (
              <>
                {/* Enemy Section */}
                <div className="bg-gray-100 p-4 rounded-lg">
                  <div className="flex justify-between items-center mb-4">
                    <h2 className="text-xl font-bold">Enemies</h2>
                    <button
                      className="px-3 py-1 bg-purple-500 text-white rounded"
                      onClick={addEnemy}
                    >
                      Add Enemy
                    </button>
                  </div>
                  <div className="grid gap-4">
                    {enemies.map((enemy) => (
                      <EnemyCard
                        key={enemy.id}
                        enemy={enemy}
                        onRemoveEnemy={removeEnemy}
                        onHealEnemy={healEnemy}
                        onDamageEnemy={damageEnemy}
                        onUpdateEnemy={updateEnemy}
                      />
                    ))}
                  </div>
                </div>
                
                {/* Initiative Tracker */}
                <InitiativeTracker />
                
                {/* Combat Log */}
                <CombatLog />
                
                {/* Map Section */}
                <MapSection
                  mapImage={mapImage}
                  setMapImage={setMapImage}
                  dotPositions={dotPositions}
                  setDotPositions={setDotPositions}
                />
                
                {/* Dice Roller */}
                <DiceRoller />
              </>
            )}
            
            {/* Rest & Recovery Tab */}
            {activeTab === 'rests' && (
              <>
                {/* Rest Tracker */}
                <RestTracker 
                  characters={characters}
                  onHeal={healCharacter}
                />
                
                {/* Time & Weather Tracker */}
                <WeatherTimeTracker />
              </>
            )}
            
            {/* Magic & Spells Tab */}
            {activeTab === 'magic' && (
              <>
                {/* Spell Tracker */}
                <SpellTracker 
                  characters={characters}
                  onUpdateChar={updateCharacter}
                />
                
                {/* Spell Lookup */}
                <SpellLookup />
              </>
            )}
            
            {/* XP & Levels Tab */}
            {activeTab === 'progression' && (
              <>
                {/* XP Tracker */}
                <XpTracker
                  characters={characters}
                  onUpdateChar={updateCharacter}
                />
              </>
            )}
            
            {/* World & Campaign Tab */}
            {activeTab === 'world' && (
              <>
                {/* Campaign Notes */}
                <NotepadComponent />
                
                {/* Time & Weather Tracker */}
                <WeatherTimeTracker />
              </>
            )}
            
            {/* References Tab */}
            {activeTab === 'references' && (
              <>
                {/* Conditions Reference */}
                <ConditionReference />
                
                {/* Classes Section */}
                <ClassesSection />

                {/* Races Section */}
                <RacesSection />

                {/* Monster/Creature List Section */}
                <MonsterCreatureList />
              </>
            )}
          </div>
        </div>
      );
    }

    // Render the main tracker
    ReactDOM.render(<DnDTracker />, document.getElementById("root"));
  </script>
</body>
</html>
