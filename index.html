<script type="text/babel">
  // [Previous unchanged component definitions up to CharacterCard]

  /** 4) CharacterCard (Updated with Ability Scores and Temp HP) */
  function CharacterCard({
    char,
    collapsed,
    onToggleCollapse,
    onUpdateChar,
    onHeal,
    onDamage,
    onRemoveStatus,
    onRemoveEffect,
    onRemoveItem,
    onRemoveAbility,
    onRemoveSpell,
    onRemoveChar,
  }) {
    const [isEditing, setIsEditing] = React.useState(false);
    const [editName, setEditName] = React.useState(char.name);
    const [editClass, setEditClass] = React.useState(char.class);
    const [editMaxHealth, setEditMaxHealth] = React.useState(String(char.maxHealth));
    const [editLevel, setEditLevel] = React.useState(String(char.level || 1));
    const [editXP, setEditXP] = React.useState(String(char.xp || 0));
    const [editInitiative, setEditInitiative] = React.useState(String(char.initiative || 0));
    const [editNotes, setEditNotes] = React.useState(char.notes || "");
    const [editStr, setEditStr] = React.useState(String(char.str || 10)); // New
    const [editDex, setEditDex] = React.useState(String(char.dex || 10)); // New
    const [editCon, setEditCon] = React.useState(String(char.con || 10)); // New
    const [editInt, setEditInt] = React.useState(String(char.int || 10)); // New
    const [editWis, setEditWis] = React.useState(String(char.wis || 10)); // New
    const [editCha, setEditCha] = React.useState(String(char.cha || 10)); // New
    const [newStatus, setNewStatus] = React.useState("");
    const [newEffect, setNewEffect] = React.useState("");
    const [newItem, setNewItem] = React.useState("");
    const [newAbility, setNewAbility] = React.useState("");
    const [newSpell, setNewSpell] = React.useState("");
    const [healInput, setHealInput] = React.useState("0");
    const [dmgInput, setDmgInput] = React.useState("0");
    const [tempHpInput, setTempHpInput] = React.useState("0"); // New

    React.useEffect(() => {
      setEditName(char.name);
      setEditClass(char.class);
      setEditMaxHealth(String(char.maxHealth));
      setEditLevel(String(char.level || 1));
      setEditXP(String(char.xp || 0));
      setEditInitiative(String(char.initiative || 0));
      setEditNotes(char.notes || "");
      setEditStr(String(char.str || 10)); // New
      setEditDex(String(char.dex || 10)); // New
      setEditCon(String(char.con || 10)); // New
      setEditInt(String(char.int || 10)); // New
      setEditWis(String(char.wis || 10)); // New
      setEditCha(String(char.cha || 10)); // New
    }, [char]);

    function handleSave() {
      const parsedMax = parseInt(editMaxHealth, 10) || 0;
      const clippedHealth = Math.min(char.health, parsedMax);
      onUpdateChar({
        ...char,
        name: editName,
        class: editClass,
        maxHealth: parsedMax,
        health: clippedHealth,
        level: parseInt(editLevel, 10) || 1,
        xp: parseInt(editXP, 10) || 0,
        initiative: parseInt(editInitiative, 10) || 0,
        notes: editNotes,
        str: parseInt(editStr, 10) || 10, // New
        dex: parseInt(editDex, 10) || 10, // New
        con: parseInt(editCon, 10) || 10, // New
        int: parseInt(editInt, 10) || 10, // New
        wis: parseInt(editWis, 10) || 10, // New
        cha: parseInt(editCha, 10) || 10, // New
      });
      setIsEditing(false);
    }

    // [Other functions like handleAddStatus, handleImageUpload remain unchanged]

    function applyTempHp() { // New
      onUpdateChar({ ...char, tempHealth: parseInt(tempHpInput, 10) || 0 });
    }

    const computeMod = (score) => Math.floor((score - 10) / 2) >= 0 ? `+${Math.floor((score - 10) / 2)}` : `${Math.floor((score - 10) / 2)}`;

    if (isEditing) {
      return (
        <div className="bg-white p-4 rounded-lg shadow space-y-2 mb-4">
          <div className="flex justify-between items-center">
            <h3 className="font-bold">Editing {char.name}</h3>
            <button className="px-2 py-1 bg-red-500 text-white rounded hover:bg-red-600" onClick={() => onRemoveChar(char.id)}>Remove</button>
          </div>
          <div className="grid grid-cols-2 gap-2">
            <input className="border p-1 rounded" placeholder="Name" value={editName} onChange={(e) => setEditName(e.target.value)} />
            <input className="border p-1 rounded" placeholder="Class" value={editClass} onChange={(e) => setEditClass(e.target.value)} />
            <input type="number" className="border p-1 rounded" placeholder="Max Health" value={editMaxHealth} onChange={(e) => setEditMaxHealth(e.target.value)} />
            <input type="number" className="border p-1 rounded" placeholder="Level" value={editLevel} onChange={(e) => setEditLevel(e.target.value)} />
            <input type="number" className="border p-1 rounded" placeholder="XP" value={editXP} onChange={(e) => setEditXP(e.target.value)} />
            <input type="number" className="border p-1 rounded" placeholder="Initiative" value={editInitiative} onChange={(e) => setEditInitiative(e.target.value)} />
          </div>
          <div className="grid grid-cols-3 gap-2 mt-2"> {/* New Ability Scores in Edit Mode */}
            <input type="number" className="border p-1 rounded" placeholder="STR" value={editStr} onChange={(e) => setEditStr(e.target.value)} />
            <input type="number" className="border p-1 rounded" placeholder="DEX" value={editDex} onChange={(e) => setEditDex(e.target.value)} />
            <input type="number" className="border p-1 rounded" placeholder="CON" value={editCon} onChange={(e) => setEditCon(e.target.value)} />
            <input type="number" className="border p-1 rounded" placeholder="INT" value={editInt} onChange={(e) => setEditInt(e.target.value)} />
            <input type="number" className="border p-1 rounded" placeholder="WIS" value={editWis} onChange={(e) => setEditWis(e.target.value)} />
            <input type="number" className="border p-1 rounded" placeholder="CHA" value={editCha} onChange={(e) => setEditCha(e.target.value)} />
          </div>
          <textarea className="border p-1 rounded w-full" rows={3} placeholder="Notes / Bio" value={editNotes} onChange={(e) => setEditNotes(e.target.value)} />
          <div className="flex gap-2">
            <button className="px-3 py-1 bg-green-500 text-white rounded hover:bg-green-600" onClick={handleSave}>Save</button>
            <button className="px-2 py-1 bg-gray-400 text-white rounded hover:bg-gray-500" onClick={() => setIsEditing(false)}>Cancel</button>
          </div>
        </div>
      );
    }

    return (
      <div className={`bg-white p-4 rounded-lg shadow mb-4 ${collapsed ? "collapsed" : ""}`}>
        {/* [Header remains unchanged] */}
        <div className="collapsible-content transition-all duration-300 ease-in-out" style={collapsed ? { maxHeight: 0, padding: 0 } : { maxHeight: "9999px" }}>
          <div className={collapsed ? "hidden" : "block"}>
            <div className="flex items-center gap-2 mt-2">
              <span className="text-red-600 font-bold">♥</span>
              <div className="w-full bg-gray-200 rounded-full h-4">
                <div className="bg-red-600 rounded-full h-4" style={{ width: (char.health / char.maxHealth) * 100 + "%" }}></div>
              </div>
              <span className="text-sm">{char.health}/{char.maxHealth}</span>
              {char.tempHealth > 0 && <span className="text-sm text-blue-600">+{char.tempHealth} Temp</span>} {/* New */}
            </div>
            <div className="mt-2"> {/* New Ability Scores */}
              <h4 className="font-semibold text-sm">Ability Scores</h4>
              <div className="grid grid-cols-3 gap-2">
                {["str", "dex", "con", "int", "wis", "cha"].map((stat) => (
                  <div key={stat} className="flex flex-col">
                    <label className="font-semibold text-xs uppercase">{stat}</label>
                    <span className="text-sm">{char[stat] || 10} ({computeMod(char[stat] || 10)})</span>
                  </div>
                ))}
              </div>
            </div>
            {/* [Other sections like Status Conditions, Effects remain unchanged] */}
            <div className="mt-4 flex gap-4 flex-wrap">
              <div>
                <label className="text-sm block">Heal #</label>
                <div className="flex items-center gap-2">
                  <input type="number" className="w-16 border rounded p-1 text-sm" value={healInput} onChange={(e) => setHealInput(e.target.value)} />
                  <button className="px-3 py-1 bg-green-500 text-white rounded hover:bg-green-600 text-sm" onClick={() => onHeal(char.id, parseInt(healInput, 10) || 0)}>Heal</button>
                </div>
              </div>
              <div>
                <label className="text-sm block">Damage #</label>
                <div className="flex items-center gap-2">
                  <input type="number" className="w-16 border rounded p-1 text-sm" value={dmgInput} onChange={(e) => setDmgInput(e.target.value)} />
                  <button className="px-3 py-1 bg-red-500 text-white rounded hover:bg-red-600 text-sm" onClick={() => onDamage(char.id, parseInt(dmgInput, 10) || 0)}>Damage</button>
                </div>
              </div>
              <div> {/* New Temp HP Input */}
                <label className="text-sm block">Temp HP</label>
                <div className="flex items-center gap-2">
                  <input type="number" className="w-16 border rounded p-1 text-sm" value={tempHpInput} onChange={(e) => setTempHpInput(e.target.value)} />
                  <button className="px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm" onClick={applyTempHp}>Set Temp HP</button>
                </div>
              </div>
            </div>
            {/* [Death Saves and Notes remain unchanged] */}
          </div>
        </div>
      </div>
    );
  }

  /** 5) EnemyCard (Updated with Temp HP and Initiative) */
  function EnemyCard({ enemy, collapsed, onToggleCollapse, onHealEnemy, onDamageEnemy, onRemoveEnemy, onUpdateEnemy }) {
    const [isEditing, setIsEditing] = React.useState(false);
    const [editName, setEditName] = React.useState(enemy.name);
    const [editMaxHealth, setEditMaxHealth] = React.useState(String(enemy.maxHealth));
    const [editHealth, setEditHealth] = React.useState(String(enemy.health));
    const [editInitiative, setEditInitiative] = React.useState(String(enemy.initiative || 0)); // New
    const [healInput, setHealInput] = React.useState("0");
    const [dmgInput, setDmgInput] = React.useState("0");
    const [tempHpInput, setTempHpInput] = React.useState("0"); // New

    function handleSave() {
      const parsedMax = parseInt(editMaxHealth, 10) || 0;
      const parsedHealth = parseInt(editHealth, 10) || 0;
      const clippedHealth = Math.min(parsedHealth, parsedMax);
      onUpdateEnemy({
        ...enemy,
        name: editName,
        maxHealth: parsedMax,
        health: clippedHealth,
        initiative: parseInt(editInitiative, 10) || 0, // New
      });
      setIsEditing(false);
    }

    function applyTempHp() { // New
      onUpdateEnemy({ ...enemy, tempHealth: parseInt(tempHpInput, 10) || 0 });
    }

    if (isEditing) {
      return (
        <div className="bg-white p-4 rounded-lg shadow space-y-2 mb-4">
          <div className="flex justify-between items-center">
            <h3 className="font-bold">Editing Enemy</h3>
            <button className="px-2 py-1 bg-red-500 text-white rounded hover:bg-red-600" onClick={() => onRemoveEnemy(enemy.id)}>Defeat</button>
          </div>
          <div className="flex flex-col gap-2">
            <input className="border p-1 rounded" placeholder="Name" value={editName} onChange={(e) => setEditName(e.target.value)} />
            <input type="number" className="border p-1 rounded" placeholder="Max Health" value={editMaxHealth} onChange={(e) => setEditMaxHealth(e.target.value)} />
            <input type="number" className="border p-1 rounded" placeholder="Current Health" value={editHealth} onChange={(e) => setEditHealth(e.target.value)} />
            <input type="number" className="border p-1 rounded" placeholder="Initiative" value={editInitiative} onChange={(e) => setEditInitiative(e.target.value)} /> {/* New */}
            <div className="flex gap-2">
              <button className="px-3 py-1 bg-green-500 text-white rounded hover:bg-green-600" onClick={handleSave}>Save</button>
              <button className="px-2 py-1 bg-gray-400 text-white rounded hover:bg-gray-500" onClick={() => setIsEditing(false)}>Cancel</button>
            </div>
          </div>
        </div>
      );
    }

    return (
      <div className={`bg-white p-4 rounded-lg shadow mb-4 ${collapsed ? "collapsed" : ""}`}>
        {/* [Header remains unchanged] */}
        <div className="collapsible-content transition-all duration-300 ease-in-out" style={collapsed ? { maxHeight: 0, padding: 0 } : { maxHeight: "9999px" }}>
          <div className={collapsed ? "hidden" : "block"}>
            <div className="flex items-center gap-2 mt-2">
              <span className="text-red-600 font-bold">♥</span>
              <div className="w-full bg-gray-200 rounded-full h-4">
                <div className="bg-red-600 rounded-full h-4" style={{ width: (enemy.health / enemy.maxHealth) * 100 + "%" }}></div>
              </div>
              <span className="text-sm">{enemy.health}/{enemy.maxHealth}</span>
              {enemy.tempHealth > 0 && <span className="text-sm text-blue-600">+{enemy.tempHealth} Temp</span>} {/* New */}
            </div>
            <div className="mt-4 flex gap-4 flex-wrap">
              <div>
                <label className="text-sm block">Heal #</label>
                <div className="flex items-center gap-2">
                  <input type="number" className="w-16 border rounded p-1 text-sm" value={healInput} onChange={(e) => setHealInput(e.target.value)} />
                  <button className="px-3 py-1 bg-green-500 text-white rounded hover:bg-green-600 text-sm" onClick={() => onHealEnemy(enemy.id, parseInt(healInput, 10) || 0)}>Heal</button>
                </div>
              </div>
              <div>
                <label className="text-sm block">Damage #</label>
                <div className="flex items-center gap-2">
                  <input type="number" className="w-16 border rounded p-1 text-sm" value={dmgInput} onChange={(e) => setDmgInput(e.target.value)} />
                  <button className="px-3 py-1 bg-red-500 text-white rounded hover:bg-red-600 text-sm" onClick={() => onDamageEnemy(enemy.id, parseInt(dmgInput, 10) || 0)}>Damage</button>
                </div>
              </div>
              <div> {/* New Temp HP Input */}
                <label className="text-sm block">Temp HP</label>
                <div className="flex items-center gap-2">
                  <input type="number" className="w-16 border rounded p-1 text-sm" value={tempHpInput} onChange={(e) => setTempHpInput(e.target.value)} />
                  <button className="px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm" onClick={applyTempHp}>Set Temp HP</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  }

  /** 9) PartyImages (Updated with Larger Images) */
  function PartyImages({ characters }) {
    return (
      <div className="bg-gray-100 p-4 rounded-lg mb-4">
        <h2 className="text-xl font-bold mb-2">Party Member Images</h2>
        <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4 max-h-72 overflow-y-auto">
          {characters.map((char) => (
            <div key={char.id} className="text-center">
              {char.image ? (
                <img src={char.image} alt={char.name} className="w-24 h-24 object-cover rounded-full mx-auto" />
              ) : (
                <div className="w-24 h-24 bg-gray-300 rounded-full mx-auto flex items-center justify-center">
                  <span className="text-gray-500 text-sm">No Image</span>
                </div>
              )}
              <p className="mt-1 text-sm">{char.name}</p>
            </div>
          ))}
        </div>
      </div>
    );
  }

  /** 15) Main DnDTracker (Updated with Initiative Tracker and Turn Counter) */
  function DnDTracker() {
    const [collapsedCharacters, toggleCharacterCollapse] = useCollapseState("collapsedCharacters");
    const [collapsedEnemies, toggleEnemyCollapse] = useCollapseState("collapsedEnemies");
    const [characters, setCharacters] = React.useState(() => {
      const saved = localStorage.getItem("characters");
      let loaded = saved ? JSON.parse(saved) : [{
        id: 1,
        name: "Jory",
        class: "Cleric",
        health: 100,
        maxHealth: 100,
        tempHealth: 0, // New
        str: 10, dex: 10, con: 10, int: 10, wis: 10, cha: 10, // New
        status: [],
        effects: [],
        inventory: ["Mace", "Shield"],
        specialAbilities: ["Turn Undead"],
        spellsMagic: ["Cure Wounds"],
        image: null,
        level: 1,
        xp: 0,
        initiative: 0,
        notes: "",
        deathSaves: { success: 0, fail: 0 },
      }];
      return loaded.map((c) => ({
        ...c,
        level: c.level || 1,
        xp: c.xp || 0,
        initiative: c.initiative || 0,
        notes: c.notes || "",
        deathSaves: c.deathSaves || { success: 0, fail: 0 },
        tempHealth: c.tempHealth || 0, // New
        str: c.str || 10, dex: c.dex || 10, con: c.con || 10, int: c.int || 10, wis: c.wis || 10, cha: c.cha || 10, // New
      }));
    });
    const [enemies, setEnemies] = React.useState(() => {
      const saved = localStorage.getItem("enemies");
      return saved ? JSON.parse(saved).map(e => ({ ...e, tempHealth: e.tempHealth || 0, initiative: e.initiative || 0 })) : []; // New
    });
    const [statRows, setStatRows] = React.useState(() => {
      const saved = localStorage.getItem("statRows");
      return saved ? JSON.parse(saved) : [{ id: 1, label: "Jory", str: 10, dex: 10, con: 10, int: 10, wis: 10, cha: 10 }];
    });
    const [mapImage, setMapImage] = React.useState(() => localStorage.getItem("mapImage") || null);
    const [dotPositions, setDotPositions] = React.useState(() => {
      const saved = localStorage.getItem("dotPositions");
      return saved ? JSON.parse(saved) : [];
    });
    const [round, setRound] = React.useState(1); // New

    React.useEffect(() => {
      localStorage.setItem("characters", JSON.stringify(characters));
    }, [characters]);
    React.useEffect(() => {
      localStorage.setItem("enemies", JSON.stringify(enemies));
    }, [enemies]);
    // [Other useEffect hooks remain unchanged]

    function addCharacter() {
      const newId = Date.now();
      setCharacters((prev) => [
        ...prev,
        {
          id: newId,
          name: "New Character",
          class: "Unassigned",
          health: 50,
          maxHealth: 50,
          tempHealth: 0, // New
          str: 10, dex: 10, con: 10, int: 10, wis: 10, cha: 10, // New
          status: [],
          effects: [],
          inventory: [],
          specialAbilities: [],
          spellsMagic: [],
          image: null,
          level: 1,
          xp: 0,
          initiative: 0,
          notes: "",
          deathSaves: { success: 0, fail: 0 },
        },
      ]);
    }

    function damageCharacter(charId, amt) { // Updated for Temp HP
      setCharacters((prev) => prev.map((c) => {
        if (c.id === charId) {
          let remainingDamage = amt;
          let newTempHealth = c.tempHealth;
          let newHealth = c.health;
          if (newTempHealth > 0) {
            if (newTempHealth >= remainingDamage) {
              newTempHealth -= remainingDamage;
              remainingDamage = 0;
            } else {
              remainingDamage -= newTempHealth;
              newTempHealth = 0;
            }
          }
          if (remainingDamage > 0) {
            newHealth = Math.max(0, newHealth - remainingDamage);
          }
          return { ...c, tempHealth: newTempHealth, health: newHealth };
        }
        return c;
      }));
    }

    function damageEnemy(enemyId, amt) { // Updated for Temp HP
      setEnemies((prev) => prev.map((e) => {
        if (e.id === enemyId) {
          let remainingDamage = amt;
          let newTempHealth = e.tempHealth;
          let newHealth = e.health;
          if (newTempHealth > 0) {
            if (newTempHealth >= remainingDamage) {
              newTempHealth -= remainingDamage;
              remainingDamage = 0;
            } else {
              remainingDamage -= newTempHealth;
              newTempHealth = 0;
            }
          }
          if (remainingDamage > 0) {
            newHealth = Math.max(0, newHealth - remainingDamage);
          }
          return { ...e, tempHealth: newTempHealth, health: newHealth };
        }
        return e;
      }));
    }

    // [Other functions like healCharacter, removeStatus remain unchanged]

    const allParticipants = [
      ...characters.map((c) => ({ type: "character", id: c.id, name: c.name, initiative: c.initiative || 0 })),
      ...enemies.map((e) => ({ type: "enemy", id: e.id, name: e.name, initiative: e.initiative || 0 })),
    ].sort((a, b) => b.initiative - a.initiative); // New

    return (
      <div className="container mx-auto p-4 space-y-4">
        {/* [DarkModeToggle and Backup/Restore remain unchanged] */}
        <div className="mb-4">
          <CopyButton characters={characters} enemies={enemies} />
        </div>
        <div className="grid gap-4">
          <div className="bg-gray-100 p-4 rounded-lg mb-4"> {/* New Initiative Tracker and Turn Counter */}
            <h2 className="text-xl font-bold mb-2">Initiative Order</h2>
            <div className="flex items-center gap-2 mb-2">
              <span className="font-bold">Round: {round}</span>
              <button className="px-2 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm" onClick={() => setRound((prev) => prev + 1)}>Next Round</button>
              <button className="px-2 py-1 bg-gray-500 text-white rounded hover:bg-gray-600 text-sm" onClick={() => setRound(1)}>Reset</button>
            </div>
            <ul className="space-y-2">
              {allParticipants.map((p) => (
                <li key={p.id} className="flex items-center gap-2">
                  <span>{p.name} ({p.type})</span>
                  <input
                    type="number"
                    className="w-16 border rounded p-1 text-sm"
                    value={p.initiative}
                    onChange={(e) => {
                      const val = parseInt(e.target.value, 10) || 0;
                      if (p.type === "character") {
                        updateCharacter({ ...characters.find((c) => c.id === p.id), initiative: val });
                      } else {
                        updateEnemy({ ...enemies.find((e) => e.id === p.id), initiative: val });
                      }
                    }}
                  />
                </li>
              ))}
            </ul>
          </div>
          {/* [Party Status, PartyImages, StatsSection, Enemies, etc., remain unchanged] */}
        </div>
      </div>
    );
  }

  ReactDOM.render(<DnDTracker />, document.getElementById("root"));
</script>
